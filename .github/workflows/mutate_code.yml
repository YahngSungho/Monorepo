name: Mutate Code

on:
  pull_request:
    types: [opened, synchronize, labeled]

env:
  HUSKY: 0

permissions:
  pull-requests: write # PR에 댓글을 작성하는 데 필요
  issues: read # 이슈 댓글을 읽는 데 필요
  contents: write

jobs:
  initiate:
    runs-on: ubuntu-latest
    if: |
      (github.event.action == 'labeled' && github.event.label.name == 'restart') ||
      (github.event.action != 'labeled' &&
        !contains(github.event.pull_request.labels.*.name, 'mutation-finished') &&
        !contains(github.event.head_commit.message, '[automated-mutation]'))
    steps:
      - name: Attempt to Cancel Auto Merge if Enabled
        uses: actions/github-script@v7
        with:
          script: |
            const prNodeId = context.payload.pull_request.node_id; // 이벤트 페이로드에서 PR의 node_id 가져오기
            const prNumber = context.issue.number;
            const owner = context.repo.owner; // 필요시 로그 출력용
            const repo = context.repo.repo; // 필요시 로그 출력용

            if (!prNodeId) {
              console.log(`PR #${prNumber}에 대한 컨텍스트에서 Pull Request Node ID를 가져올 수 없습니다.`);
              // 만약 context에 node_id가 없다면, API로 다시 조회해야 할 수 있지만,
              // pull_request 이벤트에서는 보통 포함되어 있습니다.
              core.setFailed("Pull Request Node ID를 결정할 수 없습니다.");
              return;
            }

            console.log(`GraphQL을 통해 PR #${prNumber} (Node ID: ${prNodeId})에 대한 자동 병합 비활성화를 시도합니다.`);

            try {
              // github.graphql을 사용하여 disablePullRequestAutoMerge 뮤테이션 실행
              await github.graphql(`
                mutation($prId: ID!) {
                  disablePullRequestAutoMerge(input: {pullRequestId: $prId}) {
                    clientMutationId
                  }
                }
              `, { prId: prNodeId });
              console.log(`✅ GraphQL을 통해 PR #${prNumber}에 대한 자동 병합이 성공적으로 비활성화되었습니다.`);
            } catch (error) {
              // GraphQL 오류 메시지를 확인하여 자동 병합이 활성화되지 않았는지 판단합니다.
              // 실제 오류 메시지에 따라 이 조건은 조정될 수 있습니다.
              if (error.message.includes("Pull request auto-merge cannot be disabled") || error.message.includes("Could not resolve to a PullRequest") || error.message.includes("already disabled")) {
                 console.log(`ℹ️ PR #${prNumber}에 대해 자동 병합이 활성화되지 않았거나 이미 비활성화되었습니다. (GraphQL 오류: ${error.message})`);
              } else {
                console.error(`❌ GraphQL을 통해 PR #${prNumber}에 대한 자동 병합 비활성화에 실패했습니다. 오류: ${error.message}`);
                // 필요시 오류를 다시 던져서 워크플로우 스텝을 실패시킬 수 있습니다.
                // core.setFailed(`GraphQL을 통한 자동 병합 비활성화 실패: ${error.message}`);
              }
            }
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Remove Label
        if: github.event.label.name == 'restart'
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.TOKEN1 }}
          script: |
            try {
              github.rest.issues.removeLabel({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                name: 'restart'
              });
              console.log('restart 라벨이 성공적으로 제거되었습니다.');
            } catch (error) {
              console.log('라벨 제거 중 오류가 발생했거나 라벨을 찾을 수 없습니다:', error);
            }

  # 공통 경로 필터링 job
  path-filter:
    runs-on: ubuntu-latest
    outputs:
      images: ${{ steps.filter.outputs.images }}
      markdown-json: ${{ steps.filter.outputs.markdown-json }}
      package-json: ${{ steps.filter.outputs.package-json }}
      projects: ${{ steps.filter.outputs.projects }}
      translation-targets: ${{ steps.filter.outputs.translation-targets }}
    needs: initiate
    steps:
      - uses: dorny/paths-filter@v3
        id: filter
        with:
          filters: |
            projects:
              - 'apps/**'
              - 'libraries/**'
              - 'storybook/**'
            images:
              - '**.jpg'
              - '**.jpeg'
              - '**.png'
              - '**.webp'
              - '**.gif'
              - '**.svg'
              - '**.pdf'
              - '**.tiff'
              - '**.magick'
              - '**.openslide'
              - '**.dz'
              - '**.ppm'
              - '**.fits'
              - '**.heif'
              - '**.vips'
              - '**.raw'
            markdown-json:
              - '**/*.md'
              - '**/*.mdx'
              - '**/*.json'
            translation-targets:
              - 'apps/**/*.md'
              - 'apps/**/*.mdx'
              - 'libraries/paraglide/messages/**/*.*'
              - 'libraries/paraglide/messages-helpers/**/*.*'
            package-json:
              - 'package.json'
              - '**/package.json'

  fix-package-json:
    runs-on: ubuntu-latest
    needs: path-filter
    if: needs.path-filter.outputs.package-json == 'true'
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
        with:
          ref: ${{ github.head_ref }}
          token: ${{ secrets.TOKEN1 }}
          fetch-depth: 0

      # pnpm 설치 (packageManager 버전과 일치)
      - name: Setup pnpm
        uses: pnpm/action-setup@v4
        with:
          run_install: false

      # Node.js 환경 설정 (package.json의 engines.node 버전과 일치)
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version-file: package.json
          cache: pnpm

      # 의존성 설치 최적화
      - name: Install dependencies 1
        run: pnpm install --no-frozen-lockfile

      - name: Fix Mismatches Versions
        run: pnpm run fix-mismatches

      - name: Check for Package.json changes 1
        id: check_package_json_changes
        run: |
          if git diff --quiet; then
            echo "Package.json 변경사항이 없습니다."
            echo "has_changes=false" >> $GITHUB_OUTPUT
          else
            echo "Package.json 변경사항이 있습니다."
            echo "has_changes=true" >> $GITHUB_OUTPUT
          fi

      - name: Install dependencies 2
        if: steps.check_package_json_changes.outputs.has_changes == 'true'
        run: pnpm install --no-frozen-lockfile

      - name: Check for Package.json changes 2 & Save .patch file
        run: git diff > package-json-changes.patch

      - name: Upload patch artifact
        if: steps.check_package_json_changes.outputs.has_changes == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: package-json-changes-patch
          path: package-json-changes.patch

  update-translation:
    runs-on: ubuntu-latest
    needs: [path-filter, fix-package-json]
    if: |
      needs.path-filter.outputs.translation-targets == 'true' && !failure() && !cancelled()
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
        with:
          ref: ${{ github.head_ref }}
          token: ${{ secrets.TOKEN1 }}
          fetch-depth: 0

      # 1. package-json 패치 다운로드
      - name: Check if package-json patch exists
        id: check_package_json_patch
        uses: actions/github-script@v6
        with:
          script: |
            const artifacts = await github.rest.actions.listWorkflowRunArtifacts({
              owner: context.repo.owner,
              repo: context.repo.repo,
              run_id: context.runId
            });
            const matchArtifact = artifacts.data.artifacts.find(
              artifact => artifact.name === "package-json-changes-patch"
            );
            return !!matchArtifact;

      - name: Download package-json patch artifact
        if: steps.check_package_json_patch.outputs.result == 'true'
        uses: actions/download-artifact@v4
        with:
          name: package-json-changes-patch
          path: .

      # 2. package-json 패치 적용
      - name: Apply package-json patch
        if: steps.check_package_json_patch.outputs.result == 'true'
        run: |
          if [ -f package-json-changes.patch ]; then
            echo "package.json 포맷팅 변경사항 패치를 적용합니다..."
            # --check 옵션으로 적용 가능 여부 확인
            if ! git apply --check package-json-changes.patch; then
              echo "::error::package-json-changes.patch 확인에 실패했습니다. 깔끔하게 적용할 수 없습니다."
              # 여기서 실패 처리 또는 경고 후 진행 결정 필요 (우선 실패 처리)
              exit 1
            fi
            # 실제 패치 적용
            git apply package-json-changes.patch
            echo "package.json 포맷팅 패치가 성공적으로 적용되었습니다."
            rm package-json-changes.patch
          else
            echo "적용할 package.json 포맷팅 변경사항이 없습니다."
          fi

      # 3. pnpm 설치 및 의존성 설치 (패치 적용 후)
      - name: Setup pnpm
        uses: pnpm/action-setup@v4
        with:
          run_install: false
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version-file: package.json
          cache: pnpm
      - name: Install dependencies
        run: pnpm install --prefer-offline # 패치 적용된 package.json/lock 기준

      # 4. 임시 커밋 생성 (패치 + 설치 후 상태 기준)
      - name: Create temporary commit for diff base
        run: |
          echo "--- Creating temporary commit ---"
          git config user.name "GitHub Actions Temp"
          git config user.email "actions-temp@github.com"
          echo "Status before temporary commit 'git add .':"
          git status --short
          git add . # 모든 변경사항 스테이징 (패치 적용 + install 결과 포함)
          echo "Status after temporary commit 'git add .' and before 'git commit':"
          git status --short
          echo "Diff of staged changes for temporary commit:"
          git diff --staged --stat # 스테이징된 내용 확인
          if ! git diff --staged --quiet; then
            git commit -m "Temporary commit after applying package-json patch and install"
            echo "Temporary commit created. HEAD is now at $(git rev-parse HEAD)"
          else
            echo "No changes to commit temporarily before translation."
          fi
          echo "--- Finished temporary commit ---"

      # 5. 번역 실행
      - name: Run Translation
        run: |
          echo "--- Running Translation (pnpm run translate) ---"
          pnpm run translate
          echo "--- Finished Translation ---"
          echo "Status after 'pnpm run translate' (before creating patch):"
          git status --short # 번역 실행 직후 상태 확인 (새 파일이 untracked로 보여야 함)
          echo "List all files (for debugging new file creation):"
          find . -type f -ls # 모든 파일 목록과 상세 정보 출력 (특히 번역 결과물이 생성될 것으로 예상되는 경로 확인)
        env:
          GOOGLE_GENERATIVE_AI_API_KEY: ${{ secrets.GOOGLE_GENERATIVE_AI_API_KEY }}

      # 6. 번역 변경사항 패치 생성 (임시 커밋 기준)
      - name: Check for Translation changes and create patch
        id: check_translation_changes
        run: |
          echo "--- Creating translation patch against HEAD ($(git rev-parse HEAD)) ---"
          echo "Running 'git status --short' before diff to see current state:"
          git status --short # diff 직전 상태 재확인
          echo "Running 'git diff --stat HEAD' to see changes:"
          git diff --stat HEAD # 어떤 파일이 변경으로 감지되는지 통계 보기

          # '--exit-code'를 사용하여 스크립트에서 변경 유무를 더 안정적으로 확인
          if ! git diff --quiet HEAD --exit-code; then
            echo "Translation 변경사항이 있습니다."
            echo "has_changes=true" >> $GITHUB_OUTPUT
            # cache.json 파일의 변경이 너무 클 경우, 다음 라인의 주석을 해제하여 cache.json을 제외하고 패치를 생성해볼 수 있습니다.
            # git diff HEAD -- . ':!*.cache.json' > translation-changes.patch
            git diff HEAD > translation-changes.patch # 임시 커밋과의 차이 저장
            echo "translation-changes.patch content:"
            cat translation-changes.patch # 생성된 패치 내용 출력
          else
            echo "Translation 변경사항이 없습니다."
            echo "has_changes=false" >> $GITHUB_OUTPUT
          fi
          echo "--- Finished creating translation patch ---"

      # 7. 번역 패치 업로드
      - name: Upload translation patch artifact
        if: steps.check_translation_changes.outputs.has_changes == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: translation-changes-patch
          path: translation-changes.patch

  fix-markdown-json:
    runs-on: ubuntu-latest
    needs: [path-filter, fix-package-json, update-translation]
    if: |
      needs.path-filter.outputs.markdown-json == 'true' && !failure() && !cancelled()
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
        with:
          ref: ${{ github.head_ref }}
          token: ${{ secrets.TOKEN1 }}
          fetch-depth: 0

      # 1. package-json 패치 다운로드
      - name: Check if package-json patch exists
        id: check_package_json_patch
        uses: actions/github-script@v6
        with:
          script: |
            const artifacts = await github.rest.actions.listWorkflowRunArtifacts({
              owner: context.repo.owner,
              repo: context.repo.repo,
              run_id: context.runId
            });
            const matchArtifact = artifacts.data.artifacts.find(
              artifact => artifact.name === "package-json-changes-patch"
            );
            return !!matchArtifact;

      - name: Download package-json patch artifact
        if: steps.check_package_json_patch.outputs.result == 'true'
        uses: actions/download-artifact@v4
        with:
          name: package-json-changes-patch
          path: .

      # 2. package-json 패치 적용
      - name: Apply package-json patch
        if: steps.check_package_json_patch.outputs.result == 'true'
        run: |
          if [ -f package-json-changes.patch ]; then
            echo "package.json 포맷팅 변경사항 패치를 적용합니다..."
            # --check 옵션으로 적용 가능 여부 확인
            if ! git apply --check package-json-changes.patch; then
              echo "::error::package-json-changes.patch 확인에 실패했습니다. 깔끔하게 적용할 수 없습니다."
              # 여기서 실패 처리 또는 경고 후 진행 결정 필요 (우선 실패 처리)
              exit 1
            fi
            # 실제 패치 적용
            git apply package-json-changes.patch
            echo "package.json 포맷팅 패치가 성공적으로 적용되었습니다."
            rm package-json-changes.patch
          else
            echo "적용할 package.json 포맷팅 변경사항이 없습니다."
          fi


      # 3. translation patch 다운로드
      - name: Check if translation patch exists
        id: check_translation_patch
        uses: actions/github-script@v6
        with:
          script: |
            const artifacts = await github.rest.actions.listWorkflowRunArtifacts({
              owner: context.repo.owner,
              repo: context.repo.repo,
              run_id: context.runId
            });
            const matchArtifact = artifacts.data.artifacts.find(
              artifact => artifact.name === "translation-changes-patch"
            );
            return !!matchArtifact;

      - name: Download translation patch artifact
        if: steps.check_translation_patch.outputs.result == 'true'
        uses: actions/download-artifact@v4
        with:
          name: translation-changes-patch
          path: .

      # 4. translation patch 적용
      - name: Apply translation patch
        if: steps.check_translation_patch.outputs.result == 'true'
        run: |
          if [ -f translation-changes.patch ]; then
            echo "번역 변경사항 패치를 적용합니다..."
            # --check 옵션으로 적용 가능 여부 확인
            if ! git apply --check translation-changes.patch; then
              echo "::error::translation-changes.patch 확인에 실패했습니다. 깔끔하게 적용할 수 없습니다."
              # 여기서 실패 처리 또는 경고 후 진행 결정 필요 (우선 실패 처리)
              exit 1
            fi
            # 실제 패치 적용
            git apply translation-changes.patch
            echo "번역 패치가 성공적으로 적용되었습니다."
            rm translation-changes.patch
          else
            echo "적용할 번역 변경사항이 없습니다."
          fi

      # 5. pnpm 설치 및 의존성 설치 (패치 적용 후)
      - name: Setup pnpm
        uses: pnpm/action-setup@v4
        with:
          run_install: false
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version-file: package.json
          cache: pnpm
      - name: Install dependencies
        run: pnpm install --prefer-offline # 패치 적용된 package.json/lock 기준

      # 6. 임시 커밋 생성 (패치 + 설치 후 상태 기준)
      - name: Create temporary commit for diff base
        run: |
          git config user.name "GitHub Actions Temp"
          git config user.email "actions-temp@github.com"
          git add . # 모든 변경사항 스테이징 (패치 적용 + install 결과 포함)
          if ! git diff --staged --quiet; then
            git commit -m "Temporary commit after applying package-json patch and install"
          else
            echo "마크다운 수정 전 임시로 커밋할 변경사항이 없습니다."
          fi

      # 7. 마크다운 수정 도구 실행
      - name: Fix Markdown (markdownlint)
        uses: DavidAnson/markdownlint-cli2-action@v19
        with:
          globs: |
            **/*.md
            **/*.mdx
            **/*.mdc
            !**/node_modules/**
          config: .markdownlint.json
          fix: true
        continue-on-error: true

      # pnpm 설치 (packageManager 버전과 일치) - 중복 제거
      # Node.js 환경 설정 (package.json의 engines.node 버전과 일치) - 중복 제거
      # 의존성 설치 최적화 - 중복 제거

      - name: Lint Fix Markdown Files (eslint-md-json)
        run: pnpm run eslint-md-json
        continue-on-error: true # ESLint 오류 시 워크플로우 중단 방지 (선택 사항)

      - name: Stylelint Fix Markdown Files (stylelint-md-json)
        run: pnpm run stylelint-md-json
        continue-on-error: true # Stylelint 오류 시 워크플로우 중단 방지 (선택 사항)

      - name: Format Markdown (prettier)
        run: pnpm run format-md-json

      # 8. 마크다운 변경사항 패치 생성 (임시 커밋 기준)
      - name: Check for Markdown-json changes and create patch
        id: check_markdown_json_changes
        run: |
          # --> 수정: git diff HEAD 사용하여 패치 생성
          if ! git diff --quiet HEAD; then # HEAD (임시 커밋)와 비교
            echo "Markdown-json 변경사항이 있습니다."
            echo "has_changes=true" >> $GITHUB_OUTPUT
            git diff HEAD > markdown-changes.patch # 임시 커밋과의 차이 저장
          else
            echo "Markdown-json 변경사항이 없습니다."
            echo "has_changes=false" >> $GITHUB_OUTPUT
            # touch markdown-changes.patch # --> 삭제: 변경사항 없을 시 빈 파일 생성 안 함
          fi

      # 9. 마크다운 패치 업로드
      - name: Upload markdown patch artifact
        if: steps.check_markdown_json_changes.outputs.has_changes == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: markdown-json-changes-patch
          path: markdown-json-changes.patch

  lint-format:
    runs-on: ubuntu-latest
    # fix-package-json 잡이 완료된 후 실행되도록 명시적 의존성 추가
    needs: [path-filter, fix-package-json, update-translation, fix-markdown-json]
    # --> 수정: fix-package-json이 성공하거나 스킵되었을 때 실행하도록 조건 변경
    if: |
      needs.path-filter.outputs.projects == 'true' && !failure() && !cancelled()
    env:
      TURBO_TOKEN: ${{ secrets.TURBO_TOKEN }}
      TURBO_TEAM: ${{ vars.TURBO_TEAM }}
      HUSKY: 0
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
        with:
          ref: ${{ github.head_ref }}
          token: ${{ secrets.TOKEN1 }} # 필요시 토큰 사용
          fetch-depth: 0 # diff를 위해

      # 1. package-json 패치 다운로드
      - name: Check if package-json patch exists
        id: check_package_json_patch
        uses: actions/github-script@v6
        with:
          script: |
            const artifacts = await github.rest.actions.listWorkflowRunArtifacts({
              owner: context.repo.owner,
              repo: context.repo.repo,
              run_id: context.runId
            });
            const matchArtifact = artifacts.data.artifacts.find(
              artifact => artifact.name === "package-json-changes-patch"
            );
            return !!matchArtifact;

      - name: Download package-json patch artifact
        if: steps.check_package_json_patch.outputs.result == 'true'
        uses: actions/download-artifact@v4
        with:
          name: package-json-changes-patch
          path: .

      # 2. package-json 패치 적용
      - name: Apply package-json patch
        if: steps.check_package_json_patch.outputs.result == 'true'
        run: |
          if [ -f package-json-changes.patch ]; then
            echo "package.json 포맷팅 변경사항 패치를 적용합니다..."
            # --check 옵션으로 적용 가능 여부 확인
            if ! git apply --check package-json-changes.patch; then
              echo "::error::package-json-changes.patch 확인에 실패했습니다. 깔끔하게 적용할 수 없습니다."
              # 여기서 실패 처리 또는 경고 후 진행 결정 필요 (우선 실패 처리)
              exit 1
            fi
            # 실제 패치 적용
            git apply package-json-changes.patch
            echo "package.json 포맷팅 패치가 성공적으로 적용되었습니다."
            rm package-json-changes.patch
          else
            echo "적용할 package.json 포맷팅 변경사항이 없습니다."
          fi


      # 3. translation patch 다운로드
      - name: Check if translation patch exists
        id: check_translation_patch
        uses: actions/github-script@v6
        with:
          script: |
            const artifacts = await github.rest.actions.listWorkflowRunArtifacts({
              owner: context.repo.owner,
              repo: context.repo.repo,
              run_id: context.runId
            });
            const matchArtifact = artifacts.data.artifacts.find(
              artifact => artifact.name === "translation-changes-patch"
            );
            return !!matchArtifact;

      - name: Download translation patch artifact
        if: steps.check_translation_patch.outputs.result == 'true'
        uses: actions/download-artifact@v4
        with:
          name: translation-changes-patch
          path: .

      # 4. translation patch 적용
      - name: Apply translation patch
        if: steps.check_translation_patch.outputs.result == 'true'
        run: |
          if [ -f translation-changes.patch ]; then
            echo "번역 변경사항 패치를 적용합니다..."
            # --check 옵션으로 적용 가능 여부 확인
            if ! git apply --check translation-changes.patch; then
              echo "::error::translation-changes.patch 확인에 실패했습니다. 깔끔하게 적용할 수 없습니다."
              # 여기서 실패 처리 또는 경고 후 진행 결정 필요 (우선 실패 처리)
              exit 1
            fi
            # 실제 패치 적용
            git apply translation-changes.patch
            echo "번역 패치가 성공적으로 적용되었습니다."
            rm translation-changes.patch
          else
            echo "적용할 번역 변경사항이 없습니다."
          fi

      # 5. markdown-json patch 다운로드
      - name: Check if markdown-json patch exists
        id: check_markdown_json_patch
        uses: actions/github-script@v6
        with:
          script: |
            const artifacts = await github.rest.actions.listWorkflowRunArtifacts({
              owner: context.repo.owner,
              repo: context.repo.repo,
              run_id: context.runId
            });
            const matchArtifact = artifacts.data.artifacts.find(
              artifact => artifact.name === "markdown-json-changes-patch"
            );
            return !!matchArtifact;

      - name: Download markdown-json patch artifact
        if: steps.check_markdown_json_patch.outputs.result == 'true'
        uses: actions/download-artifact@v4
        with:
          name: markdown-json-changes-patch
          path: .

      # 6. markdown-json patch 적용
      - name: Apply markdown-json patch
        if: steps.check_markdown_json_patch.outputs.result == 'true'
        run: |
          if [ -f markdown-json-changes.patch ]; then
            echo "markdown-json 변경사항 패치를 적용합니다..."
            # --check 옵션으로 적용 가능 여부 확인
            if ! git apply --check markdown-json-changes.patch; then
              echo "::error::markdown-json-changes.patch 확인에 실패했습니다. 깔끔하게 적용할 수 없습니다."
              # 여기서 실패 처리 또는 경고 후 진행 결정 필요 (우선 실패 처리)
              exit 1
            fi
            # 실제 패치 적용
            git apply markdown-json-changes.patch
            echo "markdown-json 패치가 성공적으로 적용되었습니다."
            rm markdown-json-changes.patch
          else
            echo "적용할 markdown-json 변경사항이 없습니다."
          fi

      # Node.js 및 pnpm 설정
      - name: Setup pnpm
        uses: pnpm/action-setup@v4
        with:
          run_install: false
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version-file: package.json
          cache: pnpm

      # 패치 적용 후 의존성 설치 (lint-fix 실행 위해)
      - name: Install dependencies after patch
        # 패치가 적용되었거나, 원래 package.json 변경 감지 시 실행 (필요 따라 조건 조정)
        run: pnpm install --prefer-offline

      # 임시 커밋 생성 (git diff 기준점 마련)
      - name: Create temporary commit for diff base
        run: |
          git config user.name "GitHub Actions Temp"
          git config user.email "actions-temp@github.com"
          git add . # 모든 변경사항 스테이징
          # 변경사항이 있을 때만 커밋 시도
          if ! git diff --staged --quiet; then
            git commit -m "Temporary commit after applying package-json patch"
          else
            echo "임시로 커밋할 변경사항이 없습니다."
          fi

      # 린트 실행
      - name: Run Lint & Format
        run: pnpm run lint-fix

      # changes.patch 생성 (임시 커밋 기준) 및 변경 유무 출력
      - name: Create changes.patch based on temporary commit
        id: create_changes_patch
        run: |
          # lint-fix로 변경사항이 생겼는지 확인
          if ! git diff --quiet HEAD; then # --> 수정: --quiet 뒤에 HEAD 추가 (임시 커밋과 비교)
            echo "린트 및 포맷팅 후 변경사항 감지됨. Creating changes.patch..."
            # HEAD (임시 커밋) 와 현재 작업 디렉토리의 차이를 패치 파일로 저장
            git diff HEAD > changes.patch
            echo "has_changes=true" >> $GITHUB_OUTPUT # --> 추가: 변경 있음 출력
          else
            echo "린트 및 포맷팅 후 추가 변경사항 없음."
            # touch changes.patch # --> 삭제: 빈 파일 생성 안 함
            echo "has_changes=false" >> $GITHUB_OUTPUT # --> 추가: 변경 없음 출력
          fi
      # patch 파일을 artifact로 업로드 (변경사항 있을 때만)
      - name: Upload changes.patch artifact
        uses: actions/upload-artifact@v4
        if: steps.create_changes_patch.outputs.has_changes == 'true' # --> 추가: 조건부 실행
        with:
          name: changes-patch
          path: changes.patch

  compress-images:
    runs-on: ubuntu-latest
    needs: path-filter
    if: needs.path-filter.outputs.images == 'true'
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
        with:
          ref: ${{ github.head_ref }}
          token: ${{ secrets.TOKEN1 }}
          fetch-depth: 0

      - name: Compress Images
        uses: calibreapp/image-actions@main
        with:
          githubToken: ${{ secrets.GITHUB_TOKEN }}
          compressOnly: true

      # 추가: 이미지 압축 후 수정사항을 patch 파일로 생성
      - name: Check for image changes
        id: check_image_changes
        run: |
          if git diff --quiet; then
            echo "이미지 압축 후 변경사항이 없습니다."
            echo "has_changes=false" >> $GITHUB_OUTPUT
          else
            echo "이미지 압축 후 변경사항이 감지되었습니다."
            echo "has_changes=true" >> $GITHUB_OUTPUT
            git diff > images-changes.patch
          fi

      # 추가: patch 파일을 artifact로 업로드
      - name: Upload patch artifact
        if: steps.check_image_changes.outputs.has_changes == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: images-changes-patch
          path: images-changes.patch

  push-and-labeled:
    needs: [path-filter, compress-images, lint-format, fix-package-json, fix-markdown-json, update-translation]
    if: needs.path-filter.result == 'success' && !failure() && !cancelled()
    runs-on: ubuntu-latest

    steps:
      # 저장소 체크아웃 단계
      - name: Checkout Repository
        uses: actions/checkout@v4
        with:
          ref: ${{ github.head_ref }}
          token: ${{ secrets.TOKEN1 }}
          fetch-depth: 0 # diff를 위해 전체 히스토리 가져오기

      # 추가: 이전 job에서 생성한 patch artifact를 다운로드

      - name: Check if package-json patch exists
        id: check_package_json_patch
        uses: actions/github-script@v6
        with:
          script: |
            const artifacts = await github.rest.actions.listWorkflowRunArtifacts({
              owner: context.repo.owner,
              repo: context.repo.repo,
              run_id: context.runId
            });
            return !!artifacts.data.artifacts.find(artifact => artifact.name === "package-json-changes-patch");

      - name: Download package-json patch artifact
        if: steps.check_package_json_patch.outputs.result == 'true'
        uses: actions/download-artifact@v4
        with:
          name: package-json-changes-patch
          path: .

      - name: Check if translation patch exists
        id: check_translation_patch
        uses: actions/github-script@v6
        with:
          script: |
            const artifacts = await github.rest.actions.listWorkflowRunArtifacts({
              owner: context.repo.owner,
              repo: context.repo.repo,
              run_id: context.runId
            });
            const matchArtifact = artifacts.data.artifacts.find(
              artifact => artifact.name === "translation-changes-patch"
            );
            return !!matchArtifact;

      - name: Download translation patch artifact
        if: steps.check_translation_patch.outputs.result == 'true'
        uses: actions/download-artifact@v4
        with:
          name: translation-changes-patch
          path: .

      - name: Check if markdown-json patch exists
        id: check_markdown_json_patch
        uses: actions/github-script@v6
        with:
          script: |
            const artifacts = await github.rest.actions.listWorkflowRunArtifacts({
              owner: context.repo.owner,
              repo: context.repo.repo,
              run_id: context.runId
            });
            const matchArtifact = artifacts.data.artifacts.find(
              artifact => artifact.name === "markdown-json-changes-patch"
            );
            return !!matchArtifact;

      - name: Download markdown-json patch artifact
        if: steps.check_markdown_json_patch.outputs.result == 'true'
        uses: actions/download-artifact@v4
        with:
          name: markdown-json-changes-patch
          path: .

      - name: Check if changes patch exists
        id: check_changes_patch
        uses: actions/github-script@v6
        with:
          script: |
            const artifacts = await github.rest.actions.listWorkflowRunArtifacts({
              owner: context.repo.owner,
              repo: context.repo.repo,
              run_id: context.runId
            });
            const matchArtifact = artifacts.data.artifacts.find(
              artifact => artifact.name === "changes-patch"
            );
            return !!matchArtifact;

      - name: Download patch artifact
        if: steps.check_changes_patch.outputs.result == 'true'
        uses: actions/download-artifact@v4
        with:
          name: changes-patch
          path: .

      - name: Check if images patch exists
        id: check_images_patch
        uses: actions/github-script@v6
        with:
          script: |
            const artifacts = await github.rest.actions.listWorkflowRunArtifacts({
              owner: context.repo.owner,
              repo: context.repo.repo,
              run_id: context.runId
            });
            const matchArtifact = artifacts.data.artifacts.find(
              artifact => artifact.name === "images-changes-patch"
            );
            return !!matchArtifact;

      - name: Download images patch artifact
        if: steps.check_images_patch.outputs.result == 'true'
        uses: actions/download-artifact@v4
        with:
          name: images-changes-patch
          path: .

      # 추가: 다운로드한 patch 적용
      - name: Apply patches
        run: |
          echo "--- Applying Patches ---"
          apply_patch() {
            local patch_file="$1"
            local patch_name="$2"
            if [ -f "$patch_file" ]; then
              echo "Applying $patch_name patch ($patch_file)..."
              # 3-way merge 시도, 실패 시 일반 apply 시도
              if git apply --3way "$patch_file"; then
                 echo "$patch_name patch applied successfully with 3-way merge."
              elif git apply --check "$patch_file"; then
                git apply "$patch_file"
                if [ $? -eq 0 ]; then
                  echo "$patch_name patch applied successfully."
                else
                  echo "::error::Failed to apply $patch_name patch ($patch_file) even after check. Manual conflict resolution might be needed."
                  # exit 1 # 필요하다면 여기서 워크플로우 중단
                fi
              else
                echo "::warning::$patch_name patch ($patch_file) check failed. There might be conflicts."
                # git apply --reject "$patch_file" # 충돌 부분 .rej 파일로 남기고 적용 시도
                # echo "Attempted to apply $patch_name patch with --reject. Check for .rej files."
                # exit 1 # 필요하다면 여기서 워크플로우 중단
              fi
              rm "$patch_file" || echo "Could not remove $patch_file"
              echo "Current status after applying $patch_name patch:"
              git status --short # 각 패치 적용 후 상태 확인
            else
              echo "No $patch_name patch ($patch_file) to apply."
            fi
            echo "------------------------"
          }

          apply_patch "images-changes.patch" "Image compression"
          apply_patch "package-json-changes.patch" "Package.json formatting"
          apply_patch "translation-changes.patch" "Translation"
          apply_patch "markdown-json-changes.patch" "Markdown formatting"
          apply_patch "changes.patch" "Code formatting"

          echo "--- Finished Applying Patches ---"
          echo "Final status after all patches applied (before staging):"
          git status --short
          echo "Detailed diff stat after all patches applied (before staging):"
          git diff --stat # 실제 변경된 파일 통계 보기

      - name: Stage all changes after applying patches
        run: |
          echo "--- Staging all changes ---"
          echo "Status before 'git add -A':"
          git status --short # git add -A 실행 전 상태

          git add -A
          echo "Status after 'git add -A':"
          git status --short # git add -A 실행 후 상태 (이것이 매우 중요!)

          echo "Diff of staged changes:"
          git diff --staged --stat # 스테이징된 변경사항 통계 보기
          echo "--- Finished Staging ---"

      # 커밋 시도
      - name: Commit Changes
        id: auto-commit
        uses: stefanzweifel/git-auto-commit-action@v5
        with:
          commit_message: '[automated-mutation]'
          # 디버깅을 위해 커밋 액션의 로그를 더 자세히 보려면:
          # skip_dirty_check: true
          # skip_fetch: true
          # dry_run: true # 실제 커밋은 안하고 결과만 볼 때 (테스트용)
          # file_pattern: . # 명시적으로 모든 파일을 대상으로 지정

      # 커밋 결과 출력
      - name: Print Commit Result
        run: |
          if [ "${{ steps.auto-commit.outputs.changes_detected }}" == "true" ]; then
            echo "변경사항이 감지되어 자동으로 커밋되었습니다."
            echo "Commit ID: ${{ steps.auto-commit.outputs.commit_hash }}"
          else
            echo "커밋할 변경사항이 없습니다. 모든 코드가 이미 정상적으로 포맷팅되어 있거나 이미지가 이미 최적화되어 있습니다."
          fi

      # Add a Label to PR 1
      - name: Add a Label to PR 1
        if: steps.auto-commit.outputs.changes_detected == 'true'
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.TOKEN1 }}
          script: |
            github.rest.issues.addLabels({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              labels: ['mutated']
            })

      # 라벨 추가
      - name: Add a Label to PR 2
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.TOKEN1 }}
          script: |
            github.rest.issues.addLabels({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              labels: ['mutation-finished']
            })
