name: Mutate Code

on:
  pull_request:
    types: [opened, synchronize, labeled]

concurrency:
  group: ${{ github.workflow }}-${{ github.event.pull_request.number }}
  cancel-in-progress: true

env:
  HUSKY: 0

permissions:
  pull-requests: write # PR에 댓글을 작성하는 데 필요
  issues: read # 이슈 댓글을 읽는 데 필요
  contents: write

jobs:
  initiate:
    runs-on: ubuntu-latest
    if: |
      (github.event.action == 'labeled' && github.event.label.name == 'restart') ||
      (github.event.action != 'labeled' &&
        !contains(github.event.pull_request.labels.*.name, 'mutation-finished'))
    steps:
      - name: 자동 병합 활성화 시 취소 시도
        uses: actions/github-script@v7
        with:
          script: |
            const prNodeId = context.payload.pull_request.node_id; // 이벤트 페이로드에서 PR의 node_id 가져오기
            const prNumber = context.issue.number;
            const owner = context.repo.owner; // 필요시 로그 출력용
            const repo = context.repo.repo; // 필요시 로그 출력용

            if (!prNodeId) {
              console.log(`PR #${prNumber}에 대한 컨텍스트에서 Pull Request Node ID를 가져올 수 없습니다.`);
              // 만약 context에 node_id가 없다면, API로 다시 조회해야 할 수 있지만,
              // pull_request 이벤트에서는 보통 포함되어 있습니다.
              core.setFailed("Pull Request Node ID를 결정할 수 없습니다.");
              return;
            }

            console.log(`GraphQL을 통해 PR #${prNumber} (Node ID: ${prNodeId})에 대한 자동 병합 비활성화를 시도합니다.`);

            try {
              // github.graphql을 사용하여 disablePullRequestAutoMerge 뮤테이션 실행
              await github.graphql(`
                mutation($prId: ID!) {
                  disablePullRequestAutoMerge(input: {pullRequestId: $prId}) {
                    clientMutationId
                  }
                }
              `, { prId: prNodeId });
              console.log(`✅ GraphQL을 통해 PR #${prNumber}에 대한 자동 병합이 성공적으로 비활성화되었습니다.`);
            } catch (error) {
              // GraphQL 오류 메시지를 확인하여 자동 병합이 활성화되지 않았는지 판단합니다.
              // 실제 오류 메시지에 따라 이 조건은 조정될 수 있습니다.
              if (error.message.includes("Pull request auto-merge cannot be disabled") || error.message.includes("Could not resolve to a PullRequest") || error.message.includes("already disabled")) {
                 console.log(`ℹ️ PR #${prNumber}에 대해 자동 병합이 활성화되지 않았거나 이미 비활성화되었습니다. (GraphQL 오류: ${error.message})`);
              } else {
                console.error(`❌ GraphQL을 통해 PR #${prNumber}에 대한 자동 병합 비활성화에 실패했습니다. 오류: ${error.message}`);
                // 필요시 오류를 다시 던져서 워크플로우 스텝을 실패시킬 수 있습니다.
                // core.setFailed(`GraphQL을 통한 자동 병합 비활성화 실패: ${error.message}`);
              }
            }
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: 라벨 제거
        if: github.event.label.name == 'restart'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.TOKEN1 }}
          script: |
            try {
              await github.rest.issues.removeLabel({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                name: 'restart'
              });
              console.log('restart 라벨이 30초 대기 후 성공적으로 제거되었습니다.');
            } catch (error) {
              console.log('라벨 제거 중 오류가 발생했거나 라벨을 찾을 수 없습니다:', error);
            }

  # 공통 경로 필터링 job
  path-filter:
    runs-on: ubuntu-latest
    outputs:
      libraries_backends: ${{ steps.filter.outputs.libraries_backends }}
      images: ${{ steps.filter.outputs.images }}
      markdown: ${{ steps.filter.outputs.markdown }}
      package-json: ${{ steps.filter.outputs.package-json }}
      translation-targets: ${{ steps.filter.outputs.translation-targets }}
    needs: initiate
    steps:
      - uses: dorny/paths-filter@v3
        id: filter
        with:
          filters: |
            libraries_backends:
              - 'libraries/backends/**'
              - '**/wrangler.override.*'
            images:
              - '**/**.jpg'
              - '**/**.jpeg'
              - '**/**.png'
              - '**/**.webp'
              - '**/**.gif'
              - '**/**.svg'
              - '**/**.pdf'
              - '**/**.tiff'
              - '**/**.magick'
              - '**/**.openslide'
              - '**/**.dz'
              - '**/**.ppm'
              - '**/**.fits'
              - '**/**.heif'
              - '**/**.vips'
              - '**/**.raw'
            markdown:
              - '**/*.md'
              - '**/*.mdx'
              - '**/*.mdc'
              # - '**/*.json' <- 이걸 왜 추가했었지?
            translation-targets:
              - 'apps/**/*.md'
              - 'apps/**/*.mdx'
              - 'libraries/paraglide/messages/**/*.*'
              - 'libraries/paraglide/messages-helpers/**/*.*'
            package-json:
              - 'package.json'
              - '**/package.json'

  fix-package-json:
    runs-on: ubuntu-latest
    needs: path-filter
    if: needs.path-filter.outputs.package-json == 'true'
    steps:
      - name: 저장소 체크아웃
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.pull_request.head.sha }}
          token: ${{ secrets.TOKEN1 }}
          fetch-depth: 0

      # pnpm 설치 (packageManager 버전과 일치)
      - name: pnpm 설정
        uses: pnpm/action-setup@v4
        with:
          run_install: false

      # Node.js 환경 설정 (package.json의 engines.node 버전과 일치)
      - name: Node.js 설정
        uses: actions/setup-node@v4
        with:
          node-version-file: package.json
          cache: pnpm

      # 의존성 설치 최적화
      - name: 의존성 설치 1
        run: pnpm install --no-frozen-lockfile

      - name: 버전 불일치 수정
        run: pnpm run fix-mismatches

      - name: Package.json 변경사항 확인 1
        id: check_package-json_changes
        run: |
          if git diff --quiet; then
            echo "Package.json 변경사항이 없습니다."
            echo "has_changes=false" >> $GITHUB_OUTPUT
          else
            echo "Package.json 변경사항이 있습니다."
            echo "has_changes=true" >> $GITHUB_OUTPUT
          fi

      - name: 의존성 설치 2
        if: steps.check_package-json_changes.outputs.has_changes == 'true'
        run: pnpm install --no-frozen-lockfile

      - name: Package.json 변경사항 확인 2 & .patch 파일 저장
        run: git diff > package-json.patch

      - name: 패치 아티팩트 업로드
        if: steps.check_package-json_changes.outputs.has_changes == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: package-json-patch
          path: package-json.patch

  update-backend-config:
    runs-on: ubuntu-latest
    needs: [path-filter, fix-package-json]
    if: |
      needs.path-filter.outputs.libraries_backends == 'true' && !failure() && !cancelled()
    steps:
      - name: 저장소 체크아웃
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.pull_request.head.sha }}
          token: ${{ secrets.TOKEN1 }}
          fetch-depth: 0

      # package-json 패치 다운로드/적용 (fix-package-json 산출물 연동)
      - name: package-json 패치 존재 여부 확인 (backend)
        id: check_package-json_patch_backend
        uses: actions/github-script@v7
        with:
          script: |
            const artifacts = await github.rest.actions.listWorkflowRunArtifacts({
              owner: context.repo.owner,
              repo: context.repo.repo,
              run_id: context.runId
            });
            const matchArtifact = artifacts.data.artifacts.find(
              artifact => artifact.name === "package-json-patch"
            );
            return !!matchArtifact;

      - name: package-json 패치 아티팩트 다운로드 (backend)
        if: steps.check_package-json_patch_backend.outputs.result == 'true'
        uses: actions/download-artifact@v4
        with:
          name: package-json-patch
          path: .

      - name: package-json 패치 적용 (backend)
        if: steps.check_package-json_patch_backend.outputs.result == 'true'
        run: |
          if [ -f package-json.patch ]; then
            echo "package.json 포맷팅 변경사항 패치를 적용합니다 (backend)..."
            if ! git apply --check package-json.patch; then
              echo "::error::package-json.patch 확인에 실패했습니다. 깔끔하게 적용할 수 없습니다."
              exit 1
            fi
            git apply package-json.patch
            echo "package.json 포맷팅 패치가 성공적으로 적용되었습니다 (backend)."
            rm package-json.patch
          else
            echo "적용할 package.json 포맷팅 변경사항이 없습니다 (backend)."
          fi

      - name: pnpm 설정
        uses: pnpm/action-setup@v4
        with:
          run_install: false

      - name: Node.js 설정
        uses: actions/setup-node@v4
        with:
          node-version-file: package.json
          cache: pnpm

      - name: 의존성 설치
        run: pnpm install --prefer-offline

      # 임시 커밋 생성 (패치 + 설치 후 상태 기준) — backend build 전 기준점 마련
      - name: diff 비교를 위한 임시 커밋 생성 (backend)
        run: |
          echo "--- 임시 커밋 생성 중 (backend 빌드 전) ---"
          git config user.name "GitHub Actions Temp"
          git config user.email "actions-temp@github.com"
          git add -A
          if ! git diff --staged --quiet; then
            git commit -m "Temporary commit after applying package-json patch and install (before backend build)"
            echo "임시 커밋 (backend 빌드 전)이 생성되었습니다. HEAD는 이제 $(git rev-parse HEAD) 입니다."
          else
            echo "backend 빌드 전 임시로 커밋할 변경사항이 없습니다."
          fi
          echo "--- 임시 커밋 (backend 빌드 전) 완료 ---"

      - name: Run @library/backends build:external
        run: pnpm -w --filter @library/backends run build:external

      - name: 백엔드 구성 변경사항 확인 및 패치 생성
        id: check_backend_config_changes
        run: |
          echo "현재 상태:"
          git status --short
          echo "모든 변경사항 (untracked 포함) 스테이징 중..."
          git add -A
          echo "스테이징 후 상태:"
          git status --short

          if ! git diff --quiet --staged HEAD --exit-code; then
            echo "백엔드 구성 변경사항이 있습니다. 패치 생성 중..."
            git diff --staged HEAD > backend-config.patch
            echo "has_changes=true" >> $GITHUB_OUTPUT
            echo "backend-config.patch 내용:"
            cat backend-config.patch || true
          else
            echo "백엔드 구성 변경사항이 없습니다."
            echo "has_changes=false" >> $GITHUB_OUTPUT
          fi

      - name: 백엔드 구성 패치 아티팩트 업로드
        if: steps.check_backend_config_changes.outputs.has_changes == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: backend-config-patch
          path: backend-config.patch

  fix-markdown:
    runs-on: ubuntu-latest
    needs: [path-filter, fix-package-json, update-backend-config]
    if: |
      needs.path-filter.outputs.markdown == 'true' && !failure() && !cancelled()
    steps:
      - name: 저장소 체크아웃
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.pull_request.head.sha }}
          token: ${{ secrets.TOKEN1 }}
          fetch-depth: 0

      # package-json 패치 다운로드
      - name: package-json 패치 존재 여부 확인
        id: check_package-json_patch_fix_md
        uses: actions/github-script@v7
        with:
          script: |
            const artifacts = await github.rest.actions.listWorkflowRunArtifacts({
              owner: context.repo.owner,
              repo: context.repo.repo,
              run_id: context.runId
            });
            const matchArtifact = artifacts.data.artifacts.find(
              artifact => artifact.name === "package-json-patch"
            );
            return !!matchArtifact;

      - name: package-json 패치 아티팩트 다운로드
        if: steps.check_package-json_patch_fix_md.outputs.result == 'true'
        uses: actions/download-artifact@v4
        with:
          name: package-json-patch
          path: .

      # package-json 패치 적용
      - name: package-json 패치 적용
        if: steps.check_package-json_patch_fix_md.outputs.result == 'true'
        run: |
          if [ -f package-json.patch ]; then
            echo "package.json 포맷팅 변경사항 패치를 적용합니다..."
            if ! git apply --check package-json.patch; then
              echo "::error::package-json.patch 확인에 실패했습니다. 깔끔하게 적용할 수 없습니다."
              exit 1
            fi
            git apply package-json.patch
            echo "package.json 포맷팅 패치가 성공적으로 적용되었습니다."
            rm package-json.patch
          else
            echo "적용할 package.json 포맷팅 변경사항이 없습니다."
          fi

      # backend-config 패치 다운로드/적용
      - name: backend-config 패치 존재 여부 확인
        id: check_backend_patch_fix_md
        uses: actions/github-script@v7
        with:
          script: |
            const artifacts = await github.rest.actions.listWorkflowRunArtifacts({
              owner: context.repo.owner,
              repo: context.repo.repo,
              run_id: context.runId
            });
            const matchArtifact = artifacts.data.artifacts.find(
              artifact => artifact.name === "backend-config-patch"
            );
            return !!matchArtifact;

      - name: backend-config 패치 아티팩트 다운로드
        if: steps.check_backend_patch_fix_md.outputs.result == 'true'
        uses: actions/download-artifact@v4
        with:
          name: backend-config-patch
          path: .

      - name: backend-config 패치 적용
        if: steps.check_backend_patch_fix_md.outputs.result == 'true'
        run: |
          if [ -f backend-config.patch ]; then
            echo "backend-config 변경사항 패치를 적용합니다..."
            if ! git apply --check backend-config.patch; then
              echo "::error::backend-config.patch 확인에 실패했습니다. 깔끔하게 적용할 수 없습니다."
              exit 1
            fi
            git apply backend-config.patch
            echo "backend-config 패치가 성공적으로 적용되었습니다."
            rm backend-config.patch
          else
            echo "적용할 backend-config 변경사항이 없습니다."
          fi

      # pnpm 설치 및 의존성 설치 (패치 적용 후)
      - name: pnpm 설정
        uses: pnpm/action-setup@v4
        with:
          run_install: false
      - name: Node.js 설정
        uses: actions/setup-node@v4
        with:
          node-version-file: package.json
          cache: pnpm
      - name: 의존성 설치
        run: pnpm install --prefer-offline # 패치 적용된 package.json/lock 기준

      # 임시 커밋 생성 (패치 + 설치 후 상태 기준)
      - name: diff 비교를 위한 임시 커밋 생성
        run: |
          echo "--- 임시 커밋 생성 중 (마크다운 수정 전) ---"
          git config user.name "GitHub Actions Temp"
          git config user.email "actions-temp@github.com"
          git add . # 모든 변경사항 스테이징 (패치 적용 + install 결과 포함)
          if ! git diff --staged --quiet; then
            git commit -m "Temporary commit after applying package-json and backend patches and install"
            echo "임시 커밋 (마크다운 수정 전)이 생성되었습니다. HEAD는 이제 $(git rev-parse HEAD) 입니다."
          else
            echo "마크다운 수정 전 임시로 커밋할 변경사항이 없습니다."
          fi
          echo "--- 임시 커밋 (마크다운 수정 전) 완료 ---"

      # 마크다운 수정 도구 실행
      - name: 마크다운 수정 (markdownlint)
        uses: DavidAnson/markdownlint-cli2-action@v19
        with:
          globs: |
            **/*.md
            **/*.mdx
            **/*.mdc
            !**/node_modules/**
          config: .markdownlint.json
          fix: true
        continue-on-error: true

      - name: 변경된 마크다운 파일 가져오기
        id: changed-markdown-files
        uses: tj-actions/changed-files@v46
        with:
          json: true
          separator: "\n"
          files: |
            **/*.md
            **/*.mdx
            **/*.mdc

      - name: 마크다운 수정 (markdownlint)
        if: steps.changed-markdown-files.outputs.all_changed_files != ''
        uses: DavidAnson/markdownlint-cli2-action@v19
        with:
          globs: ${{ steps.changed-markdown-files.outputs.all_changed_files }}
          config: .markdownlint.json
          fix: true
        continue-on-error: true

      - name: 마크다운 파일 Lint 및 포맷 수정
        if: steps.changed-markdown-files.outputs.all_changed_files != ''
        run: |
          # PR 기준 변경된 마크다운 파일 목록 사용 (tj-actions/changed-files 출력값)
          # JSON 기반으로 안전하게 파싱 (jq 사용: 이중 인코딩/이스케이프까지 처리)
          mapfile -t MDFILES < <(printf '%s' '${{ steps.changed-markdown-files.outputs.all_changed_files }}' \
            | jq -r 'def parse(x): (try (x|fromjson) catch x) | (if type=="string" then (fromjson) else . end); parse(.) | .[]' 2>/dev/null)
          # jq 파싱 실패 시 정규식으로 "..." 토큰 추출 fallback
          if [ ${#MDFILES[@]} -eq 0 ]; then
            mapfile -t MDFILES < <(printf '%s' '${{ steps.changed-markdown-files.outputs.all_changed_files }}' \
              | sed -E 's/\\\"/\"/g' \
              | grep -oE '"([^"\\]|\\.)*"' \
              | sed -E 's/^"|"$//g')
          fi
          # 최후 수단: 공백 분리
          if [ ${#MDFILES[@]} -eq 0 ]; then
            read -r -a MDFILES <<< "${{ steps.changed-markdown-files.outputs.all_changed_files }}"
          fi

          # 존재하지 않는(삭제된) 파일 제외
          filtered_md=()
          for f in "${MDFILES[@]}"; do
            [ -e "$f" ] || continue
            filtered_md+=("$f")
          done

          # 파일별로 '가장 최신(HEAD 기준) 비-임시 커밋'의 subject만 확인해 필터링
          filtered=()
          for f in "${filtered_md[@]}"; do
            skip=0
            subj=""
            while true; do
              subj=$(git log -1 --pretty=%s --skip=$skip -- "$f" || true)
              # 더 이상 기록이 없으면 중단
              if [ -z "$subj" ]; then
                break
              fi
              case "$subj" in
                Temporary\ commit\ *) # 현재 런에서 만든 임시 커밋은 건너뜀
                  skip=$((skip+1))
                  continue
                  ;;
                *)
                  break
                  ;;
              esac
            done
            echo "파일: $f | 마지막 비임시 커밋 subject: ${subj}"
            if [ "${subj}" = "[automated-mutation]" ]; then
              echo "제외: 마지막 커밋이 [automated-mutation]"
              continue
            fi
            filtered+=("$f")
          done

          if [ ${#filtered[@]} -eq 0 ]; then
            echo "변경된 마크다운 파일 없음"
            exit 0
          fi

          echo "Stylelint"
          printf '%s\0' "${filtered[@]}" | xargs -0 -r pnpm exec stylelint --fix --allow-empty-input || true

          echo "ESLint"
          printf '%s\0' "${filtered[@]}" | xargs -0 -r pnpm exec eslint --fix --config eslint.fix.config.js || true

          echo "Prettier"
          printf '%s\0' "${filtered[@]}" | xargs -0 -r pnpm exec prettier --write --ignore-unknown --ignore-path .prettierignore || true
        continue-on-error: true

      # 마크다운 변경사항 패치 생성 (임시 커밋 기준)
      - name: 마크다운 변경사항 확인 및 패치 생성
        id: check_markdown_changes
        run: |
          echo "--- HEAD ($(git rev-parse HEAD)) 기준으로 마크다운 패치 생성 중 ---"
          echo "현재 상태 (마크다운 수정 후):"
          git status --short
          echo "스테이징 전, 모든 변경사항 (untracked 파일 포함) 추가 중..."
          git add -A # 마크다운 수정 도구가 새 파일을 만들 수도 있으므로 추가
          echo "'git add -A' 실행 후 상태:"
          git status --short

          if ! git diff --quiet --staged HEAD --exit-code; then # 임시 커밋과 비교
            echo "markdown 변경사항이 있습니다."
            echo "has_changes=true" >> $GITHUB_OUTPUT
            git diff --staged HEAD > markdown.patch # 임시 커밋과의 스테이징된 차이 저장
            echo "markdown.patch 내용:"
            cat markdown.patch
          else
            echo "markdown 변경사항이 없습니다."
            echo "has_changes=false" >> $GITHUB_OUTPUT
          fi
          echo "--- 마크다운 패치 생성 완료 ---"

      # 마크다운 패치 업로드
      - name: 마크다운 패치 아티팩트 업로드
        if: steps.check_markdown_changes.outputs.has_changes == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: markdown-patch
          path: markdown.patch

  update-translation:
    runs-on: ubuntu-latest
    needs: [path-filter, fix-package-json, fix-markdown, update-backend-config]
    if: |
      needs.path-filter.outputs.translation-targets == 'true' && !failure() && !cancelled()
    steps:
      - name: 저장소 체크아웃
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.pull_request.head.sha }}
          token: ${{ secrets.TOKEN1 }}
          fetch-depth: 0

      - name: Install dotenvx
        run: curl -sfS https://dotenvx.sh/install.sh | sh

      - name: Load and mask only .env keys into job env
        shell: bash
        run: |
          # .env 파일들에서 "키 이름"만 추출(주석/공백 라인 무시)
          awk -F= '!/^#/ && NF { gsub(/^[ \t]+|[ \t]+$/,"",$1); print $1 }' .env.public .env.private \
            | sort -u > .env.masklist

          # DOTENV_PRIVATE_KEY_PRIVATE 키도 목록에 포함(중복 방지)
          if [ -n "$DOTENV_PRIVATE_KEY_PRIVATE" ]; then
            grep -qxF DOTENV_PRIVATE_KEY_PRIVATE .env.masklist || echo DOTENV_PRIVATE_KEY_PRIVATE >> .env.masklist
          fi

          # dotenvx 컨텍스트에서 해당 키들만 값을 읽어 마스킹 + GITHUB_ENV 등록
          dotenvx run -f .env.private -f .env.public -- bash -lc '
            while IFS= read -r key; do
              v="${!key}"
              [ -z "$v" ] && continue
              echo "::add-mask::$v"
              if printf "%s" "$v" | grep -q $'\''\n'\''; then
                echo "$key<<EOF" >> "$GITHUB_ENV"
                printf "%s\n" "$v" >> "$GITHUB_ENV"
                echo "EOF" >> "$GITHUB_ENV"
              else
                printf "%s=%s\n" "$key" "$v" >> "$GITHUB_ENV"
              fi
            done < .env.masklist
          '
          rm -f .env.masklist || true
        env:
          DOTENV_PRIVATE_KEY_PRIVATE: ${{ secrets.DOTENV_PRIVATE_KEY_PRIVATE }}

      # package-json 패치 다운로드
      - name: package-json 패치 존재 여부 확인
        id: check_package-json_patch
        uses: actions/github-script@v7
        with:
          script: |
            const artifacts = await github.rest.actions.listWorkflowRunArtifacts({
              owner: context.repo.owner,
              repo: context.repo.repo,
              run_id: context.runId
            });
            const matchArtifact = artifacts.data.artifacts.find(
              artifact => artifact.name === "package-json-patch"
            );
            return !!matchArtifact;

      - name: package-json 패치 아티팩트 다운로드
        if: steps.check_package-json_patch.outputs.result == 'true'
        uses: actions/download-artifact@v4
        with:
          name: package-json-patch
          path: .

      # package-json 패치 적용
      - name: package-json 패치 적용
        if: steps.check_package-json_patch.outputs.result == 'true'
        run: |
          if [ -f package-json.patch ]; then
            echo "package.json 포맷팅 변경사항 패치를 적용합니다..."
            # --check 옵션으로 적용 가능 여부 확인
            if ! git apply --check package-json.patch; then
              echo "::error::package-json.patch 확인에 실패했습니다. 깔끔하게 적용할 수 없습니다."
              # 여기서 실패 처리 또는 경고 후 진행 결정 필요 (우선 실패 처리)
              exit 1
            fi
            # 실제 패치 적용
            git apply package-json.patch
            echo "package.json 포맷팅 패치가 성공적으로 적용되었습니다."
            rm package-json.patch
          else
            echo "적용할 package.json 포맷팅 변경사항이 없습니다."
          fi

      # backend-config 패치 다운로드
      - name: backend-config 패치 존재 여부 확인
        id: check_backend_patch_translate
        uses: actions/github-script@v7
        with:
          script: |
            const artifacts = await github.rest.actions.listWorkflowRunArtifacts({
              owner: context.repo.owner,
              repo: context.repo.repo,
              run_id: context.runId
            });
            const matchArtifact = artifacts.data.artifacts.find(
              artifact => artifact.name === "backend-config-patch"
            );
            return !!matchArtifact;

      - name: backend-config 패치 아티팩트 다운로드
        if: steps.check_backend_patch_translate.outputs.result == 'true'
        uses: actions/download-artifact@v4
        with:
          name: backend-config-patch
          path: .

      # backend-config 패치 적용
      - name: backend-config 패치 적용
        if: steps.check_backend_patch_translate.outputs.result == 'true'
        run: |
          if [ -f backend-config.patch ]; then
            echo "backend-config 변경사항 패치를 적용합니다..."
            if ! git apply --check backend-config.patch; then
              echo "::error::backend-config.patch 확인에 실패했습니다. 깔끔하게 적용할 수 없습니다."
              exit 1
            fi
            git apply backend-config.patch
            echo "backend-config 패치가 성공적으로 적용되었습니다."
            rm backend-config.patch
          else
            echo "적용할 backend-config 변경사항이 없습니다."
          fi

      # markdown patch 다운로드
      - name: 마크다운 패치 존재 여부 확인
        id: check_markdown_patch_lint-format
        uses: actions/github-script@v7
        with:
          script: |
            const artifacts = await github.rest.actions.listWorkflowRunArtifacts({
              owner: context.repo.owner,
              repo: context.repo.repo,
              run_id: context.runId
            });
            const matchArtifact = artifacts.data.artifacts.find(
              artifact => artifact.name === "markdown-patch"
            );
            return !!matchArtifact;

      - name: 마크다운 패치 아티팩트 다운로드
        if: steps.check_markdown_patch_lint-format.outputs.result == 'true'
        uses: actions/download-artifact@v4
        with:
          name: markdown-patch
          path: .

      # markdown patch 적용
      - name: 마크다운 패치 적용
        if: steps.check_markdown_patch_lint-format.outputs.result == 'true'
        run: |
          if [ -f markdown.patch ]; then
            echo "markdown 변경사항 패치를 적용합니다..."
            if ! git apply --check markdown.patch; then
              echo "::error::markdown.patch 확인에 실패했습니다. 깔끔하게 적용할 수 없습니다."
              exit 1
            fi
            git apply markdown.patch
            echo "markdown 패치가 성공적으로 적용되었습니다."
            rm markdown.patch
          else
            echo "적용할 markdown 변경사항이 없습니다."
          fi

      # pnpm 설치 및 의존성 설치 (패치 적용 후)
      - name: pnpm 설정
        uses: pnpm/action-setup@v4
        with:
          run_install: false
      - name: Node.js 설정
        uses: actions/setup-node@v4
        with:
          node-version-file: package.json
          cache: pnpm
      - name: 의존성 설치
        run: pnpm install --prefer-offline # 패치 적용된 package.json/lock 기준

      # 임시 커밋 생성 (패치 + 설치 후 상태 기준)
      - name: diff 비교를 위한 임시 커밋 생성
        run: |
          echo "--- 임시 커밋 생성 중 (번역 전) ---"
          git config user.name "GitHub Actions Temp"
          git config user.email "actions-temp@github.com"
          echo "임시 커밋 'git add .' 실행 전 상태:"
          git status --short
          git add . # 모든 변경사항 스테이징 (패치 적용 + install 결과 포함)
          echo "임시 커밋 'git add .' 실행 후, 'git commit' 실행 전 상태:"
          git status --short
          echo "임시 커밋을 위한 스테이징된 변경사항 diff 통계:"
          git diff --staged --stat # 스테이징된 내용 확인
          if ! git diff --staged --quiet; then
            git commit -m "Temporary commit after applying package-json and backend patches and install"
            echo "임시 커밋이 생성되었습니다. HEAD는 이제 $(git rev-parse HEAD) 입니다."
          else
            echo "번역 전 임시로 커밋할 변경사항이 없습니다."
          fi
          echo "--- 임시 커밋 완료 ---"

      # 번역 실행 및 새 파일 목록 생성
      - name: 번역 실행 및 새 파일 목록 생성
        id: run_translation
        run: |
          echo "--- 번역 실행 중 (pnpm run translate) ---"
          pnpm run translate
          echo "--- 번역 완료 ---"

          # git status --porcelain에서 변경된 파일 목록을 추출 (새 파일 + 수정된 파일)
          NEW_FILES_MULTILINE=$(git status --porcelain=v1 | grep -E "^(\?\?|M |A )" | cut -c 4-)

          if [ -n "$NEW_FILES_MULTILINE" ]; then
            # 전체 새 파일 목록 (공백 구분, 공백 이스케이프 처리)을 다음 스텝에 전달하기 위해 출력으로 설정
            ALL_NEW_FILES=$(echo "$NEW_FILES_MULTILINE" | sed 's/ /\\ /g' | tr '\n' ' ' | sed 's/ $//')
            echo "all_changed_files=$ALL_NEW_FILES" >> $GITHUB_OUTPUT

            # 새 마크다운 파일 목록 (공백 구분, 공백 이스케이프 처리)을 다음 스텝에 전달하기 위해 출력으로 설정
            NEW_MD_FILES=$(echo "$NEW_FILES_MULTILINE" | grep -E '\.(md|mdx|mdc)$' | sed 's/ /\\ /g' | tr '\n' ' ' | sed 's/ $//')
            echo "all_changed_markdown_files=$NEW_MD_FILES" >> $GITHUB_OUTPUT
          else
            echo "새로 생성된 파일이 없습니다."
            echo "all_changed_files=" >> $GITHUB_OUTPUT
            echo "all_changed_markdown_files=" >> $GITHUB_OUTPUT
          fi

      # 기본 린트 및 포맷팅 실행
      - name: 기본 린트 및 포맷팅 실행
        if: steps.run_translation.outputs.all_changed_files != ''
        run: |
          # 이전 스텝에서 생성된 전체 새 파일 목록을 가져옴
          MODIFIED_FILES="${{ steps.run_translation.outputs.all_changed_files }}"

          echo "Stylelint"
          STYLELINT_FILES=$(echo "$MODIFIED_FILES" | tr ' ' '\n' | grep -E '\.(css|svelte|md|mdx|mdc)$' | tr '\n' ' ' | sed 's/ $//')
          if [ -n "$STYLELINT_FILES" ]; then
            pnpm exec stylelint --fix --allow-empty-input $STYLELINT_FILES || true
          else
            echo "Stylelint를 적용할 파일이 없습니다."
          fi

          echo "ESLint"
          pnpm exec eslint --fix --config eslint.fix.config.js $MODIFIED_FILES || true


          echo "Prettier"
          pnpm exec prettier --write --ignore-unknown --ignore-path .prettierignore $MODIFIED_FILES || true

          echo "--- 기본 린트 및 포맷팅 완료 ---"
        continue-on-error: true

      # 번역 변경사항 패치 생성 (임시 커밋 기준)
      - name: 번역 변경사항 확인 및 패치 생성
        id: check_translation_changes
        run: |
          echo "--- HEAD ($(git rev-parse HEAD)) 기준으로 번역 패치 생성 중 ---"
          echo "현재 상태 (번역으로 인한 untracked 파일 포함):"
          git status --short

          # 새로 생성된 파일(untracked files)을 포함하여 모든 변경 사항을 스테이징합니다.
          # 이것이 핵심 변경 사항입니다.
          echo "모든 변경사항 (untracked 파일 포함) 스테이징 영역에 추가 중..."
          git add -A # 또는 git add . (모든 변경사항 및 새 파일 추가)

          echo "'git add -A' 실행 후 상태:"
          git status --short # 스테이징 후 상태 확인

          # 이제 스테이징된 변경사항을 기준으로 diff를 생성합니다.
          # HEAD는 "Temporary commit after applying package-json and backend patches and install" 커밋을 가리킵니다.
          # 따라서 이 diff는 번역 작업으로 인해 발생한 변경사항(새 파일 추가 포함)만을 포함하게 됩니다.
          echo "임시 커밋(HEAD) 대비 스테이징된 변경사항 diff 통계 실행 중:"
          git diff --stat --staged HEAD # 스테이징된 변경사항과 임시 커밋(HEAD) 비교

          if ! git diff --quiet --staged HEAD --exit-code; then # 스테이징된 변경사항과 임시 커밋(HEAD) 비교
            echo "번역 변경사항이 있습니다 (새 파일 포함)."
            echo "has_changes=true" >> $GITHUB_OUTPUT
            git diff --staged HEAD > translation.patch # 스테이징된 변경사항을 패치로 저장
            echo "translation.patch 내용:"
            cat translation.patch # 생성된 패치 내용 출력
          else
            echo "번역 변경사항이 없습니다."
            echo "has_changes=false" >> $GITHUB_OUTPUT
          fi
          echo "--- 번역 패치 생성 완료 ---"

      # 번역 패치 업로드
      - name: 번역 패치 아티팩트 업로드
        if: steps.check_translation_changes.outputs.has_changes == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: translation-patch
          path: translation.patch

  lint-format:
    runs-on: ubuntu-latest
    needs: [path-filter, fix-package-json, update-translation, fix-markdown, update-backend-config]
    if: |
      needs.path-filter.result == 'success' && !failure() && !cancelled()
    env:
      HUSKY: 0
    steps:
      - name: 저장소 체크아웃
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.pull_request.head.sha }}
          token: ${{ secrets.TOKEN1 }} # 필요시 토큰 사용
          fetch-depth: 0 # diff를 위해

      - name: Install dotenvx
        run: curl -sfS https://dotenvx.sh/install.sh | sh

      - name: Load and mask only .env keys into job env
        shell: bash
        run: |
          # .env 파일들에서 "키 이름"만 추출(주석/공백 라인 무시)
          awk -F= '!/^#/ && NF { gsub(/^[ \t]+|[ \t]+$/,"",$1); print $1 }' .env.public .env.private \
            | sort -u > .env.masklist

          # DOTENV_PRIVATE_KEY_PRIVATE 키도 목록에 포함(중복 방지)
          if [ -n "$DOTENV_PRIVATE_KEY_PRIVATE" ]; then
            grep -qxF DOTENV_PRIVATE_KEY_PRIVATE .env.masklist || echo DOTENV_PRIVATE_KEY_PRIVATE >> .env.masklist
          fi

          # dotenvx 컨텍스트에서 해당 키들만 값을 읽어 마스킹 + GITHUB_ENV 등록
          dotenvx run -f .env.private -f .env.public -- bash -lc '
            while IFS= read -r key; do
              v="${!key}"
              [ -z "$v" ] && continue
              echo "::add-mask::$v"
              if printf "%s" "$v" | grep -q $'\''\n'\''; then
                echo "$key<<EOF" >> "$GITHUB_ENV"
                printf "%s\n" "$v" >> "$GITHUB_ENV"
                echo "EOF" >> "$GITHUB_ENV"
              else
                printf "%s=%s\n" "$key" "$v" >> "$GITHUB_ENV"
              fi
            done < .env.masklist
          '
          rm -f .env.masklist || true
        env:
          DOTENV_PRIVATE_KEY_PRIVATE: ${{ secrets.DOTENV_PRIVATE_KEY_PRIVATE }}

      # package-json 패치 다운로드
      - name: package-json 패치 존재 여부 확인
        id: check_package-json_patch_lint-format
        uses: actions/github-script@v7
        with:
          script: |
            const artifacts = await github.rest.actions.listWorkflowRunArtifacts({
              owner: context.repo.owner,
              repo: context.repo.repo,
              run_id: context.runId
            });
            const matchArtifact = artifacts.data.artifacts.find(
              artifact => artifact.name === "package-json-patch"
            );
            return !!matchArtifact;

      - name: package-json 패치 아티팩트 다운로드
        if: steps.check_package-json_patch_lint-format.outputs.result == 'true'
        uses: actions/download-artifact@v4
        with:
          name: package-json-patch
          path: .

      # package-json 패치 적용
      - name: package-json 패치 적용
        if: steps.check_package-json_patch_lint-format.outputs.result == 'true'
        run: |
          if [ -f package-json.patch ]; then
            echo "package.json 포맷팅 변경사항 패치를 적용합니다..."
            if ! git apply --check package-json.patch; then
              echo "::error::package-json.patch 확인에 실패했습니다. 깔끔하게 적용할 수 없습니다."
              exit 1
            fi
            git apply package-json.patch
            echo "package.json 포맷팅 패치가 성공적으로 적용되었습니다."
            rm package-json.patch
          else
            echo "적용할 package.json 포맷팅 변경사항이 없습니다."
          fi

      # backend-config 패치 다운로드 (lint-format)
      - name: 백엔드 패치 존재 여부 확인
        id: check_backend_patch_lint-format
        uses: actions/github-script@v7
        with:
          script: |
            const artifacts = await github.rest.actions.listWorkflowRunArtifacts({
              owner: context.repo.owner,
              repo: context.repo.repo,
              run_id: context.runId
            });
            const matchArtifact = artifacts.data.artifacts.find(
              artifact => artifact.name === "backend-config-patch"
            );
            return !!matchArtifact;

      - name: 백엔드 패치 아티팩트 다운로드
        if: steps.check_backend_patch_lint-format.outputs.result == 'true'
        uses: actions/download-artifact@v4
        with:
          name: backend-config-patch
          path: .

      # backend-config 패치 적용 (lint-format)
      - name: 백엔드 패치 적용
        if: steps.check_backend_patch_lint-format.outputs.result == 'true'
        run: |
          if [ -f backend-config.patch ]; then
            echo "백엔드 변경사항 패치를 적용합니다..."
            if ! git apply --check backend-config.patch; then
              echo "::error::backend-config.patch 확인에 실패했습니다. 깔끔하게 적용할 수 없습니다."
              exit 1
            fi
            git apply backend-config.patch
            echo "백엔드 패치가 성공적으로 적용되었습니다."
            rm backend-config.patch
          else
            echo "적용할 백엔드 변경사항이 없습니다."
          fi

      # markdown patch 다운로드
      - name: 마크다운 패치 존재 여부 확인
        id: check_markdown_patch_lint-format
        uses: actions/github-script@v7
        with:
          script: |
            const artifacts = await github.rest.actions.listWorkflowRunArtifacts({
              owner: context.repo.owner,
              repo: context.repo.repo,
              run_id: context.runId
            });
            const matchArtifact = artifacts.data.artifacts.find(
              artifact => artifact.name === "markdown-patch"
            );
            return !!matchArtifact;

      - name: 마크다운 패치 아티팩트 다운로드
        if: steps.check_markdown_patch_lint-format.outputs.result == 'true'
        uses: actions/download-artifact@v4
        with:
          name: markdown-patch
          path: .

      # markdown patch 적용
      - name: 마크다운 패치 적용
        if: steps.check_markdown_patch_lint-format.outputs.result == 'true'
        run: |
          if [ -f markdown.patch ]; then
            echo "markdown 변경사항 패치를 적용합니다..."
            if ! git apply --check markdown.patch; then
              echo "::error::markdown.patch 확인에 실패했습니다. 깔끔하게 적용할 수 없습니다."
              exit 1
            fi
            git apply markdown.patch
            echo "markdown 패치가 성공적으로 적용되었습니다."
            rm markdown.patch
          else
            echo "적용할 markdown 변경사항이 없습니다."
          fi

      # translation patch 다운로드
      - name: 번역 패치 존재 여부 확인
        id: check_translation_patch_lint-format
        uses: actions/github-script@v7
        with:
          script: |
            const artifacts = await github.rest.actions.listWorkflowRunArtifacts({
              owner: context.repo.owner,
              repo: context.repo.repo,
              run_id: context.runId
            });
            const matchArtifact = artifacts.data.artifacts.find(
              artifact => artifact.name === "translation-patch"
            );
            return !!matchArtifact;

      - name: 번역 패치 아티팩트 다운로드
        if: steps.check_translation_patch_lint-format.outputs.result == 'true'
        uses: actions/download-artifact@v4
        with:
          name: translation-patch
          path: .

      # translation patch 적용
      - name: 번역 패치 적용
        if: steps.check_translation_patch_lint-format.outputs.result == 'true'
        run: |
          if [ -f translation.patch ]; then
            echo "번역 변경사항 패치를 적용합니다..."
            if ! git apply --check translation.patch; then
              echo "::error::translation.patch 확인에 실패했습니다. 깔끔하게 적용할 수 없습니다."
              exit 1
            fi
            git apply translation.patch
            echo "번역 패치가 성공적으로 적용되었습니다."
            rm translation.patch
          else
            echo "적용할 번역 변경사항이 없습니다."
          fi

      # backend-config patch 다운로드

      # Node.js 및 pnpm 설정
      - name: pnpm 설정
        uses: pnpm/action-setup@v4
        with:
          run_install: false
      - name: Node.js 설정
        uses: actions/setup-node@v4
        with:
          node-version-file: package.json
          cache: pnpm

      # 패치 적용 후 의존성 설치 (lint-fix 실행 위해)
      - name: 패치 적용 후 의존성 설치
        run: pnpm install --prefer-offline

      # 임시 커밋 생성 (git diff 기준점 마련)
      - name: diff 비교를 위한 임시 커밋 생성
        run: |
          echo "--- 임시 커밋 생성 중 (린트/포맷 실행 전) ---"
          git config user.name "GitHub Actions Temp"
          git config user.email "actions-temp@github.com"
          git add . # 모든 변경사항 스테이징
          # 변경사항이 있을 때만 커밋 시도
          if ! git diff --staged --quiet; then
            git commit -m "Temporary commit after applying all patches and install (before lint-fix)"
            echo "임시 커밋 (린트/포맷 실행 전)이 생성되었습니다. HEAD는 이제 $(git rev-parse HEAD) 입니다."
          else
            echo "임시로 커밋할 변경사항이 없습니다 (린트/포맷 실행 전)."
          fi
          echo "--- 임시 커밋 (린트/포맷 실행 전) 완료 ---"

      - name: 변경된 파일 목록 가져오기 (마크다운 제외)
        id: changed-files
        uses: tj-actions/changed-files@v46
        with:
          json: true
          separator: "\n"
          files_ignore: |
            **/*.md
            **/*.mdx
            **/*.mdc

      # 린트 실행
      - name: 린트 및 포맷 실행
        if: steps.changed-files.outputs.all_changed_files != ''
        run: |
          # PR 기준 변경 파일 목록 사용 (tj-actions/changed-files 출력값)
          # JSON 기반으로 안전하게 파싱 (jq 사용: 이중 인코딩/이스케이프까지 처리)
          mapfile -t FILES < <(printf '%s' '${{ steps.changed-files.outputs.all_changed_files }}' \
            | jq -r 'def parse(x): (try (x|fromjson) catch x) | (if type=="string" then (fromjson) else . end); parse(.) | .[]' 2>/dev/null)
          # jq 파싱 실패 시 정규식으로 "..." 토큰 추출 fallback
          if [ ${#FILES[@]} -eq 0 ]; then
            mapfile -t FILES < <(printf '%s' '${{ steps.changed-files.outputs.all_changed_files }}' \
              | sed -E 's/\\\"/\"/g' \
              | grep -oE '"([^"\\]|\\.)*"' \
              | sed -E 's/^"|"$//g')
          fi
          # 최후 수단: 공백 분리
          if [ ${#FILES[@]} -eq 0 ]; then
            read -r -a FILES <<< "${{ steps.changed-files.outputs.all_changed_files }}"
          fi

          # 마크다운 제외 및 존재하지 않는 파일 제외
          files_no_md=()
          for f in "${FILES[@]}"; do
            case "$f" in
              *.md|*.mdx|*.mdc) continue;;
              *)
                [ -e "$f" ] || continue
                files_no_md+=("$f")
                ;;
            esac
          done
          echo "files_no_md count: ${#files_no_md[@]}"
          # for f in "${files_no_md[@]}"; do echo "files_no_md item: $f"; done

          echo "HEAD: $(git rev-parse --short HEAD)"
          echo "HEAD subject: $(git log -1 --pretty=%s || true)"

          # 파일별로 '가장 최신(HEAD 기준) 비-임시 커밋'의 subject만 확인해 필터링
          filtered=()
          for f in "${files_no_md[@]}"; do
            # echo "검사 시작: $f"
            skip=0
            subj=""
            while true; do
              subj=$(git log -1 --pretty=%s --skip=$skip -- "$f" || true)
              # 더 이상 기록이 없으면 중단
              if [ -z "$subj" ]; then
                break
              fi
              # echo "  cand[$skip]: $subj"
              case "$subj" in
                Temporary\ commit\ *) # 현재 런에서 만든 임시 커밋은 건너뜀
                  skip=$((skip+1))
                  continue
                  ;;
                *)
                  break
                  ;;
              esac
            done
            echo "파일: $f | 마지막 비임시 커밋 subject: ${subj}"
            if [ "${subj}" = "[automated-mutation]" ]; then
              echo "제외: 마지막 커밋이 [automated-mutation]"
              continue
            fi
            filtered+=("$f")
          done

          echo "filtered count: ${#filtered[@]}"
          # for f in "${filtered[@]}"; do echo "filtered item: $f"; done

          if [ ${#filtered[@]} -eq 0 ]; then
            echo "대상 파일 없음(자동수정만 있었거나 마크다운만 변경). 린트/포맷 생략."
            echo "최근 파일별 커밋 로그(최대 3개)로 진단:"
            for f in "${files_no_md[@]}"; do
              echo "---- $f"
              git log -3 --pretty='format:%h %s' -- "$f" || true
            done
            exit 0
          fi

          echo "Stylelint"
          printf '%s\0' "${filtered[@]}" | grep -z -E '\.(css|svelte|md|mdx|mdc)$' | xargs -0 -r pnpm exec stylelint --fix --allow-empty-input || true

          echo "ESLint"
          printf '%s\0' "${filtered[@]}" | xargs -0 -r pnpm exec eslint --fix --config eslint.fix.config.js || true

          echo "Prettier"
          printf '%s\0' "${filtered[@]}" | xargs -0 -r pnpm exec prettier --write --ignore-unknown --ignore-path .prettierignore || true
        continue-on-error: true

      # lint-format.patch 생성 (임시 커밋 기준) 및 변경 유무 출력
      - name: 린트/포맷 변경사항 확인 및 lint-format.patch 생성
        id: create_lint-format_patch
        run: |
          echo "--- HEAD ($(git rev-parse HEAD)) 기준으로 린트/포맷 변경사항 패치 생성 중 ---"
          echo "현재 상태 (린트/포맷 실행 후):"
          git status --short
          echo "스테이징 전, 모든 변경사항 (untracked 파일 포함) 추가 중..."
          git add -A # 린트/포맷 도구가 새 파일을 만들 수도 있으므로 추가
          echo "'git add -A' 실행 후 상태:"
          git status --short

          if ! git diff --quiet --staged HEAD --exit-code; then # 임시 커밋과 비교
            echo "린트 및 포맷팅 후 변경사항 감지됨. lint-format.patch 생성 중..."
            git diff --staged HEAD > lint-format.patch
            echo "has_changes=true" >> $GITHUB_OUTPUT
            echo "lint-format.patch 내용:"
            cat lint-format.patch
          else
            echo "린트 및 포맷팅 후 추가 변경사항 없음."
            echo "has_changes=false" >> $GITHUB_OUTPUT
          fi
          echo "--- 린트/포맷 변경사항 패치 생성 완료 ---"

      # patch 파일을 artifact로 업로드 (변경사항 있을 때만)
      - name: lint-format.patch 아티팩트 업로드
        uses: actions/upload-artifact@v4
        if: steps.create_lint-format_patch.outputs.has_changes == 'true'
        with:
          name: lint-format-patch
          path: lint-format.patch

  compress-images:
    runs-on: ubuntu-latest
    needs: path-filter
    if: needs.path-filter.outputs.images == 'true'
    steps:
      - name: 저장소 체크아웃
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.pull_request.head.sha }}
          token: ${{ secrets.TOKEN1 }}
          fetch-depth: 0

      - name: 이미지 압축
        uses: calibreapp/image-actions@main
        with:
          githubToken: ${{ secrets.GITHUB_TOKEN }}
          compressOnly: true

      # 추가: 이미지 압축 후 수정사항을 patch 파일로 생성
      - name: 이미지 변경사항 확인
        id: check_image_changes
        run: |
          if git diff --quiet; then
            echo "이미지 압축 후 변경사항이 없습니다."
            echo "has_changes=false" >> $GITHUB_OUTPUT
          else
            echo "이미지 압축 후 변경사항이 감지되었습니다."
            echo "has_changes=true" >> $GITHUB_OUTPUT
            git diff > images.patch
          fi

      # 추가: patch 파일을 artifact로 업로드
      - name: 이미지 패치 아티팩트 업로드
        if: steps.check_image_changes.outputs.has_changes == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: images-lint-format-patch
          path: images.patch

  push-and-labeled:
    needs:
      - path-filter
      - compress-images
      - lint-format
      - fix-package-json
      - fix-markdown
      - update-translation
      - update-backend-config

    if: needs.path-filter.result == 'success' && !failure() && !cancelled()
    runs-on: ubuntu-latest

    steps:
      # 저장소 체크아웃 단계
      - name: 저장소 체크아웃
        uses: actions/checkout@v4
        with:
          ref: ${{ github.head_ref }}
          token: ${{ secrets.TOKEN1 }}
          fetch-depth: 0 # diff를 위해 전체 히스토리 가져오기

      # images → 2) package-json → 3) backend → 4) markdown → 5) translation → 6) changes

      - name: 이미지 패치 존재 여부 확인
        id: check_images_patch_push
        uses: actions/github-script@v7
        with:
          script: |
            const artifacts = await github.rest.actions.listWorkflowRunArtifacts({
              owner: context.repo.owner,
              repo: context.repo.repo,
              run_id: context.runId
            });
            const matchArtifact = artifacts.data.artifacts.find(
              artifact => artifact.name === "images-lint-format-patch"
            );
            return !!matchArtifact;

      - name: 이미지 패치 아티팩트 다운로드
        if: steps.check_images_patch_push.outputs.result == 'true'
        uses: actions/download-artifact@v4
        with:
          name: images-lint-format-patch
          path: .

      - name: package-json 패치 존재 여부 확인
        id: check_package-json_patch_push
        uses: actions/github-script@v7
        with:
          script: |
            const artifacts = await github.rest.actions.listWorkflowRunArtifacts({
              owner: context.repo.owner,
              repo: context.repo.repo,
              run_id: context.runId
            });
            return !!artifacts.data.artifacts.find(artifact => artifact.name === "package-json-patch");

      - name: package-json 패치 아티팩트 다운로드
        if: steps.check_package-json_patch_push.outputs.result == 'true'
        uses: actions/download-artifact@v4
        with:
          name: package-json-patch
          path: .

      - name: 백엔드 패치 존재 여부 확인
        id: check_backend_patch_push
        uses: actions/github-script@v7
        with:
          script: |
            const artifacts = await github.rest.actions.listWorkflowRunArtifacts({
              owner: context.repo.owner,
              repo: context.repo.repo,
              run_id: context.runId
            });
            const matchArtifact = artifacts.data.artifacts.find(
              artifact => artifact.name === "backend-config-patch"
            );
            return !!matchArtifact;

      - name: 백엔드 패치 아티팩트 다운로드
        if: steps.check_backend_patch_push.outputs.result == 'true'
        uses: actions/download-artifact@v4
        with:
          name: backend-config-patch
          path: .

      - name: 마크다운 패치 존재 여부 확인
        id: check_markdown_patch_push
        uses: actions/github-script@v7
        with:
          script: |
            const artifacts = await github.rest.actions.listWorkflowRunArtifacts({
              owner: context.repo.owner,
              repo: context.repo.repo,
              run_id: context.runId
            });
            const matchArtifact = artifacts.data.artifacts.find(
              artifact => artifact.name === "markdown-patch"
            );
            return !!matchArtifact;

      - name: 마크다운 패치 아티팩트 다운로드
        if: steps.check_markdown_patch_push.outputs.result == 'true'
        uses: actions/download-artifact@v4
        with:
          name: markdown-patch
          path: .

      - name: 번역 패치 존재 여부 확인
        id: check_translation_patch_push
        uses: actions/github-script@v7
        with:
          script: |
            const artifacts = await github.rest.actions.listWorkflowRunArtifacts({
              owner: context.repo.owner,
              repo: context.repo.repo,
              run_id: context.runId
            });
            const matchArtifact = artifacts.data.artifacts.find(
              artifact => artifact.name === "translation-patch"
            );
            return !!matchArtifact;

      - name: 번역 패치 아티팩트 다운로드
        if: steps.check_translation_patch_push.outputs.result == 'true'
        uses: actions/download-artifact@v4
        with:
          name: translation-patch
          path: .

      - name: lint-format.patch (린트/포맷) 존재 여부 확인
        id: check_lint-format_patch_push
        uses: actions/github-script@v7
        with:
          script: |
            const artifacts = await github.rest.actions.listWorkflowRunArtifacts({
              owner: context.repo.owner,
              repo: context.repo.repo,
              run_id: context.runId
            });
            const matchArtifact = artifacts.data.artifacts.find(
              artifact => artifact.name === "lint-format-patch"
            );
            return !!matchArtifact;

      - name: lint-format.patch (린트/포맷) 아티팩트 다운로드
        if: steps.check_lint-format_patch_push.outputs.result == 'true'
        uses: actions/download-artifact@v4
        with:
          name: lint-format-patch
          path: .

      # 추가: 다운로드한 patch 적용
      - name: 패치 적용
        run: |
          echo "--- 패치 적용 시작 ---"
          apply_patch() {
            local patch_file="$1"
            local patch_name="$2"
            if [ -f "$patch_file" ]; then
              echo "$patch_name 패치 ($patch_file) 적용 중..."
              if git apply --3way "$patch_file"; then
                 echo "$patch_name 패치가 3-way 병합으로 성공적으로 적용되었습니다."
              elif git apply --check "$patch_file"; then
                git apply "$patch_file"
                if [ $? -eq 0 ]; then
                  echo "$patch_name 패치가 성공적으로 적용되었습니다."
                else
                  echo "::error::$patch_name 패치 ($patch_file) 적용 실패 (확인 후에도). 수동 충돌 해결이 필요할 수 있습니다."
                fi
              else
                echo "::warning::$patch_name 패치 ($patch_file) 확인 실패. 충돌이 있을 수 있습니다."
              fi
              rm "$patch_file" || echo "$patch_file 삭제 불가"
              echo "$patch_name 패치 적용 후 현재 상태:"
              git status --short
            else
              echo "적용할 $patch_name 패치 ($patch_file) 없음."
            fi
            echo "------------------------"
          }

          apply_patch "images.patch" "이미지 압축"
          apply_patch "package-json.patch" "Package.json 포맷팅"
          apply_patch "backend-config.patch" "백엔드 구성"
          apply_patch "markdown.patch" "마크다운 포맷팅"
          apply_patch "translation.patch" "번역"
          apply_patch "lint-format.patch" "코드 포맷팅 (린트/스타일)"

          echo "--- 모든 패치 적용 완료 ---"
          echo "모든 패치 적용 후 최종 상태 (스테이징 전):"
          git status --short
          echo "모든 패치 적용 후 상세 diff 통계 (스테이징 전):"
          git diff --stat

      - name: 모든 패치 적용 후 변경사항 스테이징
        run: |
          echo "--- 모든 변경사항 스테이징 중 ---"
          echo "'git add -A' 실행 전 상태:"
          git status --short

          git add -A
          echo "'git add -A' 실행 후 상태:"
          git status --short

          echo "스테이징된 변경사항 diff 통계:"
          git diff --staged --stat
          echo "--- 스테이징 완료 ---"

      # 커밋 시도
      - name: 변경사항 커밋
        id: auto-commit
        uses: stefanzweifel/git-auto-commit-action@v5
        with:
          commit_message: '[automated-mutation]'
          # 디버깅을 위해 커밋 액션의 로그를 더 자세히 보려면:
          # skip_dirty_check: true
          # skip_fetch: true
          # dry_run: true # 실제 커밋은 안하고 결과만 볼 때 (테스트용)
          # file_pattern: . # 명시적으로 모든 파일을 대상으로 지정

      # 커밋 결과 출력
      - name: 커밋 결과 출력
        run: |
          if [ "${{ steps.auto-commit.outputs.changes_detected }}" == "true" ]; then
            echo "변경사항이 감지되어 자동으로 커밋되었습니다."
            echo "커밋 ID: ${{ steps.auto-commit.outputs.commit_hash }}"
          else
            echo "커밋할 변경사항이 없습니다. 모든 코드가 이미 정상적으로 포맷팅되어 있거나 이미지가 이미 최적화되어 있습니다."
          fi

      # Add a Label to PR 1
      - name: PR에 라벨 추가 1 (mutated)
        if: steps.auto-commit.outputs.changes_detected == 'true'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.TOKEN1 }}
          script: |
            github.rest.issues.addLabels({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              labels: ['mutated']
            })

      # 라벨 추가
      - name: PR에 라벨 추가 2 (mutation-finished)
        env:
          GH_TOKEN: ${{ secrets.TOKEN1 }}
          PR_NUMBER: ${{ github.event.pull_request.number }}
          REPO: ${{ github.repository }}
        run: |
          echo "Adding label mutation-finished to PR #$PR_NUMBER in repo $REPO"
          gh issue edit $PR_NUMBER --add-label "mutation-finished" --repo $REPO
          echo "Label addition command executed."
