---
description:
globs: *.stories.svelte,*storybook*
alwaysApply: false
---

# Defining the meta

All stories files must have a "meta" (aka. "default export") defined, and its structure follows what's described in [the official docs on the subject](https://storybook.js.org/docs/api/csf#default-export). To define the meta in Svelte CSF, call the `defineMeta` function **within the module context**, with the meta properties you want:

```svelte
<script module>
  //    👆 notice the module context, defineMeta does not work in a regular <script> tag - instance
  import { defineMeta } from '@storybook/addon-svelte-csf';
  import MyComponent from './MyComponent.svelte';
  //      👇 Get the Story component from the return value
  const { Story } = defineMeta({
    title: 'Path/To/MyComponent',
    component: MyComponent,
    decorators: [
      /* ... */
    ],
    parameters: {
      /* ... */
    },
  });
</script>
```

`defineMeta` returns an object with a `Story` component (see [Defining stories](https://github.com/storybookjs/addon-svelte-csf#defining-stories) below) that you must destructure out to use.

# Defining stories

To define stories, you use the `Story` component returned from the `defineMeta` function. Depending on what you want the story to contain, [there are multiple ways to use the `Story` component](https://github.com/storybookjs/addon-svelte-csf/blob/main/examples/Templating.stories.svelte). Common for all the use case is that all properties of [a regular CSF story](https://storybook.js.org/docs/api/csf#named-story-exports) are passed as props to the `Story` component, with the exception of the `render` function, which does not have any effect in Svelte CSF.

All story requires either the `name` prop or [`exportName` prop](https://github.com/storybookjs/addon-svelte-csf#custom-export-name).

Tip:
In versions prior to v5 of this addon, it was always required to define a template story with the `<Template>` component. This is no longer required and stories will default to render the component from `meta` if no template is set.

## Plain Story

If your component only accepts props and doesn't require snippets or slots, you can use the simple form of defining stories, only using args:

```svelte
<Story name="Primary" args={{ primary: true }} />
```

This will render the component defined in the meta, with the args passed as props.

## With children

If your component needs children, you can pass them in directly to the story, and they will be forwarded to your component:

```svelte
<Story name="With Children">I will be the child of the component from defineMeta</Story>
```

## Static template

If you need more customization of the story, like composing components or defining snippets, you can set the `asChild` prop on the Story. Instead of forwarding the children to your component, it will instead use the children directly as the story output. This allows you to write whatever component structure you desire:

```svelte
<Story name="Composed" asChild>
  <MyComponent>
    <AChild label="Hello world!" />
  </MyComponent>
</Story>
```

Important:
This format completely ignores args, as they are not passed down to any of the child components defined. Even if your story has args and Controls, they won't have an effect. See the snippet-based formats below.

## Inline snippet

If you need composition/snippets but also want a dynamic story that reacts to args or the story context, you can define a `template` snippet in the `Story` component:

```svelte
<Story name="Simple Template" args={{ simpleChild: true }}>
  {#snippet template(args)}
    <MyComponent {...args}>Component with args</MyComponent>
  {/snippet}
</Story>
```

## Shared snippet

Often your stories are very similar and their only differences are args or play-functions. In this case it can be cumbersome to define the same `template` snippet over and over again. You can share snippets by defining them at the top-level and passing them as props to `Story`:

```svelte
{#snippet template(args)}
  <MyComponent {...args}>
    {#if args.simpleChild}
      <AChild data={args.childProps} />
    {:else}
      <ComplexChildA data={args.childProps} />
      <ComplexChildB data={args.childProps} />
    {/if}
  </MyComponent>
{/snippet}

<Story name="Simple Template" args={{ simpleChild: true }} {template} />

<Story name="Complex Template" args={{ simpleChild: false }} {template} />
```

You can also use this pattern to define multiple templates and share the different templates among different stories.

## Default snippet

If you only need a single template that you want to share, it can be tedious to include `{template}` in each `Story` component. Like in th example below:

```svelte
<Story name="Primary" args={{ variant: 'primary' }} {template} />
<Story name="Secondary" args={{ variant: 'secondary' }} {template} />
<Story name="Tertiary" args={{ variant: 'tertiary' }} {template} />

<Story name="Denary" args={{ variant: 'denary' }} {template} />
```

Similar to regular CSF, you can define a meta-level `render`-function, by referencing your default snippet in the `render` property of your `defineMeta` call:

```svelte
<script module>
  import { defineMeta } from '@storybook/addon-svelte-csf';
  import MyComponent from './MyComponent.svelte';
  const { Story } = defineMeta({
    render: template,
    //      👆 the name of the snippet as defined below (can be any name)
  });
</script>

{#snippet template(args)}
  <MyComponent {...args}>
    {#if args.simpleChild}
      <AChild data={args.childProps} />
    {:else}
      <ComplexChildA data={args.childProps} />
      <ComplexChildB data={args.childProps} />
    {/if}
  </MyComponent>
{/snippet}

<Story name="Simple Children" args={{ simpleChild: true }} />

<Story name="Complex Children" args={{ simpleChild: false }} />
```

Stories can still override this default snippet using any of the methods for defining story-level content.

Note:
Svelte has the limitation, that you can't reference a snippet from a `<script module>` if it reference any declarations in a non-module `<script>` (whether directly or indirectly, via other snippets). See [svelte.dev/docs/svelte/snippet#Exporting-snippets](https://svelte.dev/docs/svelte/snippet#Exporting-snippets)

## Custom export name

Behind-the-scenes, each `<Story />` definition is compiled to a variable export like `export const MyStory = ...;`. In most cases you don't have to care about this detail, however sometimes naming conflicts can arise from this. The variable names are simplifications of the story names - to make them valid JavaScript variables.

This can cause conflicts, eg. two stories with the names _"my story!"_ and _"My Story"_ will both be simplified to `MyStory`.

You can explicitly define the variable name of any story by passing the `exportName` prop:

```svelte
<Story exportName="MyStory1" name="my story!" />
<Story exportName="MyStory2" name="My Story" />
```

At least one of the `name` or `exportName` props must be passed to the `Story` component - passing both is also valid.

## Accessing Story context

If for some reason you need to access the [Story context](https://storybook.js.org/docs/writing-stories/decorators#context-for-mocking) _(e.g. for mocking)_ while rendering the story, then `<Story />`'s attribute `template` snippet provides an optional second argument.

```svelte
<Story name="Default">
  {#snippet template(args, context)}

     <MyComponent {...args}>
  {/snippet}
</Story>
```

# TypeScript

Story template snippets can be type-safe when necessary. The type of the args are inferred from the `component` or `render` property passed to `defineMeta`.

If you're just rendering the component directly without a custom template, you can use Svelte's `ComponentProps` type and `StoryContext` from the addon to make your template snippet type-safe:

```svelte
<script module lang="ts">
  import { defineMeta, type StoryContext } from '@storybook/addon-svelte-csf';
  import { type ComponentProps } from 'svelte';
  import MyComponent from './MyComponent.svelte';
  const { Story } = defineMeta({
    component: MyComponent,
  });
  type Args = ComponentProps<MyComponent>;
</script>

{#snippet template(args: Args, context: StoryContext<typeof Layout>)}
  <MyComponent {...args} />
{/snippet}
```

If you use the `render`-property to define a custom template that might use custom args, the args will be inferred from the types of the snippet passed to `render`. This is especially useful when you're converting primitive args to snippets:

```svelte
<script module lang="ts">
  import { defineMeta, type StoryContext } from '@storybook/addon-svelte-csf';
  import { type ComponentProps } from 'svelte';
  import MyComponent from './MyComponent.svelte';
  const { Story } = defineMeta({
    component: MyComponent,
    render: template, // 👈 args will be inferred from this, which is the Args type below
    argTypes: {
      children: {
        control: 'text',
      },
      footer: {
        control: 'text',
      },
    },
  });
  type Args = Omit<ComponentProps<MyComponent>, 'children' | 'footer'> & {
    children: string;
    footer?: string;
  };
  // OR use the Merge helper from the 'type-fest' package:
  type Args = Merge<
    ComponentProps<MyComponent>,
    {
      children: string;
      footer?: string;
    }
  >;
</script>


{#snippet template({ children, ...args }: Args, context: StoryContext<typeof MyComponent>)}
  <MyComponent {...args}>
    {children}
    {#snippet footer()}
      {args.footer}
    {/snippet}
  </MyComponent>
{/snippet}
```

See [the `Types.stories.svelte` examples](https://github.com/storybookjs/addon-svelte-csf/blob/main/examples/Types.stories.svelte) on how to use complex types properly.

---

# Comprehensive Guide to Writing Storybook Stories for Svelte Components

This document provides a guide on how to write Storybook stories for Svelte components, leveraging the `storybook-addon-svelte-csf` addon and core Storybook concepts. It synthesizes information from the official Storybook documentation and the specifics of the Svelte CSF format.

## 1. File Structure and Naming

- **File Extension:** Svelte CSF story files **must** use the `.stories.svelte` extension.
- **Naming and Hierarchy:** Use the `title` property in the `meta` export to define the component's position in the Storybook sidebar hierarchy. Follow the format `Category/SubCategory/ComponentName` (e.g., `title: 'Components/Input/Button'`).

## 2. Defining Meta (Component Metadata)

Every `.stories.svelte` file requires a default export, known as `meta`, which contains metadata about the component and its stories. Use the `defineMeta` function **within the `<script module>` context**.

```svelte
<script lang="ts" module>
  // ❗️ Must be in the module context
  import { defineMeta } from '@storybook/addon-svelte-csf';

  import MyComponent from './MyComponent.svelte';

  // 👇 Destructure the Story component from the return value
  const { Story } = defineMeta({
    // Recommended: Path-based grouping for hierarchy
    title: 'Path/To/MyComponent',
    component: MyComponent,
    // Optional: Default args for all stories
    args: {
      label: 'Default Label',
      disabled: false,
      // Example: For action logging
      // onClick: fn(), // Requires import { fn } from '@storybook/test';
    },
    // Optional: Define controls, descriptions, default values, types etc.
    argTypes: {
      label: {
        control: 'text',
        description: 'The text content of the button',
        table: { // Controls appearance in the args table
          type: { summary: 'string' },
          defaultValue: { summary: 'Default Label' },
        },
      },
      disabled: {
        control: 'boolean',
        description: 'Disables interactions with the button'
      },
      variant: {
        control: { type: 'select' }, // Example: Dropdown control
        options: ['primary', 'secondary', 'ghost'],
        description: 'Visual style of the button',
      },
      // Example: Explicitly map an arg to an action
      // onClick: { action: 'clicked' },
    },
    // Optional: Global parameters for the component
    parameters: {
      layout: 'centered', // Example parameter: centers component in canvas
      // backgrounds: { ... }, // Configure background addon
      // viewport: { ... }, // Configure viewport addon
      // docs: { description: { component: 'Documentation for MyComponent...' } } // Add component description in Docs tab
    },
    // Optional: Decorators applied to all stories
    decorators: [
      // Functions or Svelte components that wrap stories
      (Story) => ({
        Component: Story, // Simple functional decorator example
        props: { style: 'margin: 1em;' } // Add wrapper props
      }),
      // DecoratorComponent, // Svelte component decorator example
    ],
    // Optional: Loaders for async data fetching before rendering
    // loaders: [async () => ({ user: await fetch('/api/user').then(res => res.json()) })],
    // Optional: Tags for filtering/categorization and enabling features like autodocs
    tags: ['autodocs', 'component-tag'], // 'autodocs' enables automatic documentation
  });
</script>

<!-- Rest of the story definitions -->
```

- **`defineMeta`:** The core function to define component metadata.
- **`component`:** The Svelte component itself.
- **`title`:** Determines the story's location in the Storybook UI.
- **`args`:** Default props passed to the component in all stories. Can include mocked functions (`fn()`) for testing interactions.
- **`argTypes`:** Provides fine-grained control over Storybook controls, actions, and the documentation table for each prop. Define `control`, `description`, `options`, `table`, `action`, etc.
- **`parameters`:** Storybook features and addon configuration (e.g., `layout`, `backgrounds`, `viewport`, `docs`).
- **`decorators`:** Wrap stories with extra markup or context (e.g., adding padding, providers). Can be global (`meta`), component-level, or story-level.
- **`loaders`:** Async functions that fetch data before a story renders. The loaded data is available in the story context.
- **`tags`:** Used for filtering stories in the UI and enabling specific features. `['autodocs']` is crucial for automatic documentation generation.
- **Return Value:** `defineMeta` returns an object containing the `Story` component, which is used to define individual stories.

## 3. Defining Stories

Use the `Story` component obtained from `defineMeta` to define individual stories within the standard `<script>` tag or markup area.

### 3.1. Plain Story (Args Only)

For components that only need props, define stories using the `name` (or `exportName`) and `args` props on the `Story` component.

```svelte
<script module>
  // ... defineMeta as above ...
  const { Story } = defineMeta({ component: MyComponent /* ... */ });
</script>

<Story name="Primary" args={{ variant: 'primary', label: 'Primary Button' }} />
<Story name="Disabled" args={{ disabled: true, label: 'Disabled Button' }} />
```

### 3.2. Stories with Templates/Snippets

Use Svelte snippets (`{#snippet ...}`) for composition, slots, or custom rendering logic.

**a) Static Template (No Args Propagation)**

Define children directly within `Story`. **Note:** This method ignores story `args`.

```svelte
<script module>
  // ... defineMeta as above ...
  import AnotherComponent from './AnotherComponent.svelte';
  const { Story } = defineMeta({ component: MyComponent /* ... */ });
</script>

<Story name="ComposedStatic">
  <MyComponent>
    <AnotherComponent label="Child Content" />
  </MyComponent>
</Story>
```

**b) Inline Snippet (Args Aware)**

Define a `template` snippet within `Story`. It receives `args`.

```svelte
<script module>
  // ... defineMeta as above ...
  const { Story } = defineMeta({ component: MyComponent /* ... */ });
</script>

<Story name="WithArgsAndSnippet" args={{ label: 'Dynamic Label' }}>
  {#snippet template(args)}
    <MyComponent {...args}>
      <span>{args.label}</span>
    </MyComponent>
  {/snippet}
</Story>
```

**c) Shared Snippet (Args Aware)**

Define a snippet at the top level and pass it as the `template` prop.

```svelte
<script module>
  // ... defineMeta as above ...
  const { Story } = defineMeta({ component: MyComponent /* ... */ });
</script>

{#snippet commonTemplate(args)}
  <MyComponent {...args}>
    {#if args.icon} <i class="icon">{args.icon}</i> {/if}
    {args.label}
  </MyComponent>
{/snippet}

<Story name="With Icon" args={{ label: 'Save', icon: 'disk' }} template={commonTemplate} />
<Story name="No Icon" args={{ label: 'Cancel' }} template={commonTemplate} />
```

**d) Default Snippet (Args Aware)**

Define a meta-level default template using the `render` property on `defineMeta`.

```svelte
<script module>
  import { defineMeta } from '@storybook/addon-svelte-csf';
  import MyComponent from './MyComponent.svelte';
  const { Story } = defineMeta({
    render: template, // 👈 reference the default snippet defined below
  });
</script>

{#snippet template(args)}
  <MyComponent {...args} />
{/snippet}

<Story name="DefaultA" args={{ label: 'A' }} />
<Story name="DefaultB" args={{ label: 'B' }} />
```

### 3.3. Story Naming and Export

- **`name`:** Display name in the Storybook UI.
- **`exportName`:** Explicit exported variable name (avoids conflicts).
- At least one (`name` or `exportName`) is required.

```svelte
<Story name="Friendly Name" args={{ /* ... */ }} exportName="UniqueExport1" />
```

### 3.4. Accessing Story Context and Loaders

The `template` snippet can access `args` and the full `context` (including loader data).

```svelte
<script module>
 // ... defineMeta with loaders ...
 const { Story } = defineMeta({
    component: MyComponent,
    loaders: [async () => ({ user: { name: 'Fetched User' } })],
 });
</script>

<Story name="Using Context And Loader">
  {#snippet template(args, context)}
    {#if context.loaded?.user}
        <p>Welcome, {context.loaded.user.name}!</p>
    {/if}
    <MyComponent {...args} />
    <!-- <pre>{JSON.stringify(context, null, 2)}</pre> -->
  {/snippet}
</Story>
```

## 4. Documentation

- **Autodocs:** Enable with `tags: ['autodocs']` in `meta`. Generates a documentation page from `argTypes`, code comments (JSDoc/TSDoc), and the component definition.
- **MDX for Custom Docs:** Create `.mdx` files alongside or instead of `.stories.svelte` for narrative documentation, embedding stories, and using Doc Blocks.
- **Doc Blocks:** Reusable documentation components (e.g., `<Meta>`, `<Story>`, `<Controls>`, `<Description>`, `<Source>`) for building custom documentation pages in MDX.

## 7. TypeScript Integration

Use TypeScript for type safety (`lang="ts"`).

```svelte
<script lang="ts" module>
  // ❗️ Ensure lang="ts"
  import { type Args, defineMeta, type StoryContext } from '@storybook/addon-svelte-csf';

  import MyComponent from './MyComponent.svelte';

  // Optional: Define a more specific args type
  type MyComponentArgs = import('svelte').ComponentProps<MyComponent> & { customProp: string; };

  const { Story } = defineMeta<MyComponentArgs>({ // Pass generic type
    component: MyComponent,
    // ...
  });
</script>

{#snippet typeSafeTemplate(args: Args<typeof Story>, context: StoryContext<typeof Story>)}
  <MyComponent {...args} customProp={args.customProp.toUpperCase()} />
{/snippet}

<Story name="Typed Story" args={{ customProp: 'hello' }} template={typeSafeTemplate} />
```

- **`lang="ts"`:** Enables TypeScript in `<script>` tags.
- **`Args<typeof Story>`:** Helper type for `args` in snippets.
- **`StoryContext<typeof Story>`:** Helper type for `context` in snippets.
- **`defineMeta<Type>()`:** Explicitly type `args` via generics.

## 5. Stories for Multiple Components

Compose components within story snippets to demonstrate interactions or layouts.

```svelte
<script module>
  import { defineMeta } from '@storybook/addon-svelte-csf';

  import Container from './Container.svelte';
  import Item from './Item.svelte';

  const { Story } = defineMeta({
    title: 'Layouts/ContainerWithItems',
    component: Container, // Or null if just a composition story
  });
</script>

<Story name="Three Items">
  {#snippet template(args)}
    <Container {...args}>
      <Item id="1" /> <Item id="2" /> <Item id="3" />
    </Container>
  {/snippet}
</Story>
```

## 6. Mocking

- **Args Mocking:** Use `argTypes` with `action` or `fn()` from `@storybook/test` to mock callbacks passed as props.
- **Module Mocking:** For mocking imported modules (e.g., API calls, utilities), Storybook integrates with Jest/Vitest mocking capabilities, often configured via test runner setup or global decorators/parameters.
