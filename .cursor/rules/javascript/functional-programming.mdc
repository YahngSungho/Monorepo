---
description:
globs: *.js,*.ts,*.mjs,*.cjs,*.mts,*.cts,*.svelte
alwaysApply: false
---

# Functional Programming Principles & Guidelines

FOLLOW FUNCTIONAL PROGRAMMING PRINCIPLES. ALWAYS USE FUNCTIONAL PROGRAMMING TECHNIQUES.

## Core Principles

1. **Code Separation:** Clearly distinguish and manage code into the following three types:
   1. Data
   2. Calculation (Pure Functions)
   3. Action (Impure Functions, Side Effects)

   Pure code is referred to as Calculation, and impure code is referred to as Action in this codebase.

2. **Preference Order:** **Data > Calculation > Action**
   - Prefer Data over Calculation; prefer Calculation over Action.
   - Whenever possible, implement logic as a Calculation. Consider whether logic can be represented as Data. Isolate Calculations by extracting as much logic as possible into Data.
   - Use Actions only when necessary. Isolate Actions by extracting as much logic as possible into external Calculations. Minimize Action bodies by moving all non-Action logic into external Calculations.
   - Isolate Calculations by extracting as much Data as possible into external constants. Before writing a Calculation, externalize configuration, constants, decision tables, and branching rules as Data (e.g., maps, arrays of rules). Keep Calculation bodies small and deterministic, delegating structure to Data.
   - Isolate Calculations from Actions: move any I/O, logging, timing, randomness, and environment access out of Calculations. Prefer feeding Calculations with Data prepared up-front and consuming their output later.
   - Prefer data-driven design: table-driven logic, config objects, and pattern lists often replace branching inside Calculations.

   ### MUST-FOLLOW RULES (Data/Calculation/Action separation and minimization)

   #### Extract Data from Calculations

   - Non-trivial literal Data must not live inside function bodies. Extract to module-level constants (Data).
   - Non-trivial includes:
     - Multi-line template strings
     - Objects with more than 3 properties or nested objects
     - Arrays with 4 or more elements
     - Regular expressions, styles, endpoints, key lists, user-facing messages
   - Calculations must use only their inputs and module-level Data. No environment access or mutable globals.

   #### Move all Calculations out of Actions

   - `_action` functions (with side effects) must only orchestrate.
   - Disallow inside `_action`: template construction, `map/filter/reduce`, validation, serialization/parsing, data shaping, complex branching.
   - Allowed inside `_action`: calling pure Calculations and performing boundary (I/O) calls.
   - One-level object/array literals are allowed only as minimal wrappers for boundary calls; all other shaping belongs in Calculations.

   #### Examples

   ##### Good (Data/Calculation/Action separated)

   ```js
   // Data
   export const EMAIL_MINIMAL_STYLES = `...`

   // Calculation: serialization
   export const toMailgunParams = (payload) => new URLSearchParams(/* ... */)

   // Action: boundary call only
   export const createMessage_action = R.curry(async (domain, payload) => {
   	const body = toMailgunParams(payload)
   	const res = await fetch(`https://api.mailgun.net/v3/${domain}/messages`, { method: 'POST', body })
   	if (!res.ok) throw new Error('mailgun error')
   	return res.json()
   })
   ```

   ##### Bad (Calculation/Data mixed into Action)

   ```js
   export const send_action = async (domain, markdown) => {
   	const styles = `... multi-line ...` // 데이터가 액션 내부에 있음 (금지)
   	const params = new URLSearchParams() // 직렬화 계산이 액션 내부에 있음 (금지)
   	// ...
   	return fetch(...)
   }
   ```

3. **Managing Actions:**
   - **Isolation:** Make functions with side effects clearly identifiable (e.g., grouped in specific modules, naming conventions).
   - Minimize Actions: keep the Action surface tiny. Extract pure computations into Calculations and pass results into Actions. Keep orchestration thin and explicit.
   - Isolate Actions from Calculations: compose Actions as adapters around boundaries (I/O, network, DOM, DB). Sequence Actions outside of `pipe` when it obscures intent; prefer clear, linear flows.
   - **Naming:** You must suffix the names of functions with side effects with `_action` (e.g., `updateDOM_action`, `fetchData_action`). The suffix highlights side-effect boundaries and aids testing and reviews.

4. **Immutability:** Do not modify data structures (objects, arrays) directly. When changes are needed, create and return new data structures. This improves predictability and simplifies state management.

5. **Function Composition:** Build complex functionality by combining smaller, reusable functions. This enhances code reuse and helps separate logic clearly (e.g., using `R.applyPipe`).

6. **Currying:** Try to use `R.curry` whenever you can.
   - JSDoc for Curried Functions: When you write JSDoc for it, Use callback typedef + type assertion for partially-applied functons.

     ```javascript
     /**
      * @callback SendMailsAction
      * @param {EmailContent} content
      * @param {string[]} emailList
      * @returns {Promise<void>}
      */
     /** @type {SendMailsAction} */
     export const sendMails_action = sendMails_base_action(myInfo)
     ```

## Library Usage

### Ramda / Rambda (via `@library/helpers/R`)

- **Primary Use:** Utilize the `R` object imported from `@library/helpers/R` for functional programming tasks. This export is the primary source for utility functions in this project. Prefer to use these methods than custom code.
- **Import:** `import { R } from '@library/helpers/R'`
- **Features & Philosophy:** This `R` object provides functions inspired by Rambda/Ramda, focusing on TypeScript compatibility and clarity. Key utilities like `pipe` (for composition) and `curry` (for partial application) are available. The guiding philosophy, aligned with Rambda, is to:
  - **Prioritize `R.applyPipe`:** Structure data transformations as a clear sequence of functions within `pipe`.
  - **Favor Simple, Obvious Functions:** Prefer functions whose behavior is clear from their name and signature. Avoid overly generic or "magic" functions that require significant context or documentation lookup (e.g., complex conditional logic handlers like `cond`/`ifElse`, or ambiguous functions like `where`/`update` if they exist in `R`). Complex logic or branching is often clearer handled outside the main pipe.
  - **Avoid Input Order Dependency:** Be mindful of functions where the order of arguments significantly changes behavior and requires memorization (like Ramda's `difference`). Prefer functions with clearer argument roles.
  - **Specific Notations (Rambda Influence):** The `R` object may offer convenient notations for certain functions, inspired by Rambda:
    - `R.path`: Allows **dot notation** (e.g., `R.path('a.b.c')`) as an alternative to array paths (`R.path(['a', 'b', 'c'])`) for accessing nested properties. Note: Use array notation for keys that are purely numeric (e.g., `['a', '1', 'b']` not `'a.1.b'`).
    - `R.pick` / `R.omit`: Allows **comma notation** (e.g., `R.pick('a,b,c', obj)`) as an alternative to array of keys (`R.pick(['a', 'b', 'c'], obj)`). Ensure there are no spaces within the comma-separated string.
- **Usage Pattern:** Functions within `R` often follow a curried style consistent with Rambda's approach, promoting use within `R.applyPipe`:
  - Functions expecting 2 arguments are typically called like: `R.someFunction(arg1)(arg2)`
  - Functions expecting 3 arguments are typically called like: `R.someFunction(arg1, arg2)(arg3)`
  - This pattern facilitates partial application and composition.
- **Example:** Use `R.applyPipe` for composition and `R.curry` for currying. Employ clear, single-purpose functions like `R.map`, `R.filter`, `R.prop`, `R.concat` from the `R` object within pipes. Handle complex conditional logic or side effects primarily before or after the pipe for better readability.

#### Piping utilities in `R`

- `R.applyPipe` (alias of Rambda's `pipe`): left-to-right composition that takes the **initial data first** and immediately executes the pipeline.
  - Async variant: `R.applyPipeAsync` exists for asynchronous pipelines (left-to-right), returning a Promise.

  ```javascript
  import { R } from '@library/helpers/R'

  const result = R.applyPipe(
  	{ a: 1, b: 2 }, // Argument
  	R.prop('a'), // First Apply
  	R.add(10),
  ) // Second Apply
  // result === 11

  // Async pipeline
  const asyncResult = await R.applyPipeAsync(
  	[1, 2, 3], // Argument
  	R.mapAsync(async (n) => n * 2), // First Apply
  	R.filter((n) => n > 2), // Second Apply
  )
  // asyncResult === [4, 6]
  ```

- `R.getPipedFunction` (alias of Ramda's `pipe`): returns a **reusable function** built by composing the provided functions left-to-right. You call the resulting function later with input data.

  ```javascript
  import { R } from '@library/helpers/R'

  const transform = R.getPipedFunction(
  	R.filter((x) => x > 2),
  	R.map((x) => x * 10),
  )

  const out1 = transform([1, 2, 3, 4]) // [30, 40]
  const out2 = transform([3, 5]) // [30, 50]
  ```

- Difference: Use `R.applyPipe`/`R.applyPipeAsync` when you have the initial data now and want to execute immediately. Use `R.getPipedFunction` when you want to define a reusable transformation to apply multiple times later.

#### Object mapping utilities in `R`

- `R.mapObject`: alias of Rambda's `mapObject`. Maps over an object's values with access to `(value, key)`; returns a new object. Curried.

  ```javascript
  import { R } from '@library/helpers/R'

  const src = { a: 1, b: 2 }
  const doubled = R.mapObject((value, key) => value * 2)(src)
  // doubled === { a: 2, b: 4 }
  ```

- `R.mapObjectParallel`: async variant that applies an async mapper `(value, key) => Promise<newValue>` in parallel and resolves to a new object. Curried. Returns `Promise<Record<string, unknown>>`.

  ```javascript
  import { R } from '@library/helpers/R'

  const users = { a: 1, b: 2 }
  const withProfiles = await R.mapObjectParallel(async (id, key) => {
  	return await fetch(`/api/profile/${id}`).then((r) => r.json())
  })(users)
  // withProfiles === { a: {...}, b: {...} }
  ```

### Mutative: A library to help modify objects or arrays while maintaining immutability (just like `immer`)

- **When to Use:** Consider using `mutative` when Ramda doesn't provide a simple method, when the Ramda equivalent is complicated or just unpopular, or when dealing with deeply nested objects that need immutable updates.
- **Import:** `import { create } from '@library/helpers/mutative'`
- **Example:**

  ```javascript
  import { create } from '@library/helpers/mutative'

  const baseState = { count: 0, items: [] }
  const nextState = create(baseState, (draft) => {
  	draft.count++
  	draft.items.push('new')
  })
  // baseState remains unchanged
  ```

## Style Guide

- **Function Composition:** Use `R.applyPipe` (left-to-right) from `@library/helpers/R` to build clear, sequential data transformations. Pass the initial data first, followed by focused, single-purpose functions. Avoid embedding complex conditional logic (e.g., `ifElse`, `cond`) or functions with unclear side effects directly within pipes. Handle conditions and side effects primarily before or after the pipe, or by refactoring the flow into separate, clear steps. For async pipelines, prefer `R.applyPipeAsync`. When you need a reusable transformation function, use `R.getPipedFunction`.

  ```javascript
  import { R } from '@library/helpers/R'

  const numbers = [1, 2, 3, 4, 5]

  // Example: Filter numbers greater than 2, then multiply each by 10
  const processNumbers = R.applyPipe(
  	numbers, // Initial data
  	R.filter((x) => x > 2), // Function 1 (assuming Rambda-style currying: R.filter(predicate)(data))
  	R.map((x) => x * 10), // Function 2 (assuming Rambda-style currying: R.map(fn)(data))
  )
  // processNumbers will be [30, 40, 50]
  console.log(processNumbers)
  ```

- **Naming:** Use clear names that reveal the function's role. Calculations should indicate the relationship between input and output (e.g., `calculateTotal`, `formatUserName`). Actions should indicate what effect they cause (e.g., `saveUser_action`, `logMessage_action`).
- **Conciseness:** Avoid unnecessary abstractions or overly complex functional techniques where simpler imperative or object-oriented approaches are more readable and maintainable. Functional programming is a tool, not a dogma. Prioritize clarity using the utilities provided by `R` from `@library/helpers/R`. Favor simple, obvious functions over complex or ambiguous ones, especially within `pipe`.

## checklist

1. Does any Calculation contain non-trivial literal Data? → Extract to Data constants.
2. Does any `_action` still contain transformation/serialization/validation/template assembly? → Move to Calculations.
