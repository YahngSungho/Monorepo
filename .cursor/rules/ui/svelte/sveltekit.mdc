---
description:
globs: **/+layout.svelte,**/+page.svelte,hooks.*
alwaysApply: false
---

## docs/kit/index.md

--- title: SvelteKit ---

## docs/kit/10-getting-started/index.md

--- title: Getting started ---

## docs/kit/10-getting-started/10-introduction.md

--- title: Introduction --- ## What is SvelteKit? SvelteKit is a framework for rapidly developing robust, performant web applications using Svelte. If you're coming from React, SvelteKit is similar to Next. If you're coming from Vue, SvelteKit is similar to Nuxt. To learn more about the kinds of applications you can build with SvelteKit, see the documentation regarding project types. ## What is Svelte? In short, Svelte is a way of writing user interface components — like a navigation bar, comment section, or contact form — that users see and interact with in their browsers. The Svelte compiler converts your components to JavaScript that can be run to render the HTML for the page and to CSS that styles the page. You don't need to know Svelte to understand the rest of this guide, but it will help. If you'd like to learn more, check out the Svelte tutorial. ## SvelteKit vs Svelte Svelte renders UI components. You can compose these components and render an entire page with just Svelte, but you need more than just Svelte to write an entire app. SvelteKit helps you build web apps while following modern best practices and providing solutions to common development challenges. It offers everything from basic functionalities — like a router that updates your UI when a link is clicked — to more advanced capabilities. Its extensive list of features includes build optimizations to load only the minimal required code; offline support; preloading pages before user navigation; configurable rendering to handle different parts of your app on the server via SSR, in the browser through client-side rendering, or at build-time with prerendering; image optimization; and much more. Building an app with all the modern best practices is fiendishly complicated, but SvelteKit does all the boring stuff for you so that you can get on with the creative part. It reflects changes to your code in the browser instantly to provide a lightning-fast and feature-rich development experience by leveraging Vite with a Svelte plugin to do Hot Module Replacement (HMR).

## docs/kit/10-getting-started/20-creating-a-project.md

--- title: Creating a project --- The easiest way to start building a SvelteKit app is to run `npx sv create`: `bash npx sv create my-app cd my-app npm install npm run dev` The first command will scaffold a new project in the `my-app` directory asking you if you'd like to set up some basic tooling such as TypeScript. See integrations for pointers on setting up additional tooling. The subsequent commands will then install its dependencies and start a server on localhost:5173. There are two basic concepts: - Each page of your app is a Svelte component - You create pages by adding files to the `src/routes` directory of your project. These will be server-rendered so that a user's first visit to your app is as fast as possible, then a client-side app takes over Try editing the files to get a feel for how everything works. ## Editor setup We recommend using Visual Studio Code (aka VS Code) with the Svelte extension, but support also exists for numerous other editors.

## docs/kit/10-getting-started/25-project-types.md

--- title: Project types --- SvelteKit offers configurable rendering, which allows you to build and deploy your project in several different ways. You can build all of the below types of applications and more with SvelteKit. Rendering settings are not mutually exclusive and you may choose the optimal manner with which to render different parts of your application. If you don't have a particular way you'd like to build your application in mind, don't worry! The way your application is built, deployed, and rendered is controlled by which adapter you've chosen and a small amount of configuration and these can always be changed later. The project structure and routing will be the same regardless of the project type that you choose. ## Default rendering By default, when a user visits a site, SvelteKit will render the first page with server-side rendering (SSR) and subsequent pages with client-side rendering (CSR). Using SSR for the initial render improves SEO and perceived performance of the initial page load. Client-side rendering then takes over and updates the page without having to rerender common components, which is typically faster and eliminates a flash when navigating between pages. Apps built with this hybrid rendering approach have also been called transitional apps. ## Static site generation You can use SvelteKit as a static site generator (SSG) that fully prerenders your site with static rendering using `adapter-static`. You may also use the prerender option to prerender only some pages and then choose a different adapter with which to dynamically server-render other pages. Tools built solely to do static site generation may scale the prerendering process more efficiently during build when rendering a very large number of pages. When working with very large statically generated sites, you can avoid long build times with Incremental Static Regeneration (ISR) if using `adapter-vercel`. And in contrast to purpose-built SSGs, SvelteKit allows for nicely mixing and matching different rendering types on different pages. ## Single-page app Single-page apps (SPAs) exclusively use client-side rendering (CSR). You can build single-page apps (SPAs) with SvelteKit. As with all types of SvelteKit applications, you can write your backend in SvelteKit or another language or framework. If you are building an application with no backend or a separate backend, you can simply skip over and ignore the parts of the docs talking about `server` files. ## Multi-page app SvelteKit isn't typically used to build traditional multi-page apps. However, in SvelteKit you can remove all JavaScript on a page with `csr = false`, which will render subsequent links on the server, or you can use `data-sveltekit-reload` to render specific links on the server. ## Separate backend If your backend is written in another language such as Go, Java, PHP, Ruby, Rust, or C#, there are a couple of ways that you can deploy your application. The most recommended way would be to deploy your SvelteKit frontend separately from your backend utilizing `adapter-node` or a serverless adapter. Some users prefer not to have a separate process to manage and decide to deploy their application as a single-page app (SPA) served by their backend server, but note that single-page apps have worse SEO and performance characteristics. If you are using an external backend, you can simply skip over and ignore the parts of the docs talking about `server` files. You may also want to reference the FAQ about how to make calls to a separate backend. ## Serverless app SvelteKit apps are simple to run on serverless platforms. The default zero config adapter will automatically run your app on a number of supported platforms or you can use `adapter-vercel`, `adapter-netlify`, or `adapter-cloudflare` to provide platform-specific configuration. And community adapters allow you to deploy your application to almost any serverless environment. Some of these adapters such as `adapter-vercel` and `adapter-netlify` offer an `edge` option, to support edge rendering for improved latency. ## Your own server You can deploy to your own server or VPS using `adapter-node`. ## Container You can use `adapter-node` to run a SvelteKit app within a container such as Docker or LXC. ## Library You can create a library to be used by other Svelte apps with the `@sveltejs/package` add-on to SvelteKit by choosing the library option when running `sv create`. ## Offline app SvelteKit has full suppport for service workers allowing you to build many types of applications such as offline apps and progressive web apps. ## Mobile app You can turn a SvelteKit SPA into a mobile app with Tauri or Capacitor. Mobile features like the camera, geolocation, and push notifications are available via plugins for both platforms. These mobile development platforms work by starting a local web server and then serving your application like a static host on your phone. You may find `bundleStrategy: 'single'` to be a helpful option to limit the number of requests made. E.g. at the time of writing, the Capacitor local server uses HTTP/1, which limits the number of concurrent connections. ## Desktop app You can turn a SvelteKit SPA into a desktop app with Tauri, Wails, or Electron. ## Browser extension You can build browser extensions using either `adapter-static` or community adapters specifically tailored towards browser extensions. ## Embedded device Because of its efficient rendering, Svelte can be run on low power devices. Embedded devices like microcontrollers and TVs may limit the number of concurrent connections. In order to reduce the number of concurrent requests, you may find `bundleStrategy: 'single'` to be a helpful option in this deployment configuration.

## docs/kit/10-getting-started/30-project-structure.md

--- title: Project structure --- A typical SvelteKit project looks like this: `bash my-project/ ├ src/ │ ├ lib/ │ │ ├ server/ │ │ │ └ your server-only lib files] │ │ └ [your lib files] │ ├ params/ │ │ └ [your param matchers] │ ├ routes/ │ │ └ [your routes] │ ├ app.html │ ├ error.html │ ├ hooks.client.js │ ├ hooks.server.js │ └ service-worker.js ├ static/ │ └ [your static assets] ├ tests/ │ └ [your tests] ├ package.json ├ svelte.config.js ├ tsconfig.json └ vite.config.js` You'll also find common files like `.gitignore` and `.npmrc` (and `.prettierrc` and `eslint.config.js` and so on, if you chose those options when running `npx sv create`). ## Project files ### src The `src` directory contains the meat of your project. Everything except `src/routes` and `src/app.html` is optional. - `lib` contains your library code (utilities and components), which can be imported via the [`$lib` alias, or packaged up for distribution using `svelte-package` - `server` contains your server-only library code. It can be imported by using the `$lib/server` alias. SvelteKit will prevent you from importing these in client code. - `params` contains any param matchers your app needs - `routes` contains the routes of your application. You can also colocate other components that are only used within a single route here - `app.html` is your page template — an HTML document containing the following placeholders: - `%sveltekit.head%` — `<link>` and `<script>` elements needed by the app, plus any `<svelte:head>` content - `%sveltekit.body%` — the markup for a rendered page. This should live inside a `<div>` or other element, rather than directly inside `<body>`, to prevent bugs caused by browser extensions injecting elements that are then destroyed by the hydration process. SvelteKit will warn you in development if this is not the case - `%sveltekit.assets%` — either `paths.assets`, if specified, or a relative path to `paths.base` - `%sveltekit.nonce%` — a CSP nonce for manually included links and scripts, if used - `%sveltekit.env.NAME]%`- this will be replaced at render time with the`[NAME]` environment variable, which must begin with the [`publicPrefix`(usually`PUBLIC\_`). It will fallback to `''`if not matched. -`error.html`is the page that is rendered when everything else fails. It can contain the following placeholders: -`%sveltekit.status%`— the HTTP status -`%sveltekit.error.message%`— the error message -`hooks.client.js`contains your client hooks -`hooks.server.js`contains your server hooks -`service-worker.js`contains your service worker (Whether the project contains`.js`or`.ts`files depends on whether you opt to use TypeScript when you create your project. You can switch between JavaScript and TypeScript in the documentation using the toggle at the bottom of this page.) If you added Vitest when you set up your project, your unit tests will live in the`src`directory with a`.test.js`extension. ### static Any static assets that should be served as-is, like`robots.txt`or`favicon.png`, go in here. ### tests If you added Playwright for browser testing when you set up your project, the tests will live in this directory. ### package.json Your `package.json`file must include`@sveltejs/kit`, `svelte`and`vite`as`devDependencies`. When you create a project with `npx sv create`, you'll also notice that `package.json`includes`"type": "module"`. This means that `.js`files are interpreted as native JavaScript modules with`import`and`export`keywords. Legacy CommonJS files need a`.cjs`file extension. ### svelte.config.js This file contains your Svelte and SvelteKit configuration. ### tsconfig.json This file (or`jsconfig.json`, if you prefer type-checked `.js`files over`.ts`files) configures TypeScript, if you added typechecking during`npx sv create`. Since SvelteKit relies on certain configuration being set a specific way, it generates its own `.svelte-kit/tsconfig.json`file which your own config`extends`. ### vite.config.js A SvelteKit project is really just a Vite project that uses the `@sveltejs/kit/vite`plugin, along with any other Vite configuration. ## Other files ### .svelte-kit As you develop and build your project, SvelteKit will generate files in a`.svelte-kit`directory (configurable as`outDir`). You can ignore its contents, and delete them at any time (they will be regenerated when you next `dev`or`build`).

## docs/kit/10-getting-started/40-web-standards.md

--- title: Web standards --- Throughout this documentation, you'll see references to the standard Web APIs that SvelteKit builds on top of. Rather than reinventing the wheel, we _use the platform_, which means your existing web development skills are applicable to SvelteKit. Conversely, time spent learning SvelteKit will help you be a better web developer elsewhere. These APIs are available in all modern browsers and in many non-browser environments like Cloudflare Workers, Deno, and Vercel Functions. During development, and in adapters for Node-based environments (including AWS Lambda), they're made available via polyfills where necessary (for now, that is — Node is rapidly adding support for more web standards). In particular, you'll get comfortable with the following: ## Fetch APIs SvelteKit uses `fetch` for getting data from the network. It's available in hooks and server routes as well as in the browser. Besides `fetch` itself, the Fetch API includes the following interfaces: ### Request An instance of `Request` is accessible in hooks and server routes as `event.request`. It contains useful methods like `request.json()` and `request.formData()` for getting data that was posted to an endpoint. ### Response An instance of `Response` is returned from `await fetch(...)` and handlers in `+server.js` files. Fundamentally, a SvelteKit app is a machine for turning a `Request` into a `Response`. ### Headers The `Headers` interface allows you to read incoming `request.headers` and set outgoing `response.headers`. For example, you can get the `request.headers` as shown below, and use the `json` convenience function to send modified `response.headers`: `js // @errors: 2461 /// file: src/routes/what-is-my-user-agent/+server.js import { json } from '@sveltejs/kit'; /** @type {import('./$types').RequestHandler} */ export function GET({ request }) { // log all headers console.log(...request.headers); // create a JSON Response using a header we received return json({ // retrieve a specific header userAgent: request.headers.get('user-agent') }, { // set a header on the response headers: { 'x-custom-header': 'potato' } }); }` ## FormData When dealing with HTML native form submissions you'll be working with `FormData` objects. `js // @errors: 2461 /// file: src/routes/hello/+server.js import { json } from '@sveltejs/kit'; /** @type {import('./$types').RequestHandler} */ export async function POST(event) { const body = await event.request.formData(); // log all fields console.log(...body]); return json({ // get a specific field's value name: body.get('name') ?? 'world' }); }` ## Stream APIs Most of the time, your endpoints will return complete data, as in the `userAgent` example above. Sometimes, you may need to return a response that's too large to fit in memory in one go, or is delivered in chunks, and for this the platform provides [streams — ReadableStream, WritableStream and TransformStream. ## URL APIs URLs are represented by the `URL` interface, which includes useful properties like `origin` and `pathname` (and, in the browser, `hash`). This interface shows up in various places — `event.url` in hooks and server routes, `page.url` in pages, `from` and `to` in `beforeNavigate` and `afterNavigate` and so on. ### URLSearchParams Wherever you encounter a URL, you can access query parameters via `url.searchParams`, which is an instance of `URLSearchParams`: `js // @filename: ambient.d.ts declare global { const url: URL; } export {}; // @filename: index.js //cut const foo = url.searchParams.get('foo');` ## Web Crypto The Web Crypto API is made available via the `crypto` global. It's used internally for Content Security Policy headers, but you can also use it for things like generating UUIDs: `js const uuid = crypto.randomUUID();`

## docs/kit/20-core-concepts/index.md

--- title: Core concepts ---

## docs/kit/20-core-concepts/10-routing.md

--- title: Routing --- At the heart of SvelteKit is a _filesystem-based router_. The routes of your app — i.e. the URL paths that users can access — are defined by the directories in your codebase: - `src/routes` is the root route - `src/routes/about` creates an `/about` route - `src/routes/blog/slug]` creates a route with a _parameter_, `slug`, that can be used to load data dynamically when a user requests a page like `/blog/hello-world` Each route directory contains one or more _route files_, which can be identified by their `+` prefix. We'll introduce these files in a moment in more detail, but here are a few simple rules to help you remember how SvelteKit's routing works: _All files can run on the server_ All files run on the client except `+server` files _ `+layout` and `+error` files apply to subdirectories as well as the directory they live in ## +page ### +page.svelte A `+page.svelte` component defines a page of your app. By default, pages are rendered both on the server ([SSR) for the initial request and in the browser (CSR) for subsequent navigation. ```svelte <!file: src/routes/+page.svelte> <h1>Hello and welcome to my site!</h1> <a href="/about">About my site</a>``` ```svelte <!file: src/routes/about/+page.svelte> <h1>About this site</h1> <p>TODO...</p> <a href="/">Home</a>``` Pages can receive data from `load` functions via the `data` prop. ```svelte <!file: src/routes/blog/slug]/+page.svelte> <script> /\*\* @type {import('./$types').PageProps} _/ let { data } = $props(); </script> <h1>{data.title}</h1> <div>{@html data.content}</div>``` > `PageProps` was added in 2.16.0. In earlier versions, you had to type the `data` property manually with `PageData` instead, see [$types. > > In Svelte 4, you'd use `export let data` instead. ### +page.js Often, a page will need to load some data before it can be rendered. For this, we add a `+page.js` module that exports a `load` function: `js /// file: src/routes/blog/slug]/+page.js import { error } from '@sveltejs/kit'; /** @type {import('./$types').PageLoad} _/ export function load({ params }) { if (params.slug === 'hello-world') { return { title: 'Hello world!', content: 'Welcome to our blog. Lorem ipsum dolor sit amet...' }; } error(404, 'Not found'); } ` This function runs alongside `+page.svelte`, which means it runs on the server during server-side rendering and in the browser during client-side navigation. See [`load` for full details of the API. As well as `load`,`+page.js` can export values that configure the page's behaviour: - `export const prerender = true` or `false` or `'auto'` - `export const ssr = true` or `false` - `export const csr = true` or `false` You can find more information about these in page options. ### +page.server.js If your `load` function can only run on the server — for example, if it needs to fetch data from a database or you need to access private environment variables like API keys — then you can rename `+page.js` to `+page.server.js` and change the `PageLoad` type to `PageServerLoad`. ```js /// file: src/routes/blog/slug]/+page.server.js // @filename: ambient.d.ts declare global { const getPostFromDatabase: (slug: string) => { title: string; content: string; } } export {}; // @filename: index.js //cut import { error } from '@sveltejs/kit'; /** @type {import('./$types').PageServerLoad} */ export async function load({ params }) { const post = await getPostFromDatabase(params.slug); if (post) { return post; } error(404, 'Not found'); } ``` During client-side navigation, SvelteKit will load this data from the server, which means that the returned value must be serializable using [devalue. See`load` for full details of the API. Like `+page.js`,`+page.server.js` can export page options — `prerender`,`ssr` and `csr`. A`+page.server.js` file can also export _actions_. If `load` lets you read data from the server, `actions` let you write data _to_ the server using the `<form>` element. To learn how to use them, see the form actions section. ## +error If an error occurs during `load`, SvelteKit will render a default error page. You can customise this error page on a per-route basis by adding an`+error.svelte` file: ```svelte <!file: src/routes/blog/slug]/+error.svelte> <script> import { page } from '$app/state'; </script> <h1>{page.status}: {page.error.message}</h1> ``> `$app/state` was added in SvelteKit 2.12. If you're using an earlier version or are using Svelte 4, use `$app/stores` instead. SvelteKit will 'walk up the tree' looking for the closest error boundary — if the file above didn't exist it would try `src/routes/blog/+error.svelte` and then `src/routes/+error.svelte` before rendering the default error page. If _that_ fails (or if the error was thrown from the `load` function of the root `+layout`, which sits 'above' the root`+error`), SvelteKit will bail out and render a static fallback error page, which you can customise by creating a`src/error.html` file. If the error occurs inside a `load` function in `+layout(.server).js`, the closest error boundary in the tree is an`+error.svelte` file _above_ that layout (not next to it). If no route can be found (404), `src/routes/+error.svelte` (or the default error page, if that file does not exist) will be used. You can read more about error handling [here. ## +layout So far, we've treated pages as entirely standalone components — upon navigation, the existing `+page.svelte` component will be destroyed, and a new one will take its place. But in many apps, there are elements that should be visible on _every_ page, such as top-level navigation or a footer. Instead of repeating them in every `+page.svelte`, we can put them in _layouts_. ### +layout.svelte To create a layout that applies to every page, make a file called`src/routes/+layout.svelte`. The default layout (the one that SvelteKit uses if you don't bring your own) looks like this...``svelte <script> let { children } = $props(); </script> {@render children()} ``...but we can add whatever markup, styles and behaviour we want. The only requirement is that the component includes a`@render` tag for the page content. For example, let's add a nav bar:``svelte <!file: src/routes/+layout.svelte> <script> let { children } = $props(); </script> <nav> <a href="/">Home</a> <a href="/about">About</a> <a href="/settings">Settings</a> </nav> {@render children()} ``If we create pages for `/`,`/about` and `/settings`...``html /// file: src/routes/+page.svelte <h1>Home</h1>` `html /// file: src/routes/about/+page.svelte <h1>About</h1>` `html /// file: src/routes/settings/+page.svelte <h1>Settings</h1> ``...the nav will always be visible, and clicking between the three pages will only result in the`<h1>` being replaced. Layouts can be _nested_. Suppose we don't just have a single `/settings` page, but instead have nested pages like `/settings/profile` and `/settings/notifications` with a shared submenu (for a real-life example, see github.com/settings). We can create a layout that only applies to pages below `/settings` (while inheriting the root layout with the top-level nav):``svelte <!file: src/routes/settings/+layout.svelte> <script> /** @type {import('./$types').LayoutProps} */ let { data, children } = $props(); </script> <h1>Settings</h1> <div class="submenu"> {#each data.sections as section} <a href="/settings/{section.slug}">{section.title}</a> {/each} </div> {@render children()} ``` > `LayoutProps` was added in 2.16.0. In earlier versions, you had to type the properties manually instead. You can see how `data` is populated by looking at the `+layout.js` example in the next section just below. By default, each layout inherits the layout above it. Sometimes that isn't what you want - in this case, advanced layouts can help you. ### +layout.js Just like `+page.svelte` loading data from `+page.js`, your`+layout.svelte` component can get data from a `load` function in `+layout.js`. ```js /// file: src/routes/settings/+layout.js /** @type {import('./$types').LayoutLoad} _/ export function load() { return { sections: { slug: 'profile', title: 'Profile' }, { slug: 'notifications', title: 'Notifications' } ] }; } ``If a`+layout.js` exports [page options — `prerender`,`ssr` and `csr` — they will be used as defaults for child pages. Data returned from a layout's `load` function is also available to all its child pages:``svelte <!file: src/routes/settings/profile/+page.svelte> <script> /\*\* @type {import('./$types').PageProps} _/ let { data } = $props(); console.log(data.sections); // { slug: 'profile', title: 'Profile' }, ...] </script> ``` ### +layout.server.js To run your layout's `load` function on the server, move it to `+layout.server.js`, and change the`LayoutLoad` type to `LayoutServerLoad`. Like`+layout.js`,`+layout.server.js` can export [page options — `prerender`,`ssr` and `csr`. ## +server As well as pages, you can define routes with a`+server.js` file (sometimes referred to as an 'API route' or an 'endpoint'), which gives you full control over the response. Your `+server.js` file exports functions corresponding to HTTP verbs like `GET`,`POST`,`PATCH`,`PUT`,`DELETE`,`OPTIONS`, and`HEAD` that take a `RequestEvent` argument and return a `Response` object. For example we could create an `/api/random-number` route with a `GET` handler: ```js /// file: src/routes/api/random-number/+server.js import { error } from '@sveltejs/kit'; /** @type {import('./$types').RequestHandler} _/ export function GET({ url }) { const min = Number(url.searchParams.get('min') ?? '0'); const max = Number(url.searchParams.get('max') ?? '1'); const d = max - min; if (isNaN(d) || d < 0) { error(400, 'min and max must be numbers, and min must be less than max'); } const random = min + Math.random() _ d; return new Response(String(random)); } ``The first argument to `Response` can be a `ReadableStream`, making it possible to stream large amounts of data or create server-sent events (unless deploying to platforms that buffer responses, like AWS Lambda). You can use the`error`,`redirect` and `json` methods from `@sveltejs/kit` for convenience (but you don't have to). If an error is thrown (either `error(...)` or an unexpected error), the response will be a JSON representation of the error or a fallback error page — which can be customised via `src/error.html` — depending on the `Accept` header. The `+error.svelte` component will _not_ be rendered in this case. You can read more about error handling here. ### Receiving data By exporting `POST`/`PUT`/`PATCH`/`DELETE`/`OPTIONS`/`HEAD` handlers, `+server.js` files can be used to create a complete API:``svelte <!file: src/routes/add/+page.svelte> <script> let a = 0; let b = 0; let total = 0; async function add() { const response = await fetch('/api/add', { method: 'POST', body: JSON.stringify({ a, b }), headers: { 'content-type': 'application/json' } }); total = await response.json(); } </script> <input type="number" bind:value={a}> + <input type="number" bind:value={b}> = {total} <button onclick={add}>Calculate</button> ` `js /// file: src/routes/api/add/+server.js import { json } from '@sveltejs/kit'; /** @type {import('./$types').RequestHandler} \*/ export async function POST({ request }) { const { a, b } = await request.json(); return json(a + b); } ``### Fallback method handler Exporting the`fallback` handler will match any unhandled request methods, including methods like `MOVE` which have no dedicated export from `+server.js`.``js /// file: src/routes/api/add/+server.js import { json, text } from '@sveltejs/kit'; /** @type {import('./$types').RequestHandler} */ export async function POST({ request }) { const { a, b } = await request.json(); return json(a + b); } // This handler will respond to PUT, PATCH, DELETE, etc. /** @type {import('./$types').RequestHandler} _/ export async function fallback({ request }) { return text(`I caught your ${request.method} request!`); } ``### Content negotiation `+server.js` files can be placed in the same directory as `+page` files, allowing the same route to be either a page or an API endpoint. To determine which, SvelteKit applies the following rules: - `PUT`/`PATCH`/`DELETE`/`OPTIONS` requests are always handled by `+server.js` since they do not apply to pages - `GET`/`POST`/`HEAD` requests are treated as page requests if the `accept` header prioritises `text/html` (in other words, it's a browser page request), else they are handled by `+server.js`. - Responses to `GET` requests will include a `Vary: Accept` header, so that proxies and browsers cache HTML and JSON responses separately. ## $types Throughout the examples above, we've been importing types from a `$types.d.ts` file. This is a file SvelteKit creates for you in a hidden directory if you're using TypeScript (or JavaScript with JSDoc type annotations) to give you type safety when working with your root files. For example, annotating `let { data } = $props()` with `PageProps` (or `LayoutProps`, for a `+layout.svelte` file) tells TypeScript that the type of `data` is whatever was returned from `load`:``svelte <!file: src/routes/blog/slug]/+page.svelte> <script> /\*\* @type {import('./$types').PageProps} _/ let { data } = $props(); </script> ``` > The `PageProps` and `LayoutProps` types, added in 2.16.0, are a shortcut for typing the `data` prop as `PageData` or `LayoutData`, as well as other props, such as `form` for pages, or `children` for layouts. In earlier versions, you had to type these properties manually. For example, for a page: > > ```js > /// file: +page.svelte > /_*@type {{ data: import('./$types').PageData, form: import('./$types').ActionData }}*/ > let { data, form } = $props(); > ``` > > Or, for a layout: > > ```js > /// file: +layout.svelte > /** @type {{ data: import('./$types').LayoutData, children: Snippet }} \*/ > let { data, children } = $props(); > ``` In turn, annotating the `load` function with `PageLoad`, `PageServerLoad`, `LayoutLoad` or `LayoutServerLoad` (for `+page.js`, `+page.server.js`, `+layout.js` and `+layout.server.js` respectively) ensures that `params` and the return value are correctly typed. If you're using VS Code or any IDE that supports the language server protocol and TypeScript plugins then you can omit these types _entirely_! Svelte's IDE tooling will insert the correct types for you, so you'll get type checking without writing them yourself. It also works with our command line tool `svelte-check`. You can read more about omitting `$types`in our [blog post about it. ## Other files Any other files inside a route directory are ignored by SvelteKit. This means you can colocate components and utility modules with the routes that need them. If components and modules are needed by multiple routes, it's a good idea to put them in`$lib`. ## Further reading - Tutorial: Routing - Tutorial: API routes - Docs: Advanced routing

## docs/kit/20-core-concepts/20-load.md

--- title: Loading data --- Before a `+page.svelte` component (and its containing `+layout.svelte` components) can be rendered, we often need to get some data. This is done by defining `load` functions. ## Page data A `+page.svelte` file can have a sibling `+page.js` that exports a `load` function, the return value of which is available to the page via the `data` prop: ``js /// file: src/routes/blog/slug]/+page.js /** @type {import('./$types').PageLoad} */ export function load({ params }) { return { post: { title: `Title for ${params.slug} goes here`, content: `Content for ${params.slug} goes here` } }; }`` `svelte <!file: src/routes/blog/[slug]/+page.svelte> <script> /** @type {import('./$types').PageProps} */ let { data } = $props(); </script> <h1>{data.post.title}</h1> <div>{@html data.post.content}</div>` > Before version 2.16.0, the props of a page and layout had to be typed individually: > `js > /// file: +page.svelte > /** @type {{ data: import('./$types').PageData }} */ > let { data } = $props(); >` > > In Svelte 4, you'd use `export let data` instead. Thanks to the generated `$types` module, we get full type safety. A `load` function in a `+page.js` file runs both on the server and in the browser (unless combined with `export const ssr = false`, in which case it will [only run in the browser). If your `load` function should _always_ run on the server (because it uses private environment variables, for example, or accesses a database) then it would go in a `+page.server.js` instead. A more realistic version of your blog post's `load` function, that only runs on the server and pulls data from a database, might look like this: ```js /// file: src/routes/blog/slug]/+page.server.js // @filename: ambient.d.ts declare module '$lib/server/database' { export function getPost(slug: string): Promise<{ title: string, content: string }> } // @filename: index.js //cut import * as db from '$lib/server/database'; /** @type {import('./$types').PageServerLoad} */ export async function load({ params }) { return { post: await db.getPost(params.slug) }; }``` Notice that the type changed from `PageLoad` to `PageServerLoad`, because server `load` functions can access additional arguments. To understand when to use `+page.js` and when to use `+page.server.js`, see [Universal vs server. ## Layout data Your `+layout.svelte` files can also load data, via `+layout.js` or `+layout.server.js`. ```js /// file: src/routes/blog/slug]/+layout.server.js // @filename: ambient.d.ts declare module '$lib/server/database' { export function getPostSummaries(): Promise<Array<{ title: string, slug: string }>> } // @filename: index.js //cut import \* as db from '$lib/server/database'; /** @type {import('./$types').LayoutServerLoad} */ export async function load() { return { posts: await db.getPostSummaries() }; }``` ```svelte <!file: src/routes/blog/[slug]/+layout.svelte> <script> /** @type {import('./$types').LayoutProps} _/ let { data, children } = $props(); </script> <main> {@render children()} </main> <aside> <h2>More posts</h2> <ul> {#each data.posts as post} <li> <a href="/blog/{post.slug}"> {post.title} </a> </li> {/each} </ul> </aside>``` > `LayoutProps` was added in 2.16.0. In earlier versions, properties had to be typed individually: > ```js > /// file: +layout.svelte > /** @type {{ data: import('./$types').LayoutData, children: Snippet }} _/ > let { data, children } = $props(); >``` Data returned from layout `load` functions is available to child `+layout.svelte` components and the `+page.svelte` component as well as the layout that it 'belongs' to. ```svelte /// file: src/routes/blog/[slug]/+page.svelte <script> import { page } from '$app/state'; /** @type {import('./$types').PageProps} */ let { data } = $props(); // we can access `data.posts` because it's returned from // the parent layout `load` function let index = $derived(data.posts.findIndex(post => post.slug === page.params.slug)); let next = $derived(data.posts[index + 1]); </script> <h1>{data.post.title}</h1> <div>{@html data.post.content}</div> {#if next} <p>Next post: <a href="/blog/{next.slug}">{next.title}</a></p> {/if}``` ## page.data The `+page.svelte` component, and each `+layout.svelte` component above it, has access to its own data plus all the data from its parents. In some cases, we might need the opposite — a parent layout might need to access page data or data from a child layout. For example, the root layout might want to access a `title` property returned from a `load` function in `+page.js` or `+page.server.js`. This can be done with `page.data`: ```svelte <!file: src/routes/+layout.svelte> <script> import { page } from '$app/state'; </script> <svelte:head> <title>{page.data.title}</title> </svelte:head> ``Type information for `page.data` is provided by `App.PageData`. > `$app/state` was added in SvelteKit 2.12. If you're using an earlier version or are using Svelte 4, use `$app/stores` instead. > It provides a `page` store with the same interface that you can subscribe to, e.g. `$page.data.title`. ## Universal vs server As we've seen, there are two types of `load` function: * `+page.js` and `+layout.js` files export _universal_ `load` functions that run both on the server and in the browser * `+page.server.js` and `+layout.server.js` files export _server_ `load` functions that only run server-side Conceptually, they're the same thing, but there are some important differences to be aware of. ### When does which load function run? Server `load` functions _always_ run on the server. By default, universal `load` functions run on the server during SSR when the user first visits your page. They will then run again during hydration, reusing any responses from [fetch requests. All subsequent invocations of universal `load` functions happen in the browser. You can customize the behavior through page options. If you disable server side rendering, you'll get an SPA and universal `load` functions _always_ run on the client. If a route contains both universal and server `load` functions, the server `load` runs first. A `load` function is invoked at runtime, unless you prerender the page — in that case, it's invoked at build time. ### Input Both universal and server `load` functions have access to properties describing the request (`params`, `route` and `url`) and various functions (`fetch`, `setHeaders`, `parent`, `depends` and `untrack`). These are described in the following sections. Server `load` functions are called with a `ServerLoadEvent`, which inherits `clientAddress`, `cookies`, `locals`, `platform` and `request` from `RequestEvent`. Universal `load` functions are called with a `LoadEvent`, which has a `data` property. If you have `load` functions in both `+page.js` and `+page.server.js` (or `+layout.js` and `+layout.server.js`), the return value of the server `load` function is the `data` property of the universal `load` function's argument. ### Output A universal `load` function can return an object containing any values, including things like custom classes and component constructors. A server `load` function must return data that can be serialized with devalue — anything that can be represented as JSON plus things like `BigInt`, `Date`, `Map`, `Set` and `RegExp`, or repeated/cyclical references — so that it can be transported over the network. Your data can include promises, in which case it will be streamed to browsers. ### When to use which Server `load` functions are convenient when you need to access data directly from a database or filesystem, or need to use private environment variables. Universal `load` functions are useful when you need to `fetch` data from an external API and don't need private credentials, since SvelteKit can get the data directly from the API rather than going via your server. They are also useful when you need to return something that can't be serialized, such as a Svelte component constructor. In rare cases, you might need to use both together — for example, you might need to return an instance of a custom class that was initialised with data from your server. When using both, the server `load` return value is _not_ passed directly to the page, but to the universal `load` function (as the `data` property):``js /// file: src/routes/+page.server.js /** @type {import('./$types').PageServerLoad} */ export async function load() { return { serverMessage: 'hello from server load function' }; }``` ```js /// file: src/routes/+page.js // @errors: 18047 /** @type {import('./$types').PageLoad} _/ export async function load({ data }) { return { serverMessage: data.serverMessage, universalMessage: 'hello from universal load function' }; } ``## Using URL data Often the `load` function depends on the URL in one way or another. For this, the `load` function provides you with `url`, `route` and `params`. ### url An instance of `URL`, containing properties like the `origin`, `hostname`, `pathname` and `searchParams` (which contains the parsed query string as a `URLSearchParams` object). `url.hash` cannot be accessed during `load`, since it is unavailable on the server. ### route Contains the name of the current route directory, relative to `src/routes`:``js /// file: src/routes/a/b]/[...c]/+page.js /\*\* @type {import('./$types').PageLoad} _/ export function load({ route }) { console.log(route.id); // '/a/[b]/[...c]' } ``### params `params` is derived from `url.pathname` and `route.id`. Given a `route.id` of `/a/[b]/[...c]` and a `url.pathname` of `/a/x/y/z`, the `params` object would look like this:``json { "b": "x", "c": "y/z" } ``## Making fetch requests To get data from an external API or a `+server.js` handler, you can use the provided `fetch` function, which behaves identically to the [native `fetch` web API with a few additional features: - It can be used to make credentialed requests on the server, as it inherits the `cookie` and `authorization` headers for the page request. - It can make relative requests on the server (ordinarily, `fetch` requires a URL with an origin when used in a server context). - Internal requests (e.g. for `+server.js` routes) go directly to the handler function when running on the server, without the overhead of an HTTP call. - During server-side rendering, the response will be captured and inlined into the rendered HTML by hooking into the `text`, `json` and `arrayBuffer` methods of the `Response` object. Note that headers will _not_ be serialized, unless explicitly included via `filterSerializedResponseHeaders`. - During hydration, the response will be read from the HTML, guaranteeing consistency and preventing an additional network request - if you received a warning in your browser console when using the browser `fetch` instead of the `load` `fetch`, this is why.``js /// file: src/routes/items/id]/+page.js /** @type {import('./$types').PageLoad} */ export async function load({ fetch, params }) { const res = await fetch(`/api/items/${params.id}`); const item = await res.json(); return { item }; }``` ## Cookies A server `load` function can get and set [`cookies`. ```js /// file: src/routes/+layout.server.js // @filename: ambient.d.ts declare module '$lib/server/database' { export function getUser(sessionid: string | undefined): Promise<{ name: string, avatar: string }> } // @filename: index.js //cut import * as db from '$lib/server/database'; /** @type {import('./$types').LayoutServerLoad} */ export async function load({ cookies }) { const sessionid = cookies.get('sessionid'); return { user: await db.getUser(sessionid) }; }``` Cookies will only be passed through the provided `fetch` function if the target host is the same as the SvelteKit application or a more specific subdomain of it. For example, if SvelteKit is serving my.domain.com: - domain.com WILL NOT receive cookies - my.domain.com WILL receive cookies - api.domain.com WILL NOT receive cookies - sub.my.domain.com WILL receive cookies Other cookies will not be passed when `credentials: 'include'` is set, because SvelteKit does not know which domain which cookie belongs to (the browser does not pass this information along), so it's not safe to forward any of them. Use the handleFetch hook to work around it. ## Headers Both server and universal `load` functions have access to a `setHeaders` function that, when running on the server, can set headers for the response. (When running in the browser, `setHeaders` has no effect.) This is useful if you want the page to be cached, for example: ```js // @errors: 2322 1360 /// file: src/routes/products/+page.js /** @type {import('./$types').PageLoad} _/ export async function load({ fetch, setHeaders }) { const url = `https://cms.example.com/products.json`; const response = await fetch(url); // Headers are only set during SSR, caching the page's HTML // for the same length of time as the underlying data. setHeaders({ age: response.headers.get('age'), 'cache-control': response.headers.get('cache-control') }); return response.json(); } ``Setting the same header multiple times (even in separate `load` functions) is an error. You can only set a given header once using the `setHeaders` function. You cannot add a `set-cookie` header with `setHeaders` — use `cookies.set(name, value, options)` instead. ## Using parent data Occasionally it's useful for a `load` function to access data from a parent `load` function, which can be done with `await parent()`:``js /// file: src/routes/+layout.js /\*\* @type {import('./$types').LayoutLoad} _/ export function load() { return { a: 1 }; } ` `js /// file: src/routes/abc/+layout.js /** @type {import('./$types').LayoutLoad} \*/ export async function load({ parent }) { const { a } = await parent(); return { b: a + 1 }; } ` `js /// file: src/routes/abc/+page.js /** @type {import('./$types').PageLoad} */ export async function load({ parent }) { const { a, b } = await parent(); return { c: a + b }; }``` ```svelte <!file: src/routes/abc/+page.svelte> <script> /** @type {import('./$types').PageProps} _/ let { data } = $props(); </script> <p>{data.a} + {data.b} = {data.c}</p>``` Inside `+page.server.js` and `+layout.server.js`, `parent` returns data from parent `+layout.server.js` files. In `+page.js` or `+layout.js` it will return data from parent `+layout.js` files. However, a missing `+layout.js` is treated as a `({ data }) => data` function, meaning that it will also return data from parent `+layout.server.js` files that are not 'shadowed' by a `+layout.js` file Take care not to introduce waterfalls when using `await parent()`. Here, for example, `getData(params)` does not depend on the result of calling `parent()`, so we should call it first to avoid a delayed render. ```js /// file: +page.js // @filename: ambient.d.ts declare function getData(params: Record<string, string>): Promise<{ meta: any }> // @filename: index.js //cut /** @type {import('./$types').PageLoad} _/ export async function load({ params, parent }) { const parentData = await parent(); const data = await getData(params); const parentData = await parent(); return { ...data, meta: { ...parentData.meta, ...data.meta } }; } ``## Errors If an error is thrown during `load`, the nearest `+error.svelte` will be rendered. For _expected_ errors, use the `error` helper from `@sveltejs/kit` to specify the HTTP status code and an optional message:``js /// file: src/routes/admin/+layout.server.js // @filename: ambient.d.ts declare namespace App { interface Locals { user?: { name: string; isAdmin: boolean; } } } // @filename: index.js //cut import { error } from '@sveltejs/kit'; /** @type {import('./$types').LayoutServerLoad} \*/ export function load({ locals }) { if (!locals.user) { error(401, 'not logged in'); } if (!locals.user.isAdmin) { error(403, 'not an admin'); } } ``Calling `error(...)` will throw an exception, making it easy to stop execution from inside helper functions. If an _unexpected_ error is thrown, SvelteKit will invoke `handleError` and treat it as a 500 Internal Error. ## Redirects To redirect users, use the `redirect` helper from `@sveltejs/kit` to specify the location to which they should be redirected alongside a `3xx` status code. Like `error(...)`, calling `redirect(...)` will throw an exception, making it easy to stop execution from inside helper functions.``js /// file: src/routes/user/+layout.server.js // @filename: ambient.d.ts declare namespace App { interface Locals { user?: { name: string; } } } // @filename: index.js //cut import { redirect } from '@sveltejs/kit'; /** @type {import('./$types').LayoutServerLoad} */ export function load({ locals }) { if (!locals.user) { redirect(307, '/login'); } }``` In the browser, you can also navigate programmatically outside of a `load` function using `goto` from `$app.navigation`. ## Streaming with promises When using a server `load`, promises will be streamed to the browser as they resolve. This is useful if you have slow, non-essential data, since you can start rendering the page before all the data is available: ```js /// file: src/routes/blog/slug]/+page.server.js // @filename: ambient.d.ts declare global { const loadPost: (slug: string) => Promise<{ title: string, content: string }>; const loadComments: (slug: string) => Promise<{ content: string }>; } export {}; // @filename: index.js //cut /** @type {import('./$types').PageServerLoad} */ export async function load({ params }) { return { // make sure the `await`happens at the end, otherwise we // can't start loading comments until we've loaded the post comments: loadComments(params.slug), post: await loadPost(params.slug) }; }``` This is useful for creating skeleton loading states, for example: ```svelte <!file: src/routes/blog/[slug]/+page.svelte> <script> /** @type {import('./$types').PageProps} */ let { data } = $props(); </script> <h1>{data.post.title}</h1> <div>{@html data.post.content}</div> {#await data.comments} Loading comments... {:then comments} {#each comments as comment} <p>{comment.content}</p> {/each} {:catch error} <p>error loading comments: {error.message}</p> {/await}``` When streaming data, be careful to handle promise rejections correctly. More specifically, the server could crash with an "unhandled promise rejection" error if a lazy-loaded promise fails before rendering starts (at which point it's caught) and isn't handling the error in some way. When using SvelteKit's`fetch`directly in the`load` function, SvelteKit will handle this case for you. For other promises, it is enough to attach a noop-`catch`to the promise to mark it as handled. ```js /// file: src/routes/+page.server.js /** @type {import('./$types').PageServerLoad} */ export function load({ fetch }) { const ok_manual = Promise.reject(); ok_manual.catch(() => {}); return { ok_manual, ok_fetch: fetch('/fetch/that/could/fail'), dangerous_unhandled: Promise.reject() }; }``` ## Parallel loading When rendering (or navigating to) a page, SvelteKit runs all`load`functions concurrently, avoiding a waterfall of requests. During client-side navigation, the result of calling multiple server`load`functions are grouped into a single response. Once all`load`functions have returned, the page is rendered. ## Rerunning load functions SvelteKit tracks the dependencies of each`load`function to avoid rerunning it unnecessarily during navigation. For example, given a pair of`load`functions like these... ```js /// file: src/routes/blog/[slug]/+page.server.js // @filename: ambient.d.ts declare module '$lib/server/database' { export function getPost(slug: string): Promise<{ title: string, content: string }> } // @filename: index.js //cut import * as db from '$lib/server/database'; /** @type {import('./$types').PageServerLoad} */ export async function load({ params }) { return { post: await db.getPost(params.slug) }; }``` ```js /// file: src/routes/blog/[slug]/+layout.server.js // @filename: ambient.d.ts declare module '$lib/server/database' { export function getPostSummaries(): Promise<Array<{ title: string, slug: string }>> } // @filename: index.js //cut import * as db from '$lib/server/database'; /** @type {import('./$types').LayoutServerLoad} */ export async function load() { return { posts: await db.getPostSummaries() }; }``` ...the one in`+page.server.js`will rerun if we navigate from`/blog/trying-the-raw-meat-diet`to`/blog/i-regret-my-choices`because`params.slug`has changed. The one in`+layout.server.js`will not, because the data is still valid. In other words, we won't call`db.getPostSummaries()`a second time. A`load`function that calls`await parent()`will also rerun if a parent`load`function is rerun. Dependency tracking does not apply _after_ the`load`function has returned — for example, accessing`params.x`inside a nested [promise will not cause the function to rerun when`params.x`changes. (Don't worry, you'll get a warning in development if you accidentally do this.) Instead, access the parameter in the main body of your`load`function. Search parameters are tracked independently from the rest of the url. For example, accessing`event.url.searchParams.get("x")`inside a`load`function will make that`load`function re-run when navigating from`?x=1`to`?x=2`, but not when navigating from `?x=1&y=1`to`?x=1&y=2`. ### Untracking dependencies In rare cases, you may wish to exclude something from the dependency tracking mechanism. You can do this with the provided `untrack`function: ```js /// file: src/routes/+page.js /** @type {import('./$types').PageLoad} */ export async function load({ untrack, url }) { // Untrack url.pathname so that path changes don't trigger a rerun if (untrack(() => url.pathname === '/')) { return { message: 'Welcome!' }; } }``` ### Manual invalidation You can also rerun`load`functions that apply to the current page using`invalidate(url)`, which reruns all `load`functions that depend on`url`, and `invalidateAll()`, which reruns every `load`function. Server load functions will never automatically depend on a fetched`url`to avoid leaking secrets to the client. A`load`function depends on`url`if it calls`fetch(url)`or`depends(url)`. Note that `url`can be a custom identifier that starts with`a-z]:`: ```js /// file: src/routes/random-number/+page.js /** @type {import('./$types').PageLoad} */ export async function load({ fetch, depends }) { // load reruns when `invalidate('https://api.example.com/random-number')` is called... const response = await fetch('https://api.example.com/random-number'); // ...or when `invalidate('app:random')` is called depends('app:random'); return { number: await response.json() }; } ` `svelte <!file: src/routes/random-number/+page.svelte> <script> import { invalidate, invalidateAll } from '$app/navigation'; /** @type {import('./$types').PageProps} \*/ let { data } = $props(); function rerunLoadFunction() { // any of these will cause the `load` function to rerun invalidate('app:random'); invalidate('https://api.example.com/random-number'); invalidate(url => url.href.includes('random-number')); invalidateAll(); } </script> <p>random number: {data.number}</p> <button onclick={rerunLoadFunction}>Update random number</button>``` ### When do load functions rerun? To summarize, a `load` function will rerun in the following situations: - It references a property of `params` whose value has changed - It references a property of `url` (such as `url.pathname` or `url.search`) whose value has changed. Properties in `request.url` are _not_ tracked - It calls `url.searchParams.get(...)`, `url.searchParams.getAll(...)` or `url.searchParams.has(...)` and the parameter in question changes. Accessing other properties of `url.searchParams` will have the same effect as accessing `url.search`. - It calls `await parent()` and a parent `load` function reran - A child `load` function calls `await parent()` and is rerunning, and the parent is a server load function - It declared a dependency on a specific URL via [`fetch` (universal load only) or `depends`, and that URL was marked invalid with `invalidate(url)` - All active `load` functions were forcibly rerun with `invalidateAll()` `params` and `url` can change in response to a `<a href="..">` link click, a `<form>` interaction, a `goto` invocation, or a `redirect`. Note that rerunning a `load` function will update the `data` prop inside the corresponding `+layout.svelte` or `+page.svelte`; it does _not_ cause the component to be recreated. As a result, internal state is preserved. If this isn't what you want, you can reset whatever you need to reset inside an `afterNavigate` callback, and/or wrap your component in a `{#key ...}` block. ## Implications for authentication A couple features of loading data have important implications for auth checks: - Layout `load` functions do not run on every request, such as during client side navigation between child routes. (When do load functions rerun?) - Layout and page `load` functions run concurrently unless `await parent()` is called. If a layout `load` throws, the page `load` function runs, but the client will not receive the returned data. There are a few possible strategies to ensure an auth check occurs before protected code. To prevent data waterfalls and preserve layout `load` caches: - Use hooks to protect multiple routes before any `load` functions run - Use auth guards directly in `+page.server.js` `load` functions for route specific protection Putting an auth guard in `+layout.server.js` requires all child pages to call `await parent()` before protected code. Unless every child page depends on returned data from `await parent()`, the other options will be more performant. ## Using `getRequestEvent` When running server `load` functions, the `event` object passed to the function as an argument can also be retrieved with `getRequestEvent`. This allows shared logic (such as authentication guards) to access information about the current request without it needing to be passed around. For example, you might have a function that requires users to be logged in, and redirects them to `/login` if not: ```js /// file: src/lib/server/auth.js // @filename: ambient.d.ts interface User { name: string; } declare namespace App { interface Locals { user?: User; } } // @filename: index.ts //cut import { redirect } from '@sveltejs/kit'; import { getRequestEvent } from '$app/server'; export function requireLogin() { const { locals, url } = getRequestEvent(); // assume `locals.user` is populated in `handle` if (!locals.user) { const redirectTo = url.pathname + url.search; const params = new URLSearchParams({ redirectTo }); redirect(307, `/login?${params}`); } return locals.user; } ``Now, you can call `requireLogin` in any `load` function (or form action, for example) to guarantee that the user is logged in:``js /// file: +page.server.js // @filename: ambient.d.ts declare module '$lib/server/auth' { interface User { name: string; } export function requireLogin(): User; } // @filename: index.ts //cut import { requireLogin } from '$lib/server/auth'; export function load() { const user = requireLogin(); // `user` is guaranteed to be a user object here, because otherwise // `requireLogin` would throw a redirect and we wouldn't get here return { message: `hello ${user.name}!` }; }``` ## Further reading - Tutorial: Loading data - Tutorial: Errors and redirects - Tutorial: Advanced loading

## docs/kit/20-core-concepts/30-form-actions.md

--- title: Form actions --- A `+page.server.js` file can export _actions_, which allow you to `POST` data to the server using the `<form>` element. When using `<form>`, client-side JavaScript is optional, but you can easily _progressively enhance_ your form interactions with JavaScript to provide the best user experience. ## Default actions In the simplest case, a page declares a `default` action: `js /// file: src/routes/login/+page.server.js /** @satisfies {import('./$types').Actions} */ export const actions = { default: async (event) => { // TODO log the user in } };` To invoke this action from the `/login` page, just add a `<form>` — no JavaScript needed: `svelte <!file: src/routes/login/+page.svelte> <form method="POST"> <label> Email <input name="email" type="email"> </label> <label> Password <input name="password" type="password"> </label> <button>Log in</button> </form>` If someone were to click the button, the browser would send the form data via `POST` request to the server, running the default action. We can also invoke the action from other pages (for example if there's a login widget in the nav in the root layout) by adding the `action` attribute, pointing to the page: `html /// file: src/routes/+layout.svelte <form method="POST" action="/login"> </form>` ## Named actions Instead of one `default` action, a page can have as many named actions as it needs: `js /// file: src/routes/login/+page.server.js /** @satisfies {import('./$types').Actions} */ export const actions = { default: async (event) => { login: async (event) => { // TODO log the user in }, register: async (event) => { // TODO register the user } };` To invoke a named action, add a query parameter with the name prefixed by a `/` character: `svelte <!file: src/routes/login/+page.svelte> <form method="POST" action="?/register">` `svelte <!file: src/routes/+layout.svelte> <form method="POST" action="/login?/register">` As well as the `action` attribute, we can use the `formaction` attribute on a button to `POST` the same form data to a different action than the parent `<form>`: `svelte /// file: src/routes/login/+page.svelte <form method="POST"action="?/login"> <label> Email <input name="email" type="email"> </label> <label> Password <input name="password" type="password"> </label> <button>Log in</button> <button formaction="?/register">Register</button> </form>` ## Anatomy of an action Each action receives a `RequestEvent` object, allowing you to read the data with `request.formData()`. After processing the request (for example, logging the user in by setting a cookie), the action can respond with data that will be available through the `form` property on the corresponding page and through `page.form` app-wide until the next update. `js /// file: src/routes/login/+page.server.js // @filename: ambient.d.ts declare module '$lib/server/db'; // @filename: index.js //cut import * as db from '$lib/server/db'; /** @type {import('./$types').PageServerLoad} */ export async function load({ cookies }) { const user = await db.getUserFromSession(cookies.get('sessionid')); return { user }; } /** @satisfies {import('./$types').Actions} */ export const actions = { login: async ({ cookies, request }) => { const data = await request.formData(); const email = data.get('email'); const password = data.get('password'); const user = await db.getUser(email); cookies.set('sessionid', await db.createSession(user), { path: '/' }); return { success: true }; }, register: async (event) => { // TODO register the user } };` `svelte <!file: src/routes/login/+page.svelte> <script> /** @type {import('./$types').PageProps} */ let { data, form } = $props(); </script> {#if form?.success} <p>Successfully logged in! Welcome back, {data.user.name}</p> {/if}` > `PageProps` was added in 2.16.0. In earlier versions, you had to type the `data` and `form` properties individually: > `js > /// file: +page.svelte > /** @type {{ data: import('./$types').PageData, form: import('./$types').ActionData }} */ > let { data, form } = $props(); >` > > In Svelte 4, you'd use `export let data` and `export let form` instead to declare properties. ### Validation errors If the request couldn't be processed because of invalid data, you can return validation errors — along with the previously submitted form values — back to the user so that they can try again. The `fail` function lets you return an HTTP status code (typically 400 or 422, in the case of validation errors) along with the data. The status code is available through `page.status` and the data through `form`: `js /// file: src/routes/login/+page.server.js // @filename: ambient.d.ts declare module '$lib/server/db'; // @filename: index.js //cut import { fail } from '@sveltejs/kit'; import * as db from '$lib/server/db'; /** @satisfies {import('./$types').Actions} */ export const actions = { login: async ({ cookies, request }) => { const data = await request.formData(); const email = data.get('email'); const password = data.get('password'); if (!email) { return fail(400, { email, missing: true }); } const user = await db.getUser(email); if (!user || user.password !== db.hash(password)) { return fail(400, { email, incorrect: true }); } cookies.set('sessionid', await db.createSession(user), { path: '/' }); return { success: true }; }, register: async (event) => { // TODO register the user } };` `svelte /// file: src/routes/login/+page.svelte <form method="POST" action="?/login"> {#if form?.missing}<p class="error">The email field is required</p>{/if} {#if form?.incorrect}<p class="error">Invalid credentials!</p>{/if} <label> Email <input name="email" type="email"value={form?.email ?? ''}> </label> <label> Password <input name="password" type="password"> </label> <button>Log in</button> <button formaction="?/register">Register</button> </form>` The returned data must be serializable as JSON. Beyond that, the structure is entirely up to you. For example, if you had multiple forms on the page, you could distinguish which `<form>` the returned `form` data referred to with an `id` property or similar. ### Redirects Redirects (and errors) work exactly the same as in `load`: `js // @errors: 2345 /// file: src/routes/login/+page.server.js // @filename: ambient.d.ts declare module '$lib/server/db'; // @filename: index.js //cut import { fail,redirect} from '@sveltejs/kit'; import * as db from '$lib/server/db'; /** @satisfies {import('./$types').Actions} */ export const actions = { login: async ({ cookies, request,url}) => { const data = await request.formData(); const email = data.get('email'); const password = data.get('password'); const user = await db.getUser(email); if (!user) { return fail(400, { email, missing: true }); } if (user.password !== db.hash(password)) { return fail(400, { email, incorrect: true }); } cookies.set('sessionid', await db.createSession(user), { path: '/' }); if (url.searchParams.has('redirectTo')) { redirect(303, url.searchParams.get('redirectTo')); } return { success: true }; }, register: async (event) => { // TODO register the user } };` ## Loading data After an action runs, the page will be re-rendered (unless a redirect or an unexpected error occurs), with the action's return value available to the page as the `form` prop. This means that your page's `load` functions will run after the action completes. Note that `handle` runs before the action is invoked, and does not rerun before the `load` functions. This means that if, for example, you use `handle` to populate `event.locals` based on a cookie, you must update `event.locals` when you set or delete the cookie in an action: `js /// file: src/hooks.server.js // @filename: ambient.d.ts declare namespace App { interface Locals { user: { name: string; } | null } } // @filename: global.d.ts declare global { function getUser(sessionid: string | undefined): { name: string; }; } export {}; // @filename: index.js //cut /** @type {import('@sveltejs/kit').Handle} */ export async function handle({ event, resolve }) { event.locals.user = await getUser(event.cookies.get('sessionid')); return resolve(event); }` `js /// file: src/routes/account/+page.server.js // @filename: ambient.d.ts declare namespace App { interface Locals { user: { name: string; } | null } } // @filename: index.js //cut /** @type {import('./$types').PageServerLoad} */ export function load(event) { return { user: event.locals.user }; } /** @satisfies {import('./$types').Actions} */ export const actions = { logout: async (event) => { event.cookies.delete('sessionid', { path: '/' }); event.locals.user = null; } };` ## Progressive enhancement In the preceding sections we built a `/login` action that works without client-side JavaScript — not a `fetch` in sight. That's great, but when JavaScript _is_ available we can progressively enhance our form interactions to provide a better user experience. ### use:enhance The easiest way to progressively enhance a form is to add the `use:enhance` action: `svelte /// file: src/routes/login/+page.svelte <script> import { enhance } from '$app/forms'; /** @type {import('./$types').PageProps} */ let { form } = $props(); </script> <form method="POST"use:enhance>` Without an argument, `use:enhance` will emulate the browser-native behaviour, just without the full-page reloads. It will: - update the `form` property, `page.form` and `page.status` on a successful or invalid response, but only if the action is on the same page you're submitting from. For example, if your form looks like `<form action="/somewhere/else" ..>`, the `form` prop and the `page.form` state will _not_ be updated. This is because in the native form submission case you would be redirected to the page the action is on. If you want to have them updated either way, use `applyAction` - reset the `<form>` element - invalidate all data using `invalidateAll` on a successful response - call `goto` on a redirect response - render the nearest `+error` boundary if an error occurs - reset focus to the appropriate element ### Customising use:enhance To customise the behaviour, you can provide a `SubmitFunction` that runs immediately before the form is submitted, and (optionally) returns a callback that runs with the `ActionResult`. Note that if you return a callback, the default behavior mentioned above is not triggered. To get it back, call `update`. ``svelte <form method="POST" use:enhance={({ formElement, formData, action, cancel, submitter }) => { // `formElement` is this `<form>` element // `formData` is its `FormData` object that's about to be submitted // `action` is the URL to which the form is posted // calling `cancel()` will prevent the submission // `submitter` is the `HTMLElement` that caused the form to be submitted return async ({ result, update }) => { // `result` is an `ActionResult` object // `update` is a function which triggers the default logic that would be triggered if this callback wasn't set }; }} >`` You can use these functions to show and hide loading UI, and so on. If you return a callback, you may need to reproduce part of the default `use:enhance` behaviour, but without invalidating all data on a successful response. You can do so with `applyAction`: ``svelte /// file: src/routes/login/+page.svelte <script> import { enhance,applyAction} from '$app/forms'; /** @type {import('./$types').PageProps} */ let { form } = $props(); </script> <form method="POST" use:enhance={({ formElement, formData, action, cancel }) => { return async ({ result }) => { // `result` is an `ActionResult` object if (result.type === 'redirect') { goto(result.location); } else { await applyAction(result); } }; }} >`` The behaviour of `applyAction(result)` depends on `result.type`: - `success`, `failure` — sets `page.status` to `result.status` and updates `form` and `page.form` to `result.data` (regardless of where you are submitting from, in contrast to `update` from `enhance`) - `redirect` — calls `goto(result.location, { invalidateAll: true })` - `error` — renders the nearest `+error` boundary with `result.error` In all cases, focus will be reset. ### Custom event listener We can also implement progressive enhancement ourselves, without `use:enhance`, with a normal event listener on the `<form>`: ``svelte <!file: src/routes/login/+page.svelte> <script> import { invalidateAll, goto } from '$app/navigation'; import { applyAction, deserialize } from '$app/forms'; /** @type {import('./$types').PageProps} */ let { form } = $props(); /** @param {SubmitEvent & { currentTarget: EventTarget & HTMLFormElement}} event */ async function handleSubmit(event) { event.preventDefault(); const data = new FormData(event.currentTarget); const response = await fetch(event.currentTarget.action, { method: 'POST', body: data }); /** @type {import('@sveltejs/kit').ActionResult} */ const result = deserialize(await response.text()); if (result.type === 'success') { // rerun all `load` functions, following the successful update await invalidateAll(); } applyAction(result); } </script> <form method="POST" onsubmit={handleSubmit}> </form>`` Note that you need to `deserialize` the response before processing it further using the corresponding method from `$app/forms`. `JSON.parse()` isn't enough because form actions - like `load` functions - also support returning `Date` or `BigInt` objects. If you have a `+server.js` alongside your `+page.server.js`, `fetch` requests will be routed there by default. To `POST` to an action in `+page.server.js` instead, use the custom `x-sveltekit-action` header: `js const response = await fetch(this.action, { method: 'POST', body: data, headers: { 'x-sveltekit-action': 'true' } });` ## Alternatives Form actions are the preferred way to send data to the server, since they can be progressively enhanced, but you can also use `+server.js` files to expose (for example) a JSON API. Here's how such an interaction could look like: `svelte <!file: src/routes/send-message/+page.svelte> <script> function rerun() { fetch('/api/ci', { method: 'POST' }); } </script> <button onclick={rerun}>Rerun CI</button>` `js // @errors: 2355 1360 2322 /// file: src/routes/api/ci/+server.js /** @type {import('./$types').RequestHandler} */ export function POST() { // do something }` ## GET vs POST As we've seen, to invoke a form action you must use `method="POST"`. Some forms don't need to `POST` data to the server — search inputs, for example. For these you can use `method="GET"` (or, equivalently, no `method` at all), and SvelteKit will treat them like `<a>` elements, using the client-side router instead of a full page navigation: `html <form action="/search"> <label> Search <input name="q"> </label> </form>` Submitting this form will navigate to `/search?q=...` and invoke your load function but will not invoke an action. As with `<a>` elements, you can set the `data-sveltekit-reload`, `data-sveltekit-replacestate`, `data-sveltekit-keepfocus` and `data-sveltekit-noscroll` attributes on the `<form>` to control the router's behaviour. ## Further reading - Tutorial: Forms

## docs/kit/20-core-concepts/40-page-options.md

--- title: Page options --- By default, SvelteKit will render (or prerender) any component first on the server and send it to the client as HTML. It will then render the component again in the browser to make it interactive in a process called **hydration**. For this reason, you need to ensure that components can run in both places. SvelteKit will then initialize a **router** that takes over subsequent navigations. You can control each of these on a page-by-page basis by exporting options from `+page.js` or `+page.server.js`, or for groups of pages using a shared `+layout.js` or `+layout.server.js`. To define an option for the whole app, export it from the root layout. Child layouts and pages override values set in parent layouts, so — for example — you can enable prerendering for your entire app then disable it for pages that need to be dynamically rendered. You can mix and match these options in different areas of your app. For example, you could prerender your marketing page for maximum speed, server-render your dynamic pages for SEO and accessibility and turn your admin section into an SPA by rendering it on the client only. This makes SvelteKit very versatile. ## prerender It's likely that at least some routes of your app can be represented as a simple HTML file generated at build time. These routes can be _prerendered_. `js /// file: +page.js/+page.server.js/+server.js export const prerender = true;` Alternatively, you can set `export const prerender = true` in your root `+layout.js` or `+layout.server.js` and prerender everything except pages that are explicitly marked as _not_ prerenderable: `js /// file: +page.js/+page.server.js/+server.js export const prerender = false;` Routes with `prerender = true` will be excluded from manifests used for dynamic SSR, making your server (or serverless/edge functions) smaller. In some cases you might want to prerender a route but also include it in the manifest (for example, with a route like `/blog/slug]` where you want to prerender your most recent/popular content but server-render the long tail) — for these cases, there's a third option, 'auto': `js /// file: +page.js/+page.server.js/+server.js export const prerender = 'auto';` The prerenderer will start at the root of your app and generate files for any prerenderable pages or `+server.js` routes it finds. Each page is scanned for `<a>` elements that point to other pages that are candidates for prerendering — because of this, you generally don't need to specify which pages should be accessed. If you _do_ need to specify which pages should be accessed by the prerenderer, you can do so with [`config.kit.prerender.entries`, or by exporting an `entries` function from your dynamic route. While prerendering, the value of `building` imported from `$app/environment` will be `true`. ### Prerendering server routes Unlike the other page options, `prerender` also applies to `+server.js` files. These files are _not_ affected by layouts, but will inherit default values from the pages that fetch data from them, if any. For example if a `+page.js` contains this `load` function... ```js /// file: +page.js export const prerender = true; /** @type {import('./$types').PageLoad} */ export async function load({ fetch }) { const res = await fetch('/my-server-route.json'); return await res.json(); }``` ...then `src/routes/my-server-route.json/+server.js` will be treated as prerenderable if it doesn't contain its own `export const prerender = false`. ### When not to prerender The basic rule is this: for a page to be prerenderable, any two users hitting it directly must get the same content from the server. Note that you can still prerender pages that load data based on the page's parameters, such as a `src/routes/blog/slug]/+page.svelte` route. Accessing [`url.searchParams`during prerendering is forbidden. If you need to use it, ensure you are only doing so in the browser (for example in`onMount`). Pages with actions cannot be prerendered, because a server must be able to handle the action `POST`requests. ### Route conflicts Because prerendering writes to the filesystem, it isn't possible to have two endpoints that would cause a directory and a file to have the same name. For example,`src/routes/foo/+server.js`and`src/routes/foo/bar/+server.js`would try to create`foo`and`foo/bar`, which is impossible. For that reason among others, it's recommended that you always include a file extension — `src/routes/foo.json/+server.js`and`src/routes/foo/bar.json/+server.js`would result in`foo.json`and`foo/bar.json`files living harmoniously side-by-side. For _pages_, we skirt around this problem by writing`foo/index.html`instead of`foo`. ### Troubleshooting If you encounter an error like 'The following routes were marked as prerenderable, but were not prerendered' it's because the route in question (or a parent layout, if it's a page) has `export const prerender = true`but the page wasn't reached by the prerendering crawler and thus wasn't prerendered. Since these routes cannot be dynamically server-rendered, this will cause errors when people try to access the route in question. There are a few ways to fix it: _Ensure that SvelteKit can find the route by following links from`config.kit.prerender.entries`or the`entries`page option. Add links to dynamic routes (i.e. pages with`parameters]`) to this option if they are not found through crawling the other entry points, else they are not prerendered because SvelteKit doesn't know what value the parameters should have. Pages not marked as prerenderable will be ignored and their links to other pages will not be crawled, even if some of them would be prerenderable._ Ensure that SvelteKit can find the route by discovering a link to it from one of your other prerendered pages that have server-side rendering enabled. _Change`export const prerender = true`to`export const prerender = 'auto'`. Routes with `'auto'`can be dynamically server rendered ## entries SvelteKit will discover pages to prerender automatically, by starting at _entry points_ and crawling them. By default, all your non-dynamic routes are considered entry points — for example, if you have these routes... ```bash / # non-dynamic /blog # non-dynamic /blog/[slug] # dynamic, because of`[slug]` ``` ...SvelteKit will prerender `/`and`/blog`, and in the process discover links like `<a href="/blog/hello-world">`which give it new pages to prerender. Most of the time, that's enough. In some situations, links to pages like`/blog/hello-world` might not exist (or might not exist on prerendered pages), in which case we need to tell SvelteKit about their existence. This can be done with [`config.kit.prerender.entries`, or by exporting an `entries`function from a`+page.js`, a `+page.server.js`or a`+server.js` belonging to a dynamic route: ```js /// file: src/routes/blog/slug]/+page.server.js /** @type {import('./$types').EntryGenerator} */ export function entries() { return [ { slug: 'hello-world' }, { slug: 'another-blog-post' } ]; } export const prerender = true;``` `entries`can be an`async`function, allowing you to (for example) retrieve a list of posts from a CMS or database, in the example above. ## ssr Normally, SvelteKit renders your page on the server first and sends that HTML to the client where it's [hydrated. If you set`ssr`to`false`, it renders an empty 'shell' page instead. This is useful if your page is unable to be rendered on the server (because you use browser-only globals like `document`for example), but in most situations it's not recommended (see appendix). ```js /// file: +page.js export const ssr = false; // If both`ssr`and`csr`are`false`, nothing will be rendered!``` If you add `export const ssr = false`to your root`+layout.js`, your entire app will only be rendered on the client — which essentially means you turn your app into an SPA. ## csr Ordinarily, SvelteKit hydrates your server-rendered HTML into an interactive client-side-rendered (CSR) page. Some pages don't require JavaScript at all — many blog posts and 'about' pages fall into this category. In these cases you can disable CSR: ```js /// file: +page.js export const csr = false; // If both `csr`and`ssr`are`false`, nothing will be rendered!``` Disabling CSR does not ship any JavaScript to the client. This means:_ The webpage should work with HTML and CSS only. _`<script>`tags inside all Svelte components are removed._`<form>`elements cannot be progressively enhanced. _Links are handled by the browser with a full-page navigation._ Hot Module Replacement (HMR) will be disabled. You can enable`csr`during development (for example to take advantage of HMR) like so: ```js /// file: +page.js import { dev } from '$app/environment'; export const csr = dev;``` ## trailingSlash By default, SvelteKit will remove trailing slashes from URLs — if you visit`/about/`, it will respond with a redirect to `/about`. You can change this behaviour with the `trailingSlash`option, which can be one of`'never'`(the default),`'always'`, or `'ignore'`. As with other page options, you can export this value from a `+layout.js`or a`+layout.server.js`and it will apply to all child pages. You can also export the configuration from`+server.js`files. ```js /// file: src/routes/+layout.js export const trailingSlash = 'always';``` This option also affects prerendering. If`trailingSlash`is`always`, a route like `/about`will result in an`about/index.html`file, otherwise it will create`about.html`, mirroring static webserver conventions. ## config With the concept of adapters, SvelteKit is able to run on a variety of platforms. Each of these might have specific configuration to further tweak the deployment — for example on Vercel you could choose to deploy some parts of your app on the edge and others on serverless environments. `config`is an object with key-value pairs at the top level. Beyond that, the concrete shape is dependent on the adapter you're using. Every adapter should provide a`Config` interface to import for type safety. Consult the documentation of your adapter for more information. ```js // @filename: ambient.d.ts declare module 'some-adapter' { export interface Config { runtime: string } } // @filename: index.js //cut /// file: src/routes/+page.js /** @type {import('some-adapter').Config} */ export const config = { runtime: 'edge' };``` `config`objects are merged at the top level (but _not_ deeper levels). This means you don't need to repeat all the values in a`+page.js`if you want to only override some of the values in the upper`+layout.js`. For example this layout configuration... ```js /// file: src/routes/+layout.js export const config = { runtime: 'edge', regions: 'all', foo: { bar: true } }``` ...is overridden by this page configuration... ```js /// file: src/routes/+page.js export const config = { regions: 'us1', 'us2'], foo: { baz: true } }``` ...which results in the config value `{ runtime: 'edge', regions: ['us1', 'us2'], foo: { baz: true } }` for that page. ## Further reading - [Tutorial: Page options

## docs/kit/20-core-concepts/50-state-management.md

--- title: State management --- If you're used to building client-only apps, state management in an app that spans server and client might seem intimidating. This section provides tips for avoiding some common gotchas. ## Avoid shared state on the server Browsers are _stateful_ — state is stored in memory as the user interacts with the application. Servers, on the other hand, are _stateless_ — the content of the response is determined entirely by the content of the request. Conceptually, that is. In reality, servers are often long-lived and shared by multiple users. For that reason it's important not to store data in shared variables. For example, consider this code: `js // @errors: 7034 7005 /// file: +page.server.js let user; /** @type {import('./$types').PageServerLoad} */ export function load() { return { user }; } /** @satisfies {import('./$types').Actions} */ export const actions = { default: async ({ request }) => { const data = await request.formData(); // NEVER DO THIS! user = { name: data.get('name'), embarrassingSecret: data.get('secret') }; } }` The `user` variable is shared by everyone who connects to this server. If Alice submitted an embarrassing secret, and Bob visited the page after her, Bob would know Alice's secret. In addition, when Alice returns to the site later in the day, the server may have restarted, losing her data. Instead, you should _authenticate_ the user using `cookies` and persist the data to a database. ## No side-effects in load For the same reason, your `load` functions should be _pure_ — no side-effects (except maybe the occasional `console.log(...)`). For example, you might be tempted to write to a store or global state inside a `load` function so that you can use the value in your components: `js /// file: +page.js // @filename: ambient.d.ts declare module '$lib/user' { export const user: { set: (value: any) => void }; } // @filename: index.js //cut import { user } from '$lib/user'; /** @type {import('./$types').PageLoad} */ export async function load({ fetch }) { const response = await fetch('/api/user'); // NEVER DO THIS! user.set(await response.json()); }` As with the previous example, this puts one user's information in a place that is shared by _all_ users. Instead, just return the data... `js /// file: +page.js /** @type {import('./$types').PageServerLoad} */ export async function load({ fetch }) { const response = await fetch('/api/user'); return { user: await response.json() }; }` ...and pass it around to the components that need it, or use `page.data`. If you're not using SSR, then there's no risk of accidentally exposing one user's data to another. But you should still avoid side-effects in your `load` functions — your application will be much easier to reason about without them. ## Using state and stores with context You might wonder how we're able to use `page.data` and other app state (or app stores) if we can't use global state. The answer is that app state and app stores on the server use Svelte's context API — the state (or store) is attached to the component tree with `setContext`, and when you subscribe you retrieve it with `getContext`. We can do the same thing with our own state: `svelte <!file: src/routes/+layout.svelte> <script> import { setContext } from 'svelte'; /** @type {import('./$types').LayoutProps} */ let { data } = $props(); // Pass a function referencing our state // to the context for child components to access setContext('user', () => data.user); </script>` `svelte <!file: src/routes/user/+page.svelte> <script> import { getContext } from 'svelte'; // Retrieve user store from context const user = getContext('user'); </script> <p>Welcome {user().name}</p>` > You also use stores from `svelte/store` for this, but when using Svelte 5 it is recommended to make use of universal reactivity instead. Updating the value of context-based state in deeper-level pages or components while the page is being rendered via SSR will not affect the value in the parent component because it has already been rendered by the time the state value is updated. In contrast, on the client (when CSR is enabled, which is the default) the value will be propagated and components, pages, and layouts higher in the hierarchy will react to the new value. Therefore, to avoid values 'flashing' during state updates during hydration, it is generally recommended to pass state down into components rather than up. If you're not using SSR (and can guarantee that you won't need to use SSR in future) then you can safely keep state in a shared module, without using the context API. ## Component and page state is preserved When you navigate around your application, SvelteKit reuses existing layout and page components. For example, if you have a route like this... `svelte <!file: src/routes/blog/slug]/+page.svelte> <script> /** @type {import('./$types').PageProps} */ let { data } = $props(); // THIS CODE IS BUGGY! const wordCount = data.content.split(' ').length; const estimatedReadingTime = wordCount / 250; </script> <header> <h1>{data.title}</h1> <p>Reading time: {Math.round(estimatedReadingTime)} minutes</p> </header> <div>{@html data.content}</div>` ...then navigating from `/blog/my-short-post` to `/blog/my-long-post` won't cause the layout, page and any other components within to be destroyed and recreated. Instead the `data` prop (and by extension `data.title` and `data.content`) will update (as it would with any other Svelte component) and, because the code isn't rerunning, lifecycle methods like `onMount` and `onDestroy` won't rerun and `estimatedReadingTime` won't be recalculated. Instead, we need to make the value [_reactive_: `svelte /// file: src/routes/blog/slug]/+page.svelte <script> /** @type {import('./$types').PageProps} */ let { data } = $props(); let wordCount = $derived(data.content.split(' ').length); let estimatedReadingTime = $derived(wordCount / 250); </script>` Reusing components like this means that things like sidebar scroll state are preserved, and you can easily animate between changing values. In the case that you do need to completely destroy and remount a component on navigation, you can use this pattern: `svelte <script> import { page } from '$app/state'; </script> {#key page.url.pathname} <BlogPost title={data.title} content={data.title} /> {/key}` ## Storing state in the URL If you have state that should survive a reload and/or affect SSR, such as filters or sorting rules on a table, URL search parameters (like `?sort=price&order=ascending`) are a good place to put them. You can put them in `<a href="...">` or `<form action="...">` attributes, or set them programmatically via `goto('?key=value')`. They can be accessed inside `load` functions via the `url` parameter, and inside components via `page.url.searchParams`. ## Storing ephemeral state in snapshots Some UI state, such as 'is the accordion open?', is disposable — if the user navigates away or refreshes the page, it doesn't matter if the state is lost. In some cases, you _do_ want the data to persist if the user navigates to a different page and comes back, but storing the state in the URL or in a database would be overkill. For this, SvelteKit provides [snapshots, which let you associate component state with a history entry.

## docs/kit/25-build-and-deploy/index.md

--- title: Build and deploy ---

## docs/kit/25-build-and-deploy/10-building-your-app.md

--- title: Building your app --- Building a SvelteKit app happens in two stages, which both happen when you run `vite build` (usually via `npm run build`). Firstly, Vite creates an optimized production build of your server code, your browser code, and your service worker (if you have one). Prerendering is executed at this stage, if appropriate. Secondly, an _adapter_ takes this production build and tunes it for your target environment — more on this on the following pages. ## During the build SvelteKit will load your `+page/layout(.server).js` files (and all files they import) for analysis during the build. Any code that should _not_ be executed at this stage must check that `building` from `$app/environment` is `false`: `js import { building } from '$app/environment'; import { setupMyDatabase } from '$lib/server/database'; if (!building) { setupMyDatabase(); } export function load() { // ... }` ## Preview your app After building, you can view your production build locally with `vite preview` (via `npm run preview`). Note that this will run the app in Node, and so is not a perfect reproduction of your deployed app — adapter-specific adjustments like the `platform` object do not apply to previews.

## docs/kit/25-build-and-deploy/20-adapters.md

--- title: Adapters --- Before you can deploy your SvelteKit app, you need to _adapt_ it for your deployment target. Adapters are small plugins that take the built app as input and generate output for deployment. Official adapters exist for a variety of platforms — these are documented on the following pages: - `@sveltejs/adapter-cloudflare` for Cloudflare Pages - `@sveltejs/adapter-cloudflare-workers` for Cloudflare Workers - `@sveltejs/adapter-netlify` for Netlify - `@sveltejs/adapter-node` for Node servers - `@sveltejs/adapter-static` for static site generation (SSG) - `@sveltejs/adapter-vercel` for Vercel Additional community-provided adapters exist for other platforms. ## Using adapters Your adapter is specified in `svelte.config.js`: `js /// file: svelte.config.js // @filename: ambient.d.ts declare module 'svelte-adapter-foo' { const adapter: (opts: any) => import('@sveltejs/kit').Adapter; export default adapter; } // @filename: index.js //cut import adapter from 'svelte-adapter-foo'; /** @type {import('@sveltejs/kit').Config} */ const config = { kit: { adapter: adapter({ // adapter options go here }) } }; export default config;` ## Platform-specific context Some adapters may have access to additional information about the request. For example, Cloudflare Workers can access an `env` object containing KV namespaces etc. This can be passed to the `RequestEvent` used in hooks and server routes as the `platform` property — consult each adapter's documentation to learn more.

## docs/kit/25-build-and-deploy/55-single-page-apps.md

--- title: Single-page apps --- You can turn any SvelteKit app, using any adapter, into a fully client-rendered single-page app (SPA) by disabling SSR at the root layout: `js /// file: src/routes/+layout.js export const ssr = false;` If you don't have any server-side logic (i.e. `+page.server.js`, `+layout.server.js` or `+server.js` files) you can use `adapter-static` to create your SPA by adding a _fallback page_. ## Usage Install with `npm i -D @sveltejs/adapter-static`, then add the adapter to your `svelte.config.js` with the following options: `js // @errors: 2307 /// file: svelte.config.js import adapter from '@sveltejs/adapter-static'; export default { kit: { adapter: adapter({ fallback: '200.html' // may differ from host to host }) } };` The `fallback` page is an HTML page created by SvelteKit from your page template (e.g. `app.html`) that loads your app and navigates to the correct route. For example Surge, a static web host, lets you add a `200.html` file that will handle any requests that don't correspond to static assets or prerendered pages. On some hosts it may be `index.html` or something else entirely — consult your platform's documentation. ## Apache To run an SPA on Apache, you should add a `static/.htaccess` file to route requests to the fallback page: `<IfModule mod_rewrite.c> RewriteEngine On RewriteBase / RewriteRule ^200\.html$ - [L] RewriteCond %{REQUEST_FILENAME} !-f RewriteCond %{REQUEST_FILENAME} !-d RewriteRule . /200.html [L] </IfModule>` ## Prerendering individual pages If you want certain pages to be prerendered, you can re-enable `ssr` alongside `prerender` for just those parts of your app: `js /// file: src/routes/my-prerendered-page/+page.js export const prerender = true; export const ssr = true;`

## docs/kit/30-advanced/index.md

--- title: Advanced ---

## docs/kit/30-advanced/10-advanced-routing.md

--- title: Advanced routing --- ## Rest parameters If the number of route segments is unknown, you can use rest syntax — for example you might implement GitHub's file viewer like so... `bash /org]/[repo]/tree/[branch]/[...file]` ...in which case a request for `/sveltejs/kit/tree/main/documentation/docs/04-advanced-routing.md` would result in the following parameters being available to the page: `js // @noErrors { org: 'sveltejs', repo: 'kit', branch: 'main', file: 'documentation/docs/04-advanced-routing.md' }` ### 404 pages Rest parameters also allow you to render custom 404s. Given these routes... `tree src/routes/ ├ marx-brothers/ │ ├ chico/ │ ├ harpo/ │ ├ groucho/ │ └ +error.svelte └ +error.svelte` ...the `marx-brothers/+error.svelte` file will _not_ be rendered if you visit `/marx-brothers/karl`, because no route was matched. If you want to render the nested error page, you should create a route that matches any `/marx-brothers/*` request, and return a 404 from it: `tree src/routes/ ├ marx-brothers/ | ├ [...path]/ │ ├ chico/ │ ├ harpo/ │ ├ groucho/ │ └ +error.svelte └ +error.svelte` `js /// file: src/routes/marx-brothers/[...path]/+page.js import { error } from '@sveltejs/kit'; /** @type {import('./$types').PageLoad} */ export function load(event) { error(404, 'Not Found'); }` ## Optional parameters A route like `[lang]/home` contains a parameter named `lang` which is required. Sometimes it's beneficial to make these parameters optional, so that in this example both `home` and `en/home` point to the same page. You can do that by wrapping the parameter in another bracket pair: `[[lang]]/home` Note that an optional route parameter cannot follow a rest parameter (`[...rest]/[[optional]]`), since parameters are matched 'greedily' and the optional parameter would always be unused. ## Matching A route like `src/routes/fruits/[page]` would match `/fruits/apple`, but it would also match `/fruits/rocketship`. We don't want that. You can ensure that route parameters are well-formed by adding a _matcher_ — which takes the parameter string (`"apple"` or `"rocketship"`) and returns `true` if it is valid — to your [`params` directory... `js /// file: src/params/fruit.js /** * @param {string} param * @return {param is ('apple' | 'orange')} * @satisfies {import('@sveltejs/kit').ParamMatcher} */ export function match(param) { return param === 'apple' || param === 'orange'; }` ...and augmenting your routes: `src/routes/fruits/page=fruit]` If the pathname doesn't match, SvelteKit will try to match other routes (using the sort order specified below), before eventually returning a 404. Each module in the `params` directory corresponds to a matcher, with the exception of `*.test.js` and `*.spec.js` files which may be used to unit test your matchers. ## Sorting It's possible for multiple routes to match a given path. For example each of these routes would match `/foo-abc`: `bash src/routes/[...catchall]/+page.svelte src/routes/[[a=x]]/+page.svelte src/routes/[b]/+page.svelte src/routes/foo-[c]/+page.svelte src/routes/foo-abc/+page.svelte` SvelteKit needs to know which route is being requested. To do so, it sorts them according to the following rules... - More specific routes are higher priority (e.g. a route with no parameters is more specific than a route with one dynamic parameter, and so on) - Parameters with [matchers (`name=type]`) are higher priority than those without (`[name]`) - `[[optional]]` and `[...rest]` parameters are ignored unless they are the final part of the route, in which case they are treated with lowest priority. In other words `x/[[y]]/z` is treated equivalently to `x/z` for the purposes of sorting - Ties are resolved alphabetically ...resulting in this ordering, meaning that `/foo-abc` will invoke `src/routes/foo-abc/+page.svelte`, and `/foo-def` will invoke `src/routes/foo-[c]/+page.svelte` rather than less specific routes: `bash src/routes/foo-abc/+page.svelte src/routes/foo-[c]/+page.svelte src/routes/[[a=x]]/+page.svelte src/routes/[b]/+page.svelte src/routes/[...catchall]/+page.svelte` ## Encoding Some characters can't be used on the filesystem — `/` on Linux and Mac, `\ / : * ? " < > |` on Windows. The `#` and `%` characters have special meaning in URLs, and the `[ ] ( )` characters have special meaning to SvelteKit, so these also can't be used directly as part of your route. To use these characters in your routes, you can use hexadecimal escape sequences, which have the format `[x+nn]` where `nn` is a hexadecimal character code: - `\` — `[x+5c]` - `/` — `[x+2f]` - `:` — `[x+3a]` - `*` — `[x+2a]` - `?` — `[x+3f]` - `"` — `[x+22]` - `<` — `[x+3c]` - `>` — `[x+3e]` - `|` — `[x+7c]` - `#` — `[x+23]` - `%` — `[x+25]` - `[` — `[x+5b]` - `]` — `[x+5d]` - `(` — `[x+28]` - `)` — `[x+29]` For example, to create a `/smileys/:-)` route, you would create a `src/routes/smileys/[x+3a]-[x+29]/+page.svelte` file. You can determine the hexadecimal code for a character with JavaScript: `js ':'.charCodeAt(0).toString(16); // '3a', hence '[x+3a]'` You can also use Unicode escape sequences. Generally you won't need to as you can use the unencoded character directly, but if — for some reason — you can't have a filename with an emoji in it, for example, then you can use the escaped characters. In other words, these are equivalent: `src/routes/[u+d83e][u+dd2a]/+page.svelte src/routes/🤪/+page.svelte` The format for a Unicode escape sequence is `[u+nnnn]` where `nnnn` is a valid value between `0000` and `10ffff`. (Unlike JavaScript string escaping, there's no need to use surrogate pairs to represent code points above `ffff`.) To learn more about Unicode encodings, consult [Programming with Unicode. ## Advanced layouts By default, the _layout hierarchy_ mirrors the _route hierarchy_. In some cases, that might not be what you want. ### (group) Perhaps you have some routes that are 'app' routes that should have one layout (e.g. `/dashboard` or `/item`), and others that are 'marketing' routes that should have a different layout (`/about` or `/testimonials`). We can group these routes with a directory whose name is wrapped in parentheses — unlike normal directories, `(app)` and `(marketing)` do not affect the URL pathname of the routes inside them: `tree src/routes/ │ (app)/ │ ├ dashboard/ │ ├ item/ │ └ +layout.svelte │ (marketing)/ │ ├ about/ │ ├ testimonials/ │ └ +layout.svelte ├ admin/ └ +layout.svelte` You can also put a `+page` directly inside a `(group)`, for example if `/` should be an `(app)` or a `(marketing)` page. ### Breaking out of layouts The root layout applies to every page of your app — if omitted, it defaults to `{@render children()}`. If you want some pages to have a different layout hierarchy than the rest, then you can put your entire app inside one or more groups _except_ the routes that should not inherit the common layouts. In the example above, the `/admin` route does not inherit either the `(app)` or `(marketing)` layouts. ### +page@ Pages can break out of the current layout hierarchy on a route-by-route basis. Suppose we have an `/item/id]/embed` route inside the `(app)` group from the previous example: `tree src/routes/ ├ (app)/ │ ├ item/ │ │ ├ [id]/ │ │ │ ├ embed/ │ │ │ │ └ +page.svelte │ │ │ └ +layout.svelte │ │ └ +layout.svelte │ └ +layout.svelte └ +layout.svelte` Ordinarily, this would inherit the root layout, the `(app)` layout, the `item` layout and the `[id]` layout. We can reset to one of those layouts by appending `@` followed by the segment name — or, for the root layout, the empty string. In this example, we can choose from the following options: - `+page@[id].svelte` - inherits from `src/routes/(app)/item/[id]/+layout.svelte` - `+page@item.svelte` - inherits from `src/routes/(app)/item/+layout.svelte` - `+page@(app).svelte` - inherits from `src/routes/(app)/+layout.svelte` - `+page@.svelte` - inherits from `src/routes/+layout.svelte` `tree src/routes/ ├ (app)/ │ ├ item/ │ │ ├ [id]/ │ │ │ ├ embed/ │ │ │ │ └ +page@(app).svelte │ │ │ └ +layout.svelte │ │ └ +layout.svelte │ └ +layout.svelte └ +layout.svelte` ### +layout@ Like pages, layouts can _themselves_ break out of their parent layout hierarchy, using the same technique. For example, a `+layout@.svelte` component would reset the hierarchy for all its child routes. `src/routes/ ├ (app)/ │ ├ item/ │ │ ├ [id]/ │ │ │ ├ embed/ │ │ │ │ └ +page.svelte // uses (app)/item/[id]/+layout.svelte │ │ │ ├ +layout.svelte // inherits from (app)/item/+layout@.svelte │ │ │ └ +page.svelte // uses (app)/item/+layout@.svelte │ │ └ +layout@.svelte // inherits from root layout, skipping (app)/+layout.svelte │ └ +layout.svelte └ +layout.svelte` ### When to use layout groups Not all use cases are suited for layout grouping, nor should you feel compelled to use them. It might be that your use case would result in complex `(group)` nesting, or that you don't want to introduce a `(group)` for a single outlier. It's perfectly fine to use other means such as composition (reusable `load` functions or Svelte components) or if-statements to achieve what you want. The following example shows a layout that rewinds to the root layout and reuses components and functions that other layouts can also use: `svelte <!file: src/routes/nested/route/+layout@.svelte> <script> import ReusableLayout from '$lib/ReusableLayout.svelte'; let { data, children } = $props(); </script> <ReusableLayout {data}> {@render children()} </ReusableLayout>` `js /// file: src/routes/nested/route/+layout.js // @filename: ambient.d.ts declare module "$lib/reusable-load-function" { export function reusableLoad(event: import('@sveltejs/kit').LoadEvent): Promise<Record<string, any>>; } // @filename: index.js //cut import { reusableLoad } from '$lib/reusable-load-function'; /** @type {import('./$types').PageLoad} */ export function load(event) { // Add additional logic here, if needed return reusableLoad(event); }` ## Further reading - [Tutorial: Advanced Routing

## docs/kit/30-advanced/20-hooks.md

--- title: Hooks --- 'Hooks' are app-wide functions you declare that SvelteKit will call in response to specific events, giving you fine-grained control over the framework's behaviour. There are three hooks files, all optional: - `src/hooks.server.js` — your app's server hooks - `src/hooks.client.js` — your app's client hooks - `src/hooks.js` — your app's hooks that run on both the client and server Code in these modules will run when the application starts up, making them useful for initializing database clients and so on. ## Server hooks The following hooks can be added to `src/hooks.server.js`: ### handle This function runs every time the SvelteKit server receives a request — whether that happens while the app is running, or during prerendering — and determines the response. It receives an `event` object representing the request and a function called `resolve`, which renders the route and generates a `Response`. This allows you to modify response headers or bodies, or bypass SvelteKit entirely (for implementing routes programmatically, for example). `js /// file: src/hooks.server.js /** @type {import('@sveltejs/kit').Handle} */ export async function handle({ event, resolve }) { if (event.url.pathname.startsWith('/custom')) { return new Response('custom response'); } const response = await resolve(event); return response; }` If unimplemented, defaults to `({ event, resolve }) => resolve(event)`. During prerendering, SvelteKit crawls your pages for links and renders each route it finds. Rendering the route invokes the `handle` function (and all other route dependencies, like `load`). If you need to exclude some code from running during this phase, check that the app is not `building` beforehand. ### locals To add custom data to the request, which is passed to handlers in `+server.js` and server `load` functions, populate the `event.locals` object, as shown below. `js /// file: src/hooks.server.js // @filename: ambient.d.ts type User = { name: string; } declare namespace App { interface Locals { user: User; } } const getUserInformation: (cookie: string | void) => Promise<User>; // @filename: index.js //cut /** @type {import('@sveltejs/kit').Handle} */ export async function handle({ event, resolve }) { event.locals.user = await getUserInformation(event.cookies.get('sessionid')); const response = await resolve(event); // Note that modifying response headers isn't always safe. // Response objects can have immutable headers // (e.g. Response.redirect() returned from an endpoint). // Modifying immutable headers throws a TypeError. // In that case, clone the response or avoid creating a // response object with immutable headers. response.headers.set('x-custom-header', 'potato'); return response; }` You can define multiple `handle` functions and execute them with the `sequence` helper function. `resolve` also supports a second, optional parameter that gives you more control over how the response will be rendered. That parameter is an object that can have the following fields: - `transformPageChunk(opts: { html: string, done: boolean }): MaybePromise<string | undefined>` — applies custom transforms to HTML. If `done` is true, it's the final chunk. Chunks are not guaranteed to be well-formed HTML (they could include an element's opening tag but not its closing tag, for example) but they will always be split at sensible boundaries such as `%sveltekit.head%` or layout/page components. - `filterSerializedResponseHeaders(name: string, value: string): boolean` — determines which headers should be included in serialized responses when a `load` function loads a resource with `fetch`. By default, none will be included. - `preload(input: { type: 'js' | 'css' | 'font' | 'asset', path: string }): boolean` — determines what files should be added to the `<head>` tag to preload it. The method is called with each file that was found at build time while constructing the code chunks — so if you for example have `import './styles.css` in your `+page.svelte`, `preload` will be called with the resolved path to that CSS file when visiting that page. Note that in dev mode `preload` is _not_ called, since it depends on analysis that happens at build time. Preloading can improve performance by downloading assets sooner, but it can also hurt if too much is downloaded unnecessarily. By default, `js` and `css` files will be preloaded. `asset` files are not preloaded at all currently, but we may add this later after evaluating feedback. `js /// file: src/hooks.server.js /** @type {import('@sveltejs/kit').Handle} */ export async function handle({ event, resolve }) { const response = await resolve(event, { transformPageChunk: ({ html }) => html.replace('old', 'new'), filterSerializedResponseHeaders: (name) => name.startsWith('x-'), preload: ({ type, path }) => type === 'js' || path.includes('/important/') }); return response; }` Note that `resolve(...)` will never throw an error, it will always return a `Promise<Response>` with the appropriate status code. If an error is thrown elsewhere during `handle`, it is treated as fatal, and SvelteKit will respond with a JSON representation of the error or a fallback error page — which can be customised via `src/error.html` — depending on the `Accept` header. You can read more about error handling here. ### handleFetch This function allows you to modify (or replace) a `fetch` request that happens inside a `load` or `action` function that runs on the server (or during pre-rendering). For example, your `load` function might make a request to a public URL like `https://api.yourapp.com` when the user performs a client-side navigation to the respective page, but during SSR it might make sense to hit the API directly (bypassing whatever proxies and load balancers sit between it and the public internet). `js /// file: src/hooks.server.js /** @type {import('@sveltejs/kit').HandleFetch} */ export async function handleFetch({ request, fetch }) { if (request.url.startsWith('https://api.yourapp.com/')) { // clone the original request, but change the URL request = new Request( request.url.replace('https://api.yourapp.com/', 'http://localhost:9999/'), request ); } return fetch(request); }` **Credentials** For same-origin requests, SvelteKit's `fetch` implementation will forward `cookie` and `authorization` headers unless the `credentials` option is set to `"omit"`. For cross-origin requests, `cookie` will be included if the request URL belongs to a subdomain of the app — for example if your app is on `my-domain.com`, and your API is on `api.my-domain.com`, cookies will be included in the request. If your app and your API are on sibling subdomains — `www.my-domain.com` and `api.my-domain.com` for example — then a cookie belonging to a common parent domain like `my-domain.com` will _not_ be included, because SvelteKit has no way to know which domain the cookie belongs to. In these cases you will need to manually include the cookie using `handleFetch`: `js /// file: src/hooks.server.js // @errors: 2345 /** @type {import('@sveltejs/kit').HandleFetch} */ export async function handleFetch({ event, request, fetch }) { if (request.url.startsWith('https://api.my-domain.com/')) { request.headers.set('cookie', event.request.headers.get('cookie')); } return fetch(request); }` ## Shared hooks The following can be added to `src/hooks.server.js` _and_ `src/hooks.client.js`: ### handleError If an unexpected error is thrown during loading or rendering, this function will be called with the `error`, `event`, `status` code and `message`. This allows for two things: - you can log the error - you can generate a custom representation of the error that is safe to show to users, omitting sensitive details like messages and stack traces. The returned value, which defaults to `{ message }`, becomes the value of `$page.error`. For errors thrown from your code (or library code called by your code) the status will be 500 and the message will be "Internal Error". While `error.message` may contain sensitive information that should not be exposed to users, `message` is safe (albeit meaningless to the average user). To add more information to the `$page.error` object in a type-safe way, you can customize the expected shape by declaring an `App.Error` interface (which must include `message: string`, to guarantee sensible fallback behavior). This allows you to — for example — append a tracking ID for users to quote in correspondence with your technical support staff: `ts /// file: src/app.d.ts declare global { namespace App { interface Error { message: string; errorId: string; } } } export {};` `js /// file: src/hooks.server.js // @errors: 2322 2353 // @filename: ambient.d.ts declare module '@sentry/sveltekit' { export const init: (opts: any) => void; export const captureException: (error: any, opts: any) => void; } // @filename: index.js //cut import * as Sentry from '@sentry/sveltekit'; Sentry.init({/*...*/}) /** @type {import('@sveltejs/kit').HandleServerError} */ export async function handleError({ error, event, status, message }) { const errorId = crypto.randomUUID(); // example integration with https://sentry.io/ Sentry.captureException(error, { extra: { event, errorId, status } }); return { message: 'Whoops!', errorId }; }` `js /// file: src/hooks.client.js // @errors: 2322 2353 // @filename: ambient.d.ts declare module '@sentry/sveltekit' { export const init: (opts: any) => void; export const captureException: (error: any, opts: any) => void; } // @filename: index.js //cut import * as Sentry from '@sentry/sveltekit'; Sentry.init({/*...*/}) /** @type {import('@sveltejs/kit').HandleClientError} */ export async function handleError({ error, event, status, message }) { const errorId = crypto.randomUUID(); // example integration with https://sentry.io/ Sentry.captureException(error, { extra: { event, errorId, status } }); return { message: 'Whoops!', errorId }; }` This function is not called for _expected_ errors (those thrown with the `error` function imported from `@sveltejs/kit`). During development, if an error occurs because of a syntax error in your Svelte code, the passed in error has a `frame` property appended highlighting the location of the error. ### init This function runs once, when the server is created or the app starts in the browser, and is a useful place to do asynchronous work such as initializing a database connection. `js /// file: src/hooks.server.js import * as db from '$lib/server/database'; /** @type {import('@sveltejs/kit').ServerInit} */ export async function init() { await db.connect(); }` > In the browser, asynchronous work in `init` will delay hydration, so be mindful of what you put in there. ## Universal hooks The following can be added to `src/hooks.js`. Universal hooks run on both server and client (not to be confused with shared hooks, which are environment-specific). ### reroute This function runs before `handle` and allows you to change how URLs are translated into routes. The returned pathname (which defaults to `url.pathname`) is used to select the route and its parameters. For example, you might have a `src/routes/[lang]]/about/+page.svelte` page, which should be accessible as `/en/about` or `/de/ueber-uns` or `/fr/a-propos`. You could implement this with `reroute`: `js /// file: src/hooks.js // @errors: 2345 // @errors: 2304 /** @type {Record<string, string>} */ const translated = { '/en/about': '/en/about', '/de/ueber-uns': '/de/about', '/fr/a-propos': '/fr/about', }; /** @type {import('@sveltejs/kit').Reroute} */ export function reroute({ url }) { if (url.pathname in translated) { return translated[url.pathname]; } }` The `lang` parameter will be correctly derived from the returned pathname. Using `reroute` will _not_ change the contents of the browser's address bar, or the value of `event.url`. Since version 2.18, the `reroute` hook can be asynchronous, allowing it to (for example) fetch data from your backend to decide where to reroute to. Use this carefully and make sure it's fast, as it will delay navigation otherwise. If you need to fetch data, use the `fetch` provided as an argument. It has the [same benefits as the `fetch` provided to `load` functions, with the caveat that `params` and `id` are unavailable to `handleFetch` because the route is not yet known. ``js /// file: src/hooks.js // @errors: 2345` // @errors: 2304 /** @type {import('@sveltejs/kit').Reroute} */ export function reroute({ url, fetch }) { // Ask a special endpoint within your app about the destination if (url.pathname === '/api/reroute') return; const api = new URL('/api/reroute', url); api.searchParams.set('pathname', url.pathname); const result = await fetch(api).then(r => r.json()); return result.pathname; }`` ### transport This is a collection of _transporters_, which allow you to pass custom types — returned from `load` and form actions — across the server/client boundary. Each transporter contains an `encode` function, which encodes values on the server (or returns `false` for anything that isn't an instance of the type) and a corresponding `decode` function: `js /// file: src/hooks.js import { Vector } from '$lib/math'; /** @type {import('@sveltejs/kit').Transport} */ export const transport = { Vector: { encode: (value) => value instanceof Vector && value.x, value.y], decode: ([x, y]) => new Vector(x, y) } };` ## Further reading - [Tutorial: Hooks

## docs/kit/30-advanced/25-errors.md

--- title: Errors --- Errors are an inevitable fact of software development. SvelteKit handles errors differently depending on where they occur, what kind of errors they are, and the nature of the incoming request. ## Error objects SvelteKit distinguishes between expected and unexpected errors, both of which are represented as simple `{ message: string }` objects by default. You can add additional properties, like a `code` or a tracking `id`, as shown in the examples below. (When using TypeScript this requires you to redefine the `Error` type as described in type safety). ## Expected errors An _expected_ error is one created with the `error` helper imported from `@sveltejs/kit`: `js /// file: src/routes/blog/slug]/+page.server.js // @filename: ambient.d.ts declare module '$lib/server/database' { export function getPost(slug: string): Promise<{ title: string, content: string } | undefined> } // @filename: index.js //cut import { error } from '@sveltejs/kit'; import * as db from '$lib/server/database'; /** @type {import('./$types').PageServerLoad} */ export async function load({ params }) { const post = await db.getPost(params.slug); if (!post) { error(404, { message: 'Not found' }); } return { post }; }` This throws an exception that SvelteKit catches, causing it to set the response status code to 404 and render an [`+error.svelte` component, where `page.error` is the object provided as the second argument to `error(...)`. `svelte <!file: src/routes/+error.svelte> <script> import { page } from '$app/state'; </script> <h1>{page.error.message}</h1>` > `$app/state` was added in SvelteKit 2.12. If you're using an earlier version or are using Svelte 4, use `$app/stores` instead. You can add extra properties to the error object if needed... `js // @filename: ambient.d.ts declare global { namespace App { interface Error { message: string; code: string; } } } export {} // @filename: index.js import { error } from '@sveltejs/kit'; //cut error(404, { message: 'Not found', code: 'NOT_FOUND' });` ...otherwise, for convenience, you can pass a string as the second argument: `js import { error } from '@sveltejs/kit'; //cut error(404, { message: 'Not found' }); error(404, 'Not found');` ## Unexpected errors An _unexpected_ error is any other exception that occurs while handling a request. Since these can contain sensitive information, unexpected error messages and stack traces are not exposed to users. By default, unexpected errors are printed to the console (or, in production, your server logs), while the error that is exposed to the user has a generic shape: `json { "message": "Internal Error" }` Unexpected errors will go through the `handleError` hook, where you can add your own error handling — for example, sending errors to a reporting service, or returning a custom error object which becomes `$page.error`. ## Responses If an error occurs inside `handle` or inside a `+server.js` request handler, SvelteKit will respond with either a fallback error page or a JSON representation of the error object, depending on the request's `Accept` headers. You can customise the fallback error page by adding a `src/error.html` file: `html <!DOCTYPE html> <html lang="en"> <head> <meta charset="utf-8" /> <title>%sveltekit.error.message%</title> </head> <body> <h1>My custom error page</h1> <p>Status: %sveltekit.status%</p> <p>Message: %sveltekit.error.message%</p> </body> </html>` SvelteKit will replace `%sveltekit.status%` and `%sveltekit.error.message%` with their corresponding values. If the error instead occurs inside a `load` function while rendering a page, SvelteKit will render the `+error.svelte` component nearest to where the error occurred. If the error occurs inside a `load` function in `+layout(.server).js`, the closest error boundary in the tree is an `+error.svelte` file _above_ that layout (not next to it). The exception is when the error occurs inside the root `+layout.js` or `+layout.server.js`, since the root layout would ordinarily _contain_ the `+error.svelte` component. In this case, SvelteKit uses the fallback error page. ## Type safety If you're using TypeScript and need to customize the shape of errors, you can do so by declaring an `App.Error` interface in your app (by convention, in `src/app.d.ts`, though it can live anywhere that TypeScript can 'see'): `ts /// file: src/app.d.ts declare global { namespace App { interface Error { code: string; id: string; } } } export {};` This interface always includes a `message: string` property. ## Further reading - Tutorial: Errors and redirects - Tutorial: Hooks

## docs/kit/30-advanced/30-link-options.md

--- title: Link options --- In SvelteKit, `<a>` elements (rather than framework-specific `<Link>` components) are used to navigate between the routes of your app. If the user clicks on a link whose `href` is 'owned' by the app (as opposed to, say, a link to an external site) then SvelteKit will navigate to the new page by importing its code and then calling any `load` functions it needs to fetch data. You can customise the behaviour of links with `data-sveltekit-*` attributes. These can be applied to the `<a>` itself, or to a parent element. These options also apply to `<form>` elements with `method="GET"`. ## data-sveltekit-preload-data Before the browser registers that the user has clicked on a link, we can detect that they've hovered the mouse over it (on desktop) or that a `touchstart` or `mousedown` event was triggered. In both cases, we can make an educated guess that a `click` event is coming. SvelteKit can use this information to get a head start on importing the code and fetching the page's data, which can give us an extra couple of hundred milliseconds — the difference between a user interface that feels laggy and one that feels snappy. We can control this behaviour with the `data-sveltekit-preload-data` attribute, which can have one of two values: - `"hover"` means that preloading will start if the mouse comes to a rest over a link. On mobile, preloading begins on `touchstart` - `"tap"` means that preloading will start as soon as a `touchstart` or `mousedown` event is registered The default project template has a `data-sveltekit-preload-data="hover"` attribute applied to the `<body>` element in `src/app.html`, meaning that every link is preloaded on hover by default: `html <body data-sveltekit-preload-data="hover"> <div style="display: contents">%sveltekit.body%</div> </body>` Sometimes, calling `load` when the user hovers over a link might be undesirable, either because it's likely to result in false positives (a click needn't follow a hover) or because data is updating very quickly and a delay could mean staleness. In these cases, you can specify the `"tap"` value, which causes SvelteKit to call `load` only when the user taps or clicks on a link: `html <a data-sveltekit-preload-data="tap" href="/stonks"> Get current stonk values </a>` Data will never be preloaded if the user has chosen reduced data usage, meaning `navigator.connection.saveData` is `true`. ## data-sveltekit-preload-code Even in cases where you don't want to preload _data_ for a link, it can be beneficial to preload the _code_. The `data-sveltekit-preload-code` attribute works similarly to `data-sveltekit-preload-data`, except that it can take one of four values, in decreasing 'eagerness': - `"eager"` means that links will be preloaded straight away - `"viewport"` means that links will be preloaded once they enter the viewport - `"hover"` - as above, except that only code is preloaded - `"tap"` - as above, except that only code is preloaded Note that `viewport` and `eager` only apply to links that are present in the DOM immediately following navigation — if a link is added later (in an `{#if ...}` block, for example) it will not be preloaded until triggered by `hover` or `tap`. This is to avoid performance pitfalls resulting from aggressively observing the DOM for changes. As with `data-sveltekit-preload-data`, this attribute will be ignored if the user has chosen reduced data usage. ## data-sveltekit-reload Occasionally, we need to tell SvelteKit not to handle a link, but allow the browser to handle it. Adding a `data-sveltekit-reload` attribute to a link... `html <a data-sveltekit-reload href="/path">Path</a>` ...will cause a full-page navigation when the link is clicked. Links with a `rel="external"` attribute will receive the same treatment. In addition, they will be ignored during prerendering. ## data-sveltekit-replacestate Sometimes you don't want navigation to create a new entry in the browser's session history. Adding a `data-sveltekit-replacestate` attribute to a link... `html <a data-sveltekit-replacestate href="/path">Path</a>` ...will replace the current `history` entry rather than creating a new one with `pushState` when the link is clicked. ## data-sveltekit-keepfocus Sometimes you don't want focus to be reset after navigation. For example, maybe you have a search form that submits as the user is typing, and you want to keep focus on the text input. Adding a `data-sveltekit-keepfocus` attribute to it... `html <form data-sveltekit-keepfocus> <input type="text" name="query"> </form>` ...will cause the currently focused element to retain focus after navigation. In general, avoid using this attribute on links, since the focused element would be the `<a>` tag (and not a previously focused element) and screen reader and other assistive technology users often expect focus to be moved after a navigation. You should also only use this attribute on elements that still exist after navigation. If the element no longer exists, the user's focus will be lost, making for a confusing experience for assistive technology users. ## data-sveltekit-noscroll When navigating to internal links, SvelteKit mirrors the browser's default navigation behaviour: it will change the scroll position to 0,0 so that the user is at the very top left of the page (unless the link includes a `#hash`, in which case it will scroll to the element with a matching ID). In certain cases, you may wish to disable this behaviour. Adding a `data-sveltekit-noscroll` attribute to a link... `html <a href="path" data-sveltekit-noscroll>Path</a>` ...will prevent scrolling after the link is clicked. ## Disabling options To disable any of these options inside an element where they have been enabled, use the `"false"` value: `html <div data-sveltekit-preload-data> <a href="/a">a</a> <a href="/b">b</a> <a href="/c">c</a> <div data-sveltekit-preload-data="false"> <a href="/d">d</a> <a href="/e">e</a> <a href="/f">f</a> </div> </div>` To apply an attribute to an element conditionally, do this: `svelte <div data-sveltekit-preload-data={condition ? 'hover' : false}>`

## docs/kit/30-advanced/40-service-workers.md

--- title: Service workers --- Service workers act as proxy servers that handle network requests inside your app. This makes it possible to make your app work offline, but even if you don't need offline support (or can't realistically implement it because of the type of app you're building), it's often worth using service workers to speed up navigation by precaching your built JS and CSS. In SvelteKit, if you have a `src/service-worker.js` file (or `src/service-worker/index.js`) it will be bundled and automatically registered. You can change the location of your service worker if you need to. You can disable automatic registration if you need to register the service worker with your own logic or use another solution. The default registration looks something like this: `js if ('serviceWorker' in navigator) { addEventListener('load', function () { navigator.serviceWorker.register('./path/to/service-worker.js'); }); }` ## Inside the service worker Inside the service worker you have access to the `$service-worker` module, which provides you with the paths to all static assets, build files and prerendered pages. You're also provided with an app version string, which you can use for creating a unique cache name, and the deployment's `base` path. If your Vite config specifies `define` (used for global variable replacements), this will be applied to service workers as well as your server/client builds. The following example caches the built app and any files in `static` eagerly, and caches all other requests as they happen. This would make each page work offline once visited. ``js // @errors: 2339 /// <reference types="@sveltejs/kit" /> import { build, files, version } from '$service-worker'; // Create a unique cache name for this deployment const CACHE = `cache-${version}`; const ASSETS =  ...build, // the app itself ...files // everything in `static` ]; self.addEventListener('install', (event) => { // Create a new cache and add all files to it async function addFilesToCache() { const cache = await caches.open(CACHE); await cache.addAll(ASSETS); } event.waitUntil(addFilesToCache()); }); self.addEventListener('activate', (event) => { // Remove previous cached data from disk async function deleteOldCaches() { for (const key of await caches.keys()) { if (key !== CACHE) await caches.delete(key); } } event.waitUntil(deleteOldCaches()); }); self.addEventListener('fetch', (event) => { // ignore POST requests etc if (event.request.method !== 'GET') return; async function respond() { const url = new URL(event.request.url); const cache = await caches.open(CACHE); // `build`/`files` can always be served from the cache if (ASSETS.includes(url.pathname)) { const response = await cache.match(url.pathname); if (response) { return response; } } // for everything else, try the network first, but // fall back to the cache if we're offline try { const response = await fetch(event.request); // if we're offline, fetch can return a value that is not a Response // instead of throwing - and we can't pass this non-Response to respondWith if (!(response instanceof Response)) { throw new Error('invalid response from fetch'); } if (response.status === 200) { cache.put(event.request, response.clone()); } return response; } catch (err) { const response = await cache.match(event.request); if (response) { return response; } // if there's no cache, then just error out // as there is nothing we can do to respond to this request throw err; } } event.respondWith(respond()); });`` ## During development The service worker is bundled for production, but not during development. For that reason, only browsers that support [modules in service workers will be able to use them at dev time. If you are manually registering your service worker, you will need to pass the `{ type: 'module' }` option in development: `js import { dev } from '$app/environment'; navigator.serviceWorker.register('/service-worker.js', { type: dev ? 'module' : 'classic' });` ## Type safety Setting up proper types for service workers requires some manual setup. Inside your `service-worker.js`, add the following to the top of your file: `original-js /// <reference types="@sveltejs/kit" /> /// <reference no-default-lib="true"/> /// <reference lib="esnext" /> /// <reference lib="webworker" /> const sw = /** @type {ServiceWorkerGlobalScope} */ (/** @type {unknown} */ (self));` `generated-ts /// <reference types="@sveltejs/kit" /> /// <reference no-default-lib="true"/> /// <reference lib="esnext" /> /// <reference lib="webworker" /> const sw = self as unknown as ServiceWorkerGlobalScope;` This disables access to DOM typings like `HTMLElement` which are not available inside a service worker and instantiates the correct globals. The reassignment of `self` to `sw` allows you to type cast it in the process (there are a couple of ways to do this, but this is the easiest that requires no additional files). Use `sw` instead of `self` in the rest of the file. The reference to the SvelteKit types ensures that the `$service-worker` import has proper type definitions. If you import `$env/static/public` you either have to `// @ts-ignore` the import or add `/// <reference types="../.svelte-kit/ambient.d.ts" />` to the reference types. ## Other solutions SvelteKit's service worker implementation is designed to be easy to work with and is probably a good solution for most users. However, outside of SvelteKit, many PWA applications leverage the Workbox library. If you're used to using Workbox you may prefer Vite PWA plugin. ## References For more general information on service workers, we recommend the MDN web docs.

## docs/kit/30-advanced/50-server-only-modules.md

--- title: Server-only modules --- Like a good friend, SvelteKit keeps your secrets. When writing your backend and frontend in the same repository, it can be easy to accidentally import sensitive data into your front-end code (environment variables containing API keys, for example). SvelteKit provides a way to prevent this entirely: server-only modules. ## Private environment variables The `$env/static/private` and `$env/dynamic/private` modules can only be imported into modules that only run on the server, such as `hooks.server.js` or `+page.server.js`. ## Server-only utilities The `$app/server` module, which contains a `read` function for reading assets from the filesystem, can likewise only be imported by code that runs on the server. ## Your modules You can make your own modules server-only in two ways: - adding `.server` to the filename, e.g. `secrets.server.js` - placing them in `$lib/server`, e.g. `$lib/server/secrets.js` ## How it works Any time you have public-facing code that imports server-only code (whether directly or indirectly)... `js // @errors: 7005 /// file: $lib/server/secrets.js export const atlantisCoordinates = /* redacted */];` `js // @errors: 2307 7006 7005 /// file: src/routes/utils.js export { atlantisCoordinates } from '$lib/server/secrets.js'; export const add = (a, b) => a + b;` `html /// file: src/routes/+page.svelte <script> import { add } from './utils.js'; </script>` ...SvelteKit will error: `Cannot import $lib/server/secrets.js into public-facing code: src/routes/+page.svelte src/routes/utils.js $lib/server/secrets.js` Even though the public-facing code — `src/routes/+page.svelte` — only uses the `add` export and not the secret `atlantisCoordinates` export, the secret code could end up in JavaScript that the browser downloads, and so the import chain is considered unsafe. This feature also works with dynamic imports, even interpolated ones like ``await import(`./${foo}.js`)``, with one small caveat: during development, if there are two or more dynamic imports between the public-facing code and the server-only module, the illegal import will not be detected the first time the code is loaded. ## Further reading - [Tutorial: Environment variables

## docs/kit/30-advanced/65-snapshots.md

--- title: Snapshots --- Ephemeral DOM state — like scroll positions on sidebars, the content of `<input>` elements and so on — is discarded when you navigate from one page to another. For example, if the user fills out a form but navigates away and then back before submitting, or if the user refreshes the page, the values they filled in will be lost. In cases where it's valuable to preserve that input, you can take a _snapshot_ of DOM state, which can then be restored if the user navigates back. To do this, export a `snapshot` object with `capture` and `restore` methods from a `+page.svelte` or `+layout.svelte`: `svelte <!file: +page.svelte> <script> let comment = $state(''); /** @type {import('./$types').Snapshot<string>} */ export const snapshot = { capture: () => comment, restore: (value) => comment = value }; </script> <form method="POST"> <label for="comment">Comment</label> <textarea id="comment" bind:value={comment} /> <button>Post comment</button> </form>` When you navigate away from this page, the `capture` function is called immediately before the page updates, and the returned value is associated with the current entry in the browser's history stack. If you navigate back, the `restore` function is called with the stored value as soon as the page is updated. The data must be serializable as JSON so that it can be persisted to `sessionStorage`. This allows the state to be restored when the page is reloaded, or when the user navigates back from a different site.

## docs/kit/30-advanced/67-shallow-routing.md

--- title: Shallow routing --- As you navigate around a SvelteKit app, you create _history entries_. Clicking the back and forward buttons traverses through this list of entries, re-running any `load` functions and replacing page components as necessary. Sometimes, it's useful to create history entries _without_ navigating. For example, you might want to show a modal dialog that the user can dismiss by navigating back. This is particularly valuable on mobile devices, where swipe gestures are often more natural than interacting directly with the UI. In these cases, a modal that is _not_ associated with a history entry can be a source of frustration, as a user may swipe backwards in an attempt to dismiss it and find themselves on the wrong page. SvelteKit makes this possible with the `pushState` and `replaceState` functions, which allow you to associate state with a history entry without navigating. For example, to implement a history-driven modal: `svelte <!file: +page.svelte> <script> import { pushState } from '$app/navigation'; import { page } from '$app/state'; import Modal from './Modal.svelte'; function showModal() { pushState('', { showModal: true }); } </script> {#if page.state.showModal} <Modal close={() => history.back()} /> {/if}` The modal can be dismissed by navigating back (unsetting `page.state.showModal`) or by interacting with it in a way that causes the `close` callback to run, which will navigate back programmatically. ## API The first argument to `pushState` is the URL, relative to the current URL. To stay on the current URL, use `''`. The second argument is the new page state, which can be accessed via the page object as `page.state`. You can make page state type-safe by declaring an `App.PageState` interface (usually in `src/app.d.ts`). To set page state without creating a new history entry, use `replaceState` instead of `pushState`. > `page.state` from `$app/state` was added in SvelteKit 2.12. If you're using an earlier version or are using Svelte 4, use `$page.state` from `$app/stores` instead. ## Loading data for a route When shallow routing, you may want to render another `+page.svelte` inside the current page. For example, clicking on a photo thumbnail could pop up the detail view without navigating to the photo page. For this to work, you need to load the data that the `+page.svelte` expects. A convenient way to do this is to use `preloadData` inside the `click` handler of an `<a>` element. If the element (or a parent) uses `data-sveltekit-preload-data`, the data will have already been requested, and `preloadData` will reuse that request. ``svelte <!file: src/routes/photos/+page.svelte> <script> import { preloadData, pushState, goto } from '$app/navigation'; import { page } from '$app/state'; import Modal from './Modal.svelte'; import PhotoPage from './[id]/+page.svelte'; let { data } = $props(); </script> {#each data.thumbnails as thumbnail} <a href="/photos/{thumbnail.id}" onclick={async (e) => { if (innerWidth < 640 // bail if the screen is too small || e.shiftKey // or the link is opened in a new window || e.metaKey || e.ctrlKey // or a new tab (mac: metaKey, win/linux: ctrlKey) // should also consider clicking with a mouse scroll wheel ) return; // prevent navigation e.preventDefault(); const { href } = e.currentTarget; // run `load` functions (or rather, get the result of the `load` functions // that are already running because of `data-sveltekit-preload-data`) const result = await preloadData(href); if (result.type === 'loaded' && result.status === 200) { pushState(href, { selected: result.data }); } else { // something bad happened! try navigating goto(href); } }} > <img alt={thumbnail.alt} src={thumbnail.src} /> </a> {/each} {#if page.state.selected} <Modal onclose={() => history.back()}> <PhotoPage data={page.state.selected} /> </Modal> {/if}`` ## Caveats During server-side rendering, `page.state` is always an empty object. The same is true for the first page the user lands on — if the user reloads the page (or returns from another document), state will _not_ be applied until they navigate. Shallow routing is a feature that requires JavaScript to work. Be mindful when using it and try to think of sensible fallback behavior in case JavaScript isn't available.

## docs/kit/40-best-practices/index.md

--- title: Best practices ---

## docs/kit/40-best-practices/03-auth.md

--- title: Auth --- Auth refers to authentication and authorization, which are common needs when building a web application. Authentication means verifying that the user is who they say they are based on their provided credentials. Authorization means determining which actions they are allowed to take. ## Sessions vs tokens After the user has provided their credentials such as a username and password, we want to allow them to use the application without needing to provide their credentials again for future requests. Users are commonly authenticated on subsequent requests with either a session identifier or signed token such as a JSON Web Token (JWT). Session IDs are most commonly stored in a database. They can be immediately revoked, but require a database query to be made on each request. In contrast, JWT generally are not checked against a datastore, which means they cannot be immediately revoked. The advantage of this method is improved latency and reduced load on your datastore. ## Integration points Auth cookies can be checked inside server hooks. If a user is found matching the provided credentials, the user information can be stored in `locals`. ## Guides Lucia is a good reference for session-based web app auth. It contains example code snippets and projects for implementing session-based auth within SvelteKit and other JS projects. You can add code which follows the Lucia guide to your project with `npx sv create` when creating a new project or `npx sv add lucia` for an existing project. An auth system is tightly coupled to a web framework because most of the code lies in validating user input, handling errors, and directing users to the appropriate next page. As a result, many of the generic JS auth libraries include one or more web frameworks within them. For this reason, many users will find it preferrable to follow a SvelteKit-specific guide such as the examples found in Lucia rather than having multiple web frameworks inside their project.

## docs/kit/40-best-practices/06-icons.md

--- title: Icons --- ## CSS A great way to use icons is to define them purely via CSS. Iconify offers support for many popular icon sets that can be included via CSS. This method can also be used with popular CSS frameworks by leveraging the Iconify Tailwind CSS plugin or UnoCSS plugin. As opposed to libraries based on Svelte components, it doesn't require each icon to be imported into your `.svelte` file. ## Svelte There are many icon libraries for Svelte. When choosing an icon library, it is recommended to avoid those that provide a `.svelte` file per icon as these libraries can have thousands of `.svelte` files which really slow down Vite's dependency optimization. This can become especially pathological if the icons are imported both via an umbrella import and subpath import as described in the `vite-plugin-svelte` FAQ.

## docs/kit/40-best-practices/07-images.md

--- title: Images --- Images can have a big impact on your app's performance. For best results, you should optimize them by doing the following: - generate optimal formats like `.avif` and `.webp` - create different sizes for different screens - ensure that assets can be cached effectively Doing this manually is tedious. There are a variety of techniques you can use, depending on your needs and preferences. ## Vite's built-in handling Vite will automatically process imported assets for improved performance. This includes assets referenced via the CSS `url()` function. Hashes will be added to the filenames so that they can be cached, and assets smaller than `assetsInlineLimit` will be inlined. Vite's asset handling is most often used for images, but is also useful for video, audio, etc. `svelte <script> import logo from '$lib/assets/logo.png'; </script> <img alt="The project logo" src={logo} />` ## @sveltejs/enhanced-img `@sveltejs/enhanced-img` is a plugin offered on top of Vite's built-in asset handling. It provides plug and play image processing that serves smaller file formats like `avif` or `webp`, automatically sets the intrinsic `width` and `height` of the image to avoid layout shift, creates images of multiple sizes for various devices, and strips EXIF data for privacy. It will work in any Vite-based project including, but not limited to, SvelteKit projects. > > **WARNING**: The `@sveltejs/enhanced-img` package is experimental. It uses pre-1.0 versioning and may introduce breaking changes with every minor version release. ### Setup Install: `bash npm install --save-dev @sveltejs/enhanced-img` Adjust `vite.config.js`: `js import { sveltekit } from '@sveltejs/kit/vite'; import { enhancedImages } from '@sveltejs/enhanced-img'; import { defineConfig } from 'vite'; export default defineConfig({ plugins:  enhancedImages(), sveltekit() ] });` Building will take longer on the first build due to the computational expense of transforming images. However, the build output will be cached in `./node_modules/.cache/imagetools` so that subsequent builds will be fast. ### Basic usage Use in your `.svelte` components by using `<enhanced:img>` rather than `<img>` and referencing the image file with a [Vite asset import path: `svelte <enhanced:img src="./path/to/your/image.jpg" alt="An alt text" />` At build time, your `<enhanced:img>` tag will be replaced with an `<img>` wrapped by a `<picture>` providing multiple image types and sizes. It's only possible to downscale images without losing quality, which means that you should provide the highest resolution image that you need — smaller versions will be generated for the various device types that may request an image. You should provide your image at 2x resolution for HiDPI displays (a.k.a. retina displays). `<enhanced:img>` will automatically take care of serving smaller versions to smaller devices. If you wish to add styles to your `<enhanced:img>`, you should add a `class` and target that. ### Dynamically choosing an image You can also manually import an image asset and pass it to an `<enhanced:img>`. This is useful when you have a collection of static images and would like to dynamically choose one or iterate over them. In this case you will need to update both the `import` statement and `<img>` element as shown below to indicate you'd like process them. `svelte <script> import MyImage from './path/to/your/image.jpg?enhanced'; </script> <enhanced:img src={MyImage} alt="some alt text" />` You can also use Vite's `import.meta.glob`. Note that you will have to specify `enhanced` via a custom query: `svelte <script> const imageModules = import.meta.glob( '/path/to/assets/*.{avif,gif,heif,jpeg,jpg,png,tiff,webp,svg}', { eager: true, query: { enhanced: true } } ) </script> {#each Object.entries(imageModules) as _path, module]} <enhanced:img src={module.default} alt="some alt text" /> {/each}` ### Intrinsic Dimensions `width` and `height` are optional as they can be inferred from the source image and will be automatically added when the `<enhanced:img>` tag is preprocessed. With these attributes, the browser can reserve the correct amount of space, preventing [layout shift. If you'd like to use a different `width` and `height` you can style the image with CSS. Because the preprocessor adds a `width` and `height` for you, if you'd like one of the dimensions to be automatically calculated then you will need to specify that: `svelte <style> .hero-image img { width: var(--size); height: auto; } </style>` ### `srcset` and `sizes` If you have a large image, such as a hero image taking the width of the design, you should specify `sizes` so that smaller versions are requested on smaller devices. E.g. if you have a 1280px image you may want to specify something like: `svelte <enhanced:img src="./image.png" sizes="min(1280px, 100vw)"/>` If `sizes` is specified, `<enhanced:img>` will generate small images for smaller devices and populate the `srcset` attribute. The smallest picture generated automatically will have a width of 540px. If you'd like smaller images or would otherwise like to specify custom widths, you can do that with the `w` query parameter: `svelte <enhanced:img src="./image.png?w=1280;640;400" sizes="(min-width:1920px) 1280px, (min-width:1080px) 640px, (min-width:768px) 400px" />` If `sizes` is not provided, then a HiDPI/Retina image and a standard resolution image will be generated. The image you provide should be 2x the resolution you wish to display so that the browser can display that image on devices with a high device pixel ratio. ### Per-image transforms By default, enhanced images will be transformed to more efficient formats. However, you may wish to apply other transforms such as a blur, quality, flatten, or rotate operation. You can run per-image transforms by appending a query string: `svelte <enhanced:img src="./path/to/your/image.jpg?blur=15" alt="An alt text" />` See the imagetools repo for the full list of directives. ## Loading images dynamically from a CDN In some cases, the images may not be accessible at build time — e.g. they may live inside a content management system or elsewhere. Using a content delivery network (CDN) can allow you to optimize these images dynamically, and provides more flexibility with regards to sizes, but it may involve some setup overhead and usage costs. Depending on caching strategy, the browser may not be able to use a cached copy of the asset until a 304 response is received from the CDN. Building HTML to target CDNs allows using an `<img>` tag since the CDN can serve the appropriate format based on the `User-Agent` header, whereas build-time optimizations must produce `<picture>` tags with multiple sources. Finally, some CDNs may generate images lazily, which could have a negative performance impact for sites with low traffic and frequently changing images. CDNs can generally be used without any need for a library. However, there are a number of libraries with Svelte support that make it easier. `@unpic/svelte` is a CDN-agnostic library with support for a large number of providers. You may also find that specific CDNs like Cloudinary have Svelte support. Finally, some content management systems (CMS) which support Svelte (such as Contentful, Storyblok, and Contentstack) have built-in support for image handling. ## Best practices - For each image type, use the appropriate solution from those discussed above. You can mix and match all three solutions in one project. For example, you may use Vite's built-in handling to provide images for `<meta>` tags, display images on your homepage with `@sveltejs/enhanced-img`, and display user-submitted content with a dynamic approach. - Consider serving all images via CDN regardless of the image optimization types you use. CDNs reduce latency by distributing copies of static assets globally. - Your original images should have a good quality/resolution and should have 2x the width it will be displayed at to serve HiDPI devices. Image processing can size images down to save bandwidth when serving smaller screens, but it would be a waste of bandwidth to invent pixels to size images up. - For images which are much larger than the width of a mobile device (roughly 400px), such as a hero image taking the width of the page design, specify `sizes` so that smaller images can be served on smaller devices. - For important images, such as the largest contentful paint (LCP) image, set `fetchpriority="high"` and avoid `loading="lazy"` to prioritize loading as early as possible. - Give the image a container or styling so that it is constrained and does not jump around while the page is loading affecting your cumulative layout shift (CLS). `width` and `height` help the browser to reserve space while the image is still loading, so `@sveltejs/enhanced-img` will add a `width` and `height` for you. - Always provide a good `alt` text. The Svelte compiler will warn you if you don't do this. - Do not use `em` or `rem` in `sizes` and change the default size of these measures. When used in `sizes` or `@media` queries, `em` and `rem` are both defined to mean the user's default `font-size`. For a `sizes` declaration like `sizes="(min-width: 768px) min(100vw, 108rem), 64rem"`, the actual `em` or `rem` that controls how the image is laid out on the page can be different if changed by CSS. For example, do not do something like `html { font-size: 62.5%; }` as the slot reserved by the browser preloader will now end up being larger than the actual slot of the CSS object model once it has been created.

## docs/kit/40-best-practices/20-seo.md

--- title: SEO --- The most important aspect of SEO is to create high-quality content that is widely linked to from around the web. However, there are a few technical considerations for building sites that rank well. ## Out of the box ### SSR While search engines have got better in recent years at indexing content that was rendered with client-side JavaScript, server-side rendered content is indexed more frequently and reliably. SvelteKit employs SSR by default, and while you can disable it in `handle`, you should leave it on unless you have a good reason not to. ### Performance Signals such as Core Web Vitals impact search engine ranking. Because Svelte and SvelteKit introduce minimal overhead, it's easier to build high performance sites. You can test your site's performance using Google's PageSpeed Insights or Lighthouse. Read the performance page for more details. ### Normalized URLs SvelteKit redirects pathnames with trailing slashes to ones without (or vice versa depending on your configuration), as duplicate URLs are bad for SEO. ## Manual setup ### &lt;title&gt; and &lt;meta&gt; Every page should have well-written and unique `<title>` and `<meta name="description">` elements inside a `<svelte:head>`. Guidance on how to write descriptive titles and descriptions, along with other suggestions on making content understandable by search engines, can be found on Google's Lighthouse SEO audits documentation. ### Sitemaps Sitemaps help search engines prioritize pages within your site, particularly when you have a large amount of content. You can create a sitemap dynamically using an endpoint: ``js /// file: src/routes/sitemap.xml/+server.js export async function GET() { return new Response( ` <?xml version="1.0" encoding="UTF-8" ?> <urlset xmlns="https://www.sitemaps.org/schemas/sitemap/0.9" xmlns:xhtml="https://www.w3.org/1999/xhtml" xmlns:mobile="https://www.google.com/schemas/sitemap-mobile/1.0" xmlns:news="https://www.google.com/schemas/sitemap-news/0.9" xmlns:image="https://www.google.com/schemas/sitemap-image/1.1" xmlns:video="https://www.google.com/schemas/sitemap-video/1.1" > </urlset>`.trim(), { headers: { 'Content-Type': 'application/xml' } } ); }`` ### AMP An unfortunate reality of modern web development is that it is sometimes necessary to create an Accelerated Mobile Pages (AMP) version of your site. In SvelteKit this can be done by setting the `inlineStyleThreshold` option... `js /// file: svelte.config.js /** @type {import('@sveltejs/kit').Config} */ const config = { kit: { // since <link rel="stylesheet"> isn't // allowed, inline all styles inlineStyleThreshold: Infinity } }; export default config;` ...disabling `csr` in your root `+layout.js`/`+layout.server.js`... `js /// file: src/routes/+layout.server.js export const csr = false;` ...adding `amp` to your `app.html` `html <html amp> ...` ...and transforming the HTML using `transformPageChunk` along with `transform` imported from `@sveltejs/amp`: `js /// file: src/hooks.server.js import * as amp from '@sveltejs/amp'; /** @type {import('@sveltejs/kit').Handle} */ export async function handle({ event, resolve }) { let buffer = ''; return await resolve(event, { transformPageChunk: ({ html, done }) => { buffer += html; if (done) return amp.transform(buffer); } }); }` To prevent shipping any unused CSS as a result of transforming the page to amp, we can use `dropcss`: ``js // @filename: ambient.d.ts declare module 'dropcss'; // @filename: index.js //cut /// file: src/hooks.server.js // @errors: 2307 import * as amp from '@sveltejs/amp'; import dropcss from 'dropcss'; /** @type {import('@sveltejs/kit').Handle} */ export async function handle({ event, resolve }) { let buffer = ''; return await resolve(event, { transformPageChunk: ({ html, done }) => { buffer += html; if (done) { let css = ''; const markup = amp .transform(buffer) .replace('⚡', 'amp') // dropcss can't handle this character .replace(/<style amp-custom([^>]*?)>([^]+?)<\/style>/, (match, attributes, contents) => { css = contents; return `<style amp-custom${attributes}></style>`; }); css = dropcss({ css, html: markup }).css; return markup.replace('</style>', `${css}</style>`); } } }); }``

## docs/kit/98-reference/index.md

--- title: Reference ---

## docs/kit/98-reference/10-@sveltejs-kit.md

--- title: @sveltejs/kit --- `js // @noErrors import { Server, VERSION, error, fail, isActionFailure, isHttpError, isRedirect, json, normalizeUrl, redirect, text } from '@sveltejs/kit';` ## Server <div class="ts-block"> `dts class Server {/*…*/}` <div class="ts-block-property"> `dts constructor(manifest: SSRManifest);` <div class="ts-block-property-details"></div> </div> <div class="ts-block-property"> `dts init(options: ServerInitOptions): Promise<void>;` <div class="ts-block-property-details"></div> </div> <div class="ts-block-property"> `dts respond(request: Request, options: RequestOptions): Promise<Response>;` <div class="ts-block-property-details"></div> </div></div> ## VERSION <div class="ts-block"> `dts const VERSION: string;` </div> ## error Throws an error with a HTTP status code and an optional message. When called during request handling, this will cause SvelteKit to return an error response without invoking `handleError`. Make sure you're not catching the thrown error, which would prevent SvelteKit from handling it. <div class="ts-block"> `dts function error(status: number, body: App.Error): never;` </div> <div class="ts-block"> `dts function error( status: number, body?: { message: string; } extends App.Error ? App.Error | string | undefined : never ): never;` </div> ## fail Create an `ActionFailure` object. <div class="ts-block"> `dts function fail(status: number): ActionFailure<undefined>;` </div> <div class="ts-block"> `dts function fail< T extends Record<string, unknown> | undefined = undefined >(status: number, data: T): ActionFailure<T>;` </div> ## isActionFailure Checks whether this is an action failure thrown by `fail`. <div class="ts-block"> `dts function isActionFailure(e: unknown): e is ActionFailure;` </div> ## isHttpError Checks whether this is an error thrown by `error`. <div class="ts-block"> `dts function isHttpError<T extends number>( e: unknown, status?: T | undefined ): e is HttpError_1 & { status: T extends undefined ? never : T; };` </div> ## isRedirect Checks whether this is a redirect thrown by `redirect`. <div class="ts-block"> `dts function isRedirect(e: unknown): e is Redirect_1;` </div> ## json Create a JSON `Response` object from the supplied data. <div class="ts-block"> `dts function json( data: any, init?: ResponseInit | undefined ): Response;` </div> ## normalizeUrl <blockquote class="since note"> Available since 2.18.0 </blockquote> Strips possible SvelteKit-internal suffixes and trailing slashes from the URL pathname. Returns the normalized URL as well as a method for adding the potential suffix back based on a new pathname (possibly including search) or URL. `js // @errors: 7031 import { normalizeUrl } from '@sveltejs/kit'; const { url, denormalize } = normalizeUrl('/blog/post/__data.json'); console.log(url.pathname); // /blog/post console.log(denormalize('/blog/post/a')); // /blog/post/a/__data.json` <div class="ts-block"> `dts function normalizeUrl(url: URL | string): { url: URL; wasNormalized: boolean; denormalize: (url?: string | URL) => URL; };` </div> ## redirect Redirect a request. When called during request handling, SvelteKit will return a redirect response. Make sure you're not catching the thrown redirect, which would prevent SvelteKit from handling it. Most common status codes: _`303 See Other`: redirect as a GET request (often used after a form POST request)_ `307 Temporary Redirect`: redirect will keep the request method _ `308 Permanent Redirect`: redirect will keep the request method, SEO will be transferred to the new page See all redirect status codes <div class="ts-block"> `dts function redirect( status: | 300 | 301 | 302 | 303 | 304 | 305 | 306 | 307 | 308 | ({} & number), location: string | URL ): never;` </div> ## text Create a `Response` object from the supplied body. <div class="ts-block"> `dts function text( body: string, init?: ResponseInit | undefined ): Response;` </div> ## Action Shape of a form action method that is part of `export const actions = {..}` in `+page.server.js`. See form actions for more information. <div class="ts-block"> `dts type Action< Params extends Partial<Record<string, string>> = Partial< Record<string, string> >, OutputData extends Record<string, any> | void = Record< string, any > | void, RouteId extends string | null = string | null > = ( event: RequestEvent<Params, RouteId> ) => MaybePromise<OutputData>;` </div> ## ActionFailure <div class="ts-block"> ```dts interface ActionFailure< T extends Record<string, unknown> | undefined = undefined > {/_…_/} `<div class="ts-block-property">`dts status: number; `<div class="ts-block-property-details"></div> </div> <div class="ts-block-property">`dts data: T; `<div class="ts-block-property-details"></div> </div> <div class="ts-block-property">`dts uniqueSymbol]: true; `<div class="ts-block-property-details"></div> </div></div> ## ActionResult When calling a form action via fetch, the response will be one of these shapes.`svelte <form method="post" use:enhance={() => { return ({ result }) => { // result is of type ActionResult }; }} `<div class="ts-block">`dts type ActionResult< Success extends | Record<string, unknown> | undefined = Record<string, any>, Failure extends | Record<string, unknown> | undefined = Record<string, any> > = | { type: 'success'; status: number; data?: Success } | { type: 'failure'; status: number; data?: Failure } | { type: 'redirect'; status: number; location: string } | { type: 'error'; status?: number; error: any }; ``</div> ## Actions Shape of the `export const actions = {..}` object in `+page.server.js`. See [form actions for more information. <div class="ts-block">``dts type Actions< Params extends Partial<Record<string, string>> = Partial< Record<string, string> >, OutputData extends Record<string, any> | void = Record< string, any > | void, RouteId extends string | null = string | null > = Record<string, Action<Params, OutputData, RouteId>>; `</div> ## Adapter Adapters are responsible for taking the production build and turning it into something that can be deployed to a platform of your choosing. <div class="ts-block">`dts interface Adapter {/_…_/} `<div class="ts-block-property">`dts name: string; `<div class="ts-block-property-details"> The name of the adapter, using for logging. Will typically correspond to the package name. </div> </div> <div class="ts-block-property">`dts adapt: (builder: Builder) => MaybePromise<void>; ``<div class="ts-block-property-details"> <div class="ts-block-property-bullets"> - `builder` An object provided by SvelteKit that contains methods for adapting the app </div> This function is called after SvelteKit has built your app. </div> </div> <div class="ts-block-property">``dts supports?: {/_…_/} `<div class="ts-block-property-details"> Checks called during dev and build to determine whether specific features will work in production with this adapter <div class="ts-block-property-children"><div class="ts-block-property">`dts read?: (details: { config: any; route: { id: string } }) => boolean; ``<div class="ts-block-property-details"> <div class="ts-block-property-bullets"> - `config` The merged route config </div> Test support for `read` from `$app/server` </div> </div></div> </div> </div> <div class="ts-block-property">``dts emulate?: () => MaybePromise<Emulator>; ``<div class="ts-block-property-details"> Creates an `Emulator`, which allows the adapter to influence the environment during dev, build and prerendering </div> </div></div> ## AfterNavigate The argument passed to `afterNavigate` callbacks. <div class="ts-block">``dts interface AfterNavigate extends Omit<Navigation, 'type'> {/_…_/} `<div class="ts-block-property">`dts type: Exclude<NavigationType, 'leave'>; ``<div class="ts-block-property-details"> The type of navigation: - `enter`: The app has hydrated/started - `form`: The user submitted a `<form>` - `link`: Navigation was triggered by a link click - `goto`: Navigation was triggered by a `goto(...)` call or a redirect - `popstate`: Navigation was triggered by back/forward navigation </div> </div> <div class="ts-block-property">``dts willUnload: false; ``<div class="ts-block-property-details"> Since `afterNavigate` callbacks are called after a navigation completes, they will never be called with a navigation that unloads the page. </div> </div></div> ## AwaitedActions <div class="ts-block">``dts type AwaitedActions< T extends Record<string, (...args: any) => any> > = OptionalUnion< { Key in keyof T]: UnpackValidationError< Awaited<ReturnType<T[Key]>> >; }[keyof T] >; ``</div> ## BeforeNavigate The argument passed to [`beforeNavigate` callbacks. <div class="ts-block">``dts interface BeforeNavigate extends Navigation {/_…_/} `<div class="ts-block-property">`dts cancel: () => void; ``<div class="ts-block-property-details"> Call this to prevent the navigation from starting. </div> </div></div> ## Builder This object is passed to the `adapt` function of adapters. It contains various methods and properties that are useful for adapting the app. <div class="ts-block">``dts interface Builder {/_…_/} `<div class="ts-block-property">`dts log: Logger; ``<div class="ts-block-property-details"> Print messages to the console. `log.info` and `log.minor` are silent unless Vite's `logLevel` is `info`. </div> </div> <div class="ts-block-property">``dts rimraf: (dir: string) => void; ``<div class="ts-block-property-details"> Remove `dir` and all its contents. </div> </div> <div class="ts-block-property">``dts mkdirp: (dir: string) => void; ``<div class="ts-block-property-details"> Create `dir` and any required parent directories. </div> </div> <div class="ts-block-property">``dts config: ValidatedConfig; ``<div class="ts-block-property-details"> The fully resolved `svelte.config.js`. </div> </div> <div class="ts-block-property">``dts prerendered: Prerendered; `<div class="ts-block-property-details"> Information about prerendered pages and assets, if any. </div> </div> <div class="ts-block-property">`dts routes: RouteDefinition]; `<div class="ts-block-property-details"> An array of all routes (including prerendered) </div> </div> <div class="ts-block-property">`dts createEntries: (fn: (route: RouteDefinition) => AdapterEntry) => Promise<void>; ``<div class="ts-block-property-details"> <div class="ts-block-property-bullets"> - `fn` A function that groups a set of routes into an entry point - <span class="tag deprecated">deprecated</span> Use `builder.routes` instead </div> Create separate functions that map to one or more routes of your app. </div> </div> <div class="ts-block-property">``dts findServerAssets: (routes: RouteDefinition[]) => string[]; ``<div class="ts-block-property-details"> Find all the assets imported by server files belonging to `routes` </div> </div> <div class="ts-block-property">``dts generateFallback: (dest: string) => Promise<void>; `<div class="ts-block-property-details"> Generate a fallback page for a static webserver to use when no route is matched. Useful for single-page apps. </div> </div> <div class="ts-block-property">`dts generateEnvModule: () => void; ``<div class="ts-block-property-details"> Generate a module exposing build-time environment variables as `$env/dynamic/public`. </div> </div> <div class="ts-block-property">``dts generateManifest: (opts: { relativePath: string; routes?: RouteDefinition[] }) => string; ``<div class="ts-block-property-details"> <div class="ts-block-property-bullets"> - `opts` a relative path to the base directory of the app and optionally in which format (esm or cjs) the manifest should be generated </div> Generate a server-side manifest to initialise the SvelteKit [server with. </div> </div> <div class="ts-block-property">``dts getBuildDirectory: (name: string) => string; ``<div class="ts-block-property-details"> <div class="ts-block-property-bullets"> - `name` path to the file, relative to the build directory </div> Resolve a path to the `name` directory inside `outDir`, e.g. `/path/to/.svelte-kit/my-adapter`. </div> </div> <div class="ts-block-property">``dts getClientDirectory: () => string; ``<div class="ts-block-property-details"> Get the fully resolved path to the directory containing client-side assets, including the contents of your `static` directory. </div> </div> <div class="ts-block-property">``dts getServerDirectory: () => string; `<div class="ts-block-property-details"> Get the fully resolved path to the directory containing server-side code. </div> </div> <div class="ts-block-property">`dts getAppPath: () => string; ``<div class="ts-block-property-details"> Get the application path including any configured `base` path, e.g. `my-base-path/_app`. </div> </div> <div class="ts-block-property">``dts writeClient: (dest: string) => string]; ``<div class="ts-block-property-details"> <div class="ts-block-property-bullets"> - `dest` the destination folder - <span class="tag">returns</span> an array of files written to `dest` </div> Write client assets to `dest`. </div> </div> <div class="ts-block-property">``dts writePrerendered: (dest: string) => string[]; ``<div class="ts-block-property-details"> <div class="ts-block-property-bullets"> - `dest` the destination folder - <span class="tag">returns</span> an array of files written to `dest` </div> Write prerendered files to `dest`. </div> </div> <div class="ts-block-property">``dts writeServer: (dest: string) => string[]; ``<div class="ts-block-property-details"> <div class="ts-block-property-bullets"> - `dest` the destination folder - <span class="tag">returns</span> an array of files written to `dest` </div> Write server-side code to `dest`. </div> </div> <div class="ts-block-property">``dts copy: ( from: string, to: string, opts?: { filter?(basename: string): boolean; replace?: Record<string, string>; } ) => string[]; ``<div class="ts-block-property-details"> <div class="ts-block-property-bullets"> - `from` the source file or directory - `to` the destination file or directory - `opts.filter` a function to determine whether a file or directory should be copied - `opts.replace` a map of strings to replace - <span class="tag">returns</span> an array of files that were copied </div> Copy a file or directory. </div> </div> <div class="ts-block-property">``dts compress: (directory: string) => Promise<void>; ``<div class="ts-block-property-details"> <div class="ts-block-property-bullets"> - `directory` The directory containing the files to be compressed </div> Compress files in `directory` with gzip and brotli, where appropriate. Generates `.gz` and `.br` files alongside the originals. </div> </div></div> ## ClientInit <blockquote class="since note"> Available since 2.10.0 </blockquote> The [`init` will be invoked once the app starts in the browser <div class="ts-block">``dts type ClientInit = () => MaybePromise<void>; `</div> ## Config See the configuration reference for details. ## Cookies <div class="ts-block">`dts interface Cookies {/_…_/} `<div class="ts-block-property">`dts get: (name: string, opts?: import('cookie').CookieParseOptions) => string | undefined; ``<div class="ts-block-property-details"> <div class="ts-block-property-bullets"> - `name` the name of the cookie - `opts` the options, passed directly to `cookie.parse`. See documentation here </div> Gets a cookie that was previously set with `cookies.set`, or from the request headers. </div> </div> <div class="ts-block-property">``dts getAll: (opts?: import('cookie').CookieParseOptions) => Array<{ name: string; value: string }>; ``<div class="ts-block-property-details"> <div class="ts-block-property-bullets"> - `opts` the options, passed directly to `cookie.parse`. See documentation here </div> Gets all cookies that were previously set with `cookies.set`, or from the request headers. </div> </div> <div class="ts-block-property">``dts set: ( name: string, value: string, opts: import('cookie').CookieSerializeOptions & { path: string } ) => void; ``<div class="ts-block-property-details"> <div class="ts-block-property-bullets"> - `name` the name of the cookie - `value` the cookie value - `opts` the options, passed directly to `cookie.serialize`. See documentation here </div> Sets a cookie. This will add a `set-cookie` header to the response, but also make the cookie available via `cookies.get` or `cookies.getAll` during the current request. The `httpOnly` and `secure` options are `true` by default (except on http://localhost, where `secure` is `false`), and must be explicitly disabled if you want cookies to be readable by client-side JavaScript and/or transmitted over HTTP. The `sameSite` option defaults to `lax`. You must specify a `path` for the cookie. In most cases you should explicitly set `path: '/'` to make the cookie available throughout your app. You can use relative paths, or set `path: ''` to make the cookie only available on the current path and its children </div> </div> <div class="ts-block-property">``dts delete: (name: string, opts: import('cookie').CookieSerializeOptions & { path: string }) => void; ``<div class="ts-block-property-details"> <div class="ts-block-property-bullets"> - `name` the name of the cookie - `opts` the options, passed directly to `cookie.serialize`. The `path` must match the path of the cookie you want to delete. See documentation here </div> Deletes a cookie by setting its value to an empty string and setting the expiry date in the past. You must specify a `path` for the cookie. In most cases you should explicitly set `path: '/'` to make the cookie available throughout your app. You can use relative paths, or set `path: ''` to make the cookie only available on the current path and its children </div> </div> <div class="ts-block-property">``dts serialize: ( name: string, value: string, opts: import('cookie').CookieSerializeOptions & { path: string } ) => string; ``<div class="ts-block-property-details"> <div class="ts-block-property-bullets"> - `name` the name of the cookie - `value` the cookie value - `opts` the options, passed directly to `cookie.serialize`. See documentation here </div> Serialize a cookie name-value pair into a `Set-Cookie` header string, but don't apply it to the response. The `httpOnly` and `secure` options are `true` by default (except on http://localhost, where `secure` is `false`), and must be explicitly disabled if you want cookies to be readable by client-side JavaScript and/or transmitted over HTTP. The `sameSite` option defaults to `lax`. You must specify a `path` for the cookie. In most cases you should explicitly set `path: '/'` to make the cookie available throughout your app. You can use relative paths, or set `path: ''` to make the cookie only available on the current path and its children </div> </div></div> ## Emulator A collection of functions that influence the environment during dev, build and prerendering <div class="ts-block">``dts interface Emulator {/_…_/} `<div class="ts-block-property">`dts platform?(details: { config: any; prerender: PrerenderOption }): MaybePromise<App.Platform>; ``<div class="ts-block-property-details"> A function that is called with the current route `config` and `prerender` option and returns an `App.Platform` object </div> </div></div> ## Handle The `handle` hook runs every time the SvelteKit server receives a request and determines the response. It receives an `event` object representing the request and a function called `resolve`, which renders the route and generates a `Response`. This allows you to modify response headers or bodies, or bypass SvelteKit entirely (for implementing routes programmatically, for example). <div class="ts-block">``dts type Handle = (input: { event: RequestEvent; resolve: ( event: RequestEvent, opts?: ResolveOptions ) => MaybePromise<Response>; }) => MaybePromise<Response>; ``</div> ## HandleClientError The client-side `handleError` hook runs when an unexpected error is thrown while navigating. If an unexpected error is thrown during loading or the following render, this function will be called with the error and the event. Make sure that this function \_never_ throws an error. <div class="ts-block">`dts type HandleClientError = (input: { error: unknown; event: NavigationEvent; status: number; message: string; }) => MaybePromise<void | App.Error>; `</div> ## HandleFetch The `handleFetch` hook allows you to modify (or replace) a `fetch` request that happens inside a `load` function that runs on the server (or during pre-rendering) <div class="ts-block">`dts type HandleFetch = (input: { event: RequestEvent; request: Request; fetch: typeof fetch; }) => MaybePromise<Response>; `</div> ## HandleServerError The server-side `handleError` hook runs when an unexpected error is thrown while responding to a request. If an unexpected error is thrown during loading or rendering, this function will be called with the error and the event. Make sure that this function _never_ throws an error. <div class="ts-block">`dts type HandleServerError = (input: { error: unknown; event: RequestEvent; status: number; message: string; }) => MaybePromise<void | App.Error>; `</div> ## HttpError The object returned by the `error` function. <div class="ts-block">``dts interface HttpError {/_…_/} `<div class="ts-block-property">`dts status: number; `<div class="ts-block-property-details"> The HTTP status code, in the range 400-599. </div> </div> <div class="ts-block-property">`dts body: App.Error; `<div class="ts-block-property-details"> The content of the error. </div> </div></div> ## KitConfig See the configuration reference for details. ## LessThan <div class="ts-block">`dts type LessThan< TNumber extends number, TArray extends any] = [] > = TNumber extends TArray['length'] ? TArray[number] : LessThan<TNumber, [...TArray, TArray['length']]>; ``</div> ## Load The generic form of `PageLoad` and `LayoutLoad`. You should import those from `./$types` (see [generated types) rather than using `Load` directly. <div class="ts-block">`dts type Load< Params extends Partial<Record<string, string>> = Partial< Record<string, string> >, InputData extends Record<string, unknown> | null = Record< string, any > | null, ParentData extends Record<string, unknown> = Record< string, any >, OutputData extends Record< string, unknown > | void = Record<string, any> | void, RouteId extends string | null = string | null > = ( event: LoadEvent<Params, InputData, ParentData, RouteId> ) => MaybePromise<OutputData>; `</div> ## LoadEvent The generic form of `PageLoadEvent` and `LayoutLoadEvent`. You should import those from `./$types` (see generated types) rather than using `LoadEvent` directly. <div class="ts-block">``dts interface LoadEvent< Params extends Partial<Record<string, string>> = Partial< Record<string, string> >, Data extends Record<string, unknown> | null = Record< string, any > | null, ParentData extends Record<string, unknown> = Record< string, any >, RouteId extends string | null = string | null > extends NavigationEvent<Params, RouteId> {/_…_/} `<div class="ts-block-property">`dts fetch: typeof fetch; ``<div class="ts-block-property-details"> `fetch` is equivalent to the native `fetch` web API, with a few additional features: - It can be used to make credentialed requests on the server, as it inherits the `cookie` and `authorization` headers for the page request. - It can make relative requests on the server (ordinarily, `fetch` requires a URL with an origin when used in a server context). - Internal requests (e.g. for `+server.js` routes) go directly to the handler function when running on the server, without the overhead of an HTTP call. - During server-side rendering, the response will be captured and inlined into the rendered HTML by hooking into the `text` and `json` methods of the `Response` object. Note that headers will _not_ be serialized, unless explicitly included via `filterSerializedResponseHeaders` - During hydration, the response will be read from the HTML, guaranteeing consistency and preventing an additional network request. You can learn more about making credentialed requests with cookies here </div> </div> <div class="ts-block-property">`dts data: Data; `<div class="ts-block-property-details"> Contains the data returned by the route's server `load` function (in `+layout.server.js` or `+page.server.js`), if any. </div> </div> <div class="ts-block-property">``dts setHeaders: (headers: Record<string, string>) => void; `<div class="ts-block-property-details"> If you need to set headers for the response, you can do so using the this method. This is useful if you want the page to be cached, for example:`js // @errors: 7031 /// file: src/routes/blog/+page.js export async function load({ fetch, setHeaders }) { const url = `https://cms.example.com/articles.json`; const response = await fetch(url); setHeaders({ age: response.headers.get('age'), 'cache-control': response.headers.get('cache-control') }); return response.json(); } ``Setting the same header multiple times (even in separate `load` functions) is an error — you can only set a given header once. You cannot add a `set-cookie` header with `setHeaders` — use the `cookies` API in a server-only `load` function instead. `setHeaders` has no effect when a `load` function runs in the browser. </div> </div> <div class="ts-block-property">`dts parent: () => Promise<ParentData>; `<div class="ts-block-property-details"> `await parent()` returns data from parent `+layout.js` `load` functions. Implicitly, a missing `+layout.js` is treated as a `({ data }) => data` function, meaning that it will return and forward data from parent `+layout.server.js` files. Be careful not to introduce accidental waterfalls when using `await parent()`. If for example you only want to merge parent data into the returned output, call it _after_ fetching your other data. </div> </div> <div class="ts-block-property">``dts depends: (...deps: Array<`${string}:${string}`>) => void; ``<div class="ts-block-property-details"> This function declares that the `load` function has a _dependency_ on one or more URLs or custom identifiers, which can subsequently be used with `invalidate()` to cause `load` to rerun. Most of the time you won't need this, as `fetch` calls `depends` on your behalf — it's only necessary if you're using a custom API client that bypasses `fetch`. URLs can be absolute or relative to the page being loaded, and must be encoded. Custom identifiers have to be prefixed with one or more lowercase letters followed by a colon to conform to the URI specification. The following example shows how to use `depends` to register a dependency on a custom identifier, which is `invalidate`d after a button click, making the `load` function rerun.``js // @errors: 7031 /// file: src/routes/+page.js let count = 0; export async function load({ depends }) { depends('increase:count'); return { count: count++ }; } ` `html /// file: src/routes/+page.svelte <script> import { invalidate } from '$app/navigation'; let { data } = $props(); const increase = async () => { await invalidate('increase:count'); } </script> <p>{data.count}<p> <button on:click={increase}>Increase Count</button> `</div> </div> <div class="ts-block-property">`dts untrack: <T>(fn: () => T) => T; `<div class="ts-block-property-details"> Use this function to opt out of dependency tracking for everything that is synchronously called within the callback. Example:`js // @errors: 7031 /// file: src/routes/+page.server.js export async function load({ untrack, url }) { // Untrack url.pathname so that path changes don't trigger a rerun if (untrack(() => url.pathname === '/')) { return { message: 'Welcome!' }; } } `</div> </div></div> ## LoadProperties <div class="ts-block">`dts type LoadProperties< input extends Record<string, any> | void > = input extends void ? undefined // needs to be undefined, because void will break intellisense : input extends Record<string, any> ? input : unknown; `</div> ## Navigation <div class="ts-block">`dts interface Navigation {/_…_/} `<div class="ts-block-property">`dts from: NavigationTarget | null; `<div class="ts-block-property-details"> Where navigation was triggered from </div> </div> <div class="ts-block-property">`dts to: NavigationTarget | null; `<div class="ts-block-property-details"> Where navigation is going to/has gone to </div> </div> <div class="ts-block-property">`dts type: Exclude<NavigationType, 'enter'>; ``<div class="ts-block-property-details"> The type of navigation: - `form`: The user submitted a `<form>` - `leave`: The app is being left either because the tab is being closed or a navigation to a different document is occurring - `link`: Navigation was triggered by a link click - `goto`: Navigation was triggered by a `goto(...)` call or a redirect - `popstate`: Navigation was triggered by back/forward navigation </div> </div> <div class="ts-block-property">``dts willUnload: boolean; `<div class="ts-block-property-details"> Whether or not the navigation will result in the page being unloaded (i.e. not a client-side navigation) </div> </div> <div class="ts-block-property">`dts delta?: number; `<div class="ts-block-property-details"> In case of a history back/forward navigation, the number of steps to go back/forward </div> </div> <div class="ts-block-property">`dts complete: Promise<void>; ``<div class="ts-block-property-details"> A promise that resolves once the navigation is complete, and rejects if the navigation fails or is aborted. In the case of a `willUnload` navigation, the promise will never resolve </div> </div></div> ## NavigationEvent <div class="ts-block">``dts interface NavigationEvent< Params extends Partial<Record<string, string>> = Partial< Record<string, string> >, RouteId extends string | null = string | null > {/_…_/} `<div class="ts-block-property">`dts params: Params; ``<div class="ts-block-property-details"> The parameters of the current page - e.g. for a route like `/blog/slug]`, a `{ slug: string }` object </div> </div> <div class="ts-block-property">``dts route: {/_…_/} `<div class="ts-block-property-details"> Info about the current route <div class="ts-block-property-children"><div class="ts-block-property">`dts id: RouteId; ``<div class="ts-block-property-details"> The ID of the current route - e.g. for `src/routes/blog/[slug]`, it would be `/blog/[slug]`. It is `null` when no route is matched. </div> </div></div> </div> </div> <div class="ts-block-property">``dts url: URL; `<div class="ts-block-property-details"> The URL of the current page </div> </div></div> ## NavigationTarget Information about the target of a specific navigation. <div class="ts-block">`dts interface NavigationTarget {/_…_/} `<div class="ts-block-property">`dts params: Record<string, string> | null; ``<div class="ts-block-property-details"> Parameters of the target page - e.g. for a route like `/blog/[slug]`, a `{ slug: string }` object. Is `null` if the target is not part of the SvelteKit app (could not be resolved to a route). </div> </div> <div class="ts-block-property">``dts route: {/_…_/} `<div class="ts-block-property-details"> Info about the target route <div class="ts-block-property-children"><div class="ts-block-property">`dts id: string | null; ``<div class="ts-block-property-details"> The ID of the current route - e.g. for `src/routes/blog/[slug]`, it would be `/blog/[slug]`. It is `null` when no route is matched. </div> </div></div> </div> </div> <div class="ts-block-property">`dts url: URL; `<div class="ts-block-property-details"> The URL that is navigated to </div> </div></div> ## NavigationType - `enter`: The app has hydrated/started - `form`: The user submitted a `<form>` with a GET method - `leave`: The user is leaving the app by closing the tab or using the back/forward buttons to go to a different document - `link`: Navigation was triggered by a link click - `goto`: Navigation was triggered by a `goto(...)` call or a redirect - `popstate`: Navigation was triggered by back/forward navigation <div class="ts-block">``dts type NavigationType = | 'enter' | 'form' | 'leave' | 'link' | 'goto' | 'popstate'; `</div> ## NumericRange <div class="ts-block">`dts type NumericRange< TStart extends number, TEnd extends number > = Exclude<TEnd | LessThan<TEnd>, LessThan<TStart>>; ``</div> ## OnNavigate The argument passed to [`onNavigate` callbacks. <div class="ts-block">``dts interface OnNavigate extends Navigation {/_…_/} `<div class="ts-block-property">`dts type: Exclude<NavigationType, 'enter' | 'leave'>; ``<div class="ts-block-property-details"> The type of navigation: - `form`: The user submitted a `<form>` - `link`: Navigation was triggered by a link click - `goto`: Navigation was triggered by a `goto(...)` call or a redirect - `popstate`: Navigation was triggered by back/forward navigation </div> </div> <div class="ts-block-property">`dts willUnload: false; `<div class="ts-block-property-details"> Since `onNavigate` callbacks are called immediately before a client-side navigation, they will never be called with a navigation that unloads the page. </div> </div></div> ## Page The shape of the `page` reactive object and the `$page` store. <div class="ts-block">``dts interface Page< Params extends Record<string, string> = Record< string, string >, RouteId extends string | null = string | null > {/_…_/} `<div class="ts-block-property">`dts url: URL; `<div class="ts-block-property-details"> The URL of the current page. </div> </div> <div class="ts-block-property">`dts params: Params; ``<div class="ts-block-property-details"> The parameters of the current page - e.g. for a route like `/blog/slug]`, a `{ slug: string }` object. </div> </div> <div class="ts-block-property">``dts route: {/_…_/} `<div class="ts-block-property-details"> Info about the current route. <div class="ts-block-property-children"><div class="ts-block-property">`dts id: RouteId; ``<div class="ts-block-property-details"> The ID of the current route - e.g. for `src/routes/blog/[slug]`, it would be `/blog/[slug]`. It is `null` when no route is matched. </div> </div></div> </div> </div> <div class="ts-block-property">``dts status: number; `<div class="ts-block-property-details"> HTTP status code of the current page. </div> </div> <div class="ts-block-property">`dts error: App.Error | null; ``<div class="ts-block-property-details"> The error object of the current page, if any. Filled from the `handleError` hooks. </div> </div> <div class="ts-block-property">`dts data: App.PageData & Record<string, any>; `<div class="ts-block-property-details"> The merged result of all data from all `load` functions on the current page. You can type a common denominator through `App.PageData`. </div> </div> <div class="ts-block-property">`dts state: App.PageState; `<div class="ts-block-property-details"> The page state, which can be manipulated using the [`pushState` and `replaceState` functions from `$app/navigation`. </div> </div> <div class="ts-block-property">``dts form: any; `<div class="ts-block-property-details"> Filled only after a form submission. See form actions for more info. </div> </div></div> ## ParamMatcher The shape of a param matcher. See matching for more info. <div class="ts-block">`dts type ParamMatcher = (param: string) => boolean; `</div> ## PrerenderOption <div class="ts-block">`dts type PrerenderOption = boolean | 'auto'; ``</div> ## Redirect The object returned by the `redirect` function. <div class="ts-block">``dts interface Redirect {/_…_/} `<div class="ts-block-property">`dts status: 300 | 301 | 302 | 303 | 304 | 305 | 306 | 307 | 308; `<div class="ts-block-property-details"> The HTTP status code, in the range 300-308. </div> </div> <div class="ts-block-property">`dts location: string; `<div class="ts-block-property-details"> The location to redirect to. </div> </div></div> ## RequestEvent <div class="ts-block">`dts interface RequestEvent< Params extends Partial<Record<string, string>> = Partial< Record<string, string> >, RouteId extends string | null = string | null > {/_…_/} `<div class="ts-block-property">`dts cookies: Cookies; `<div class="ts-block-property-details"> Get or set cookies related to the current request </div> </div> <div class="ts-block-property">`dts fetch: typeof fetch; ``<div class="ts-block-property-details"> `fetch` is equivalent to the native `fetch` web API, with a few additional features: - It can be used to make credentialed requests on the server, as it inherits the `cookie` and `authorization` headers for the page request. - It can make relative requests on the server (ordinarily, `fetch` requires a URL with an origin when used in a server context). - Internal requests (e.g. for `+server.js` routes) go directly to the handler function when running on the server, without the overhead of an HTTP call. - During server-side rendering, the response will be captured and inlined into the rendered HTML by hooking into the `text` and `json` methods of the `Response` object. Note that headers will _not_ be serialized, unless explicitly included via `filterSerializedResponseHeaders` - During hydration, the response will be read from the HTML, guaranteeing consistency and preventing an additional network request. You can learn more about making credentialed requests with cookies here. </div> </div> <div class="ts-block-property">``dts getClientAddress: () => string; `<div class="ts-block-property-details"> The client's IP address, set by the adapter. </div> </div> <div class="ts-block-property">`dts locals: App.Locals; ``<div class="ts-block-property-details"> Contains custom data that was added to the request within the `server handle hook`. </div> </div> <div class="ts-block-property">`dts params: Params; `<div class="ts-block-property-details"> The parameters of the current route - e.g. for a route like `/blog/slug]`, a `{ slug: string }` object. </div> </div> <div class="ts-block-property">``dts platform: Readonly<App.Platform> | undefined; `<div class="ts-block-property-details"> Additional data made available through the adapter. </div> </div> <div class="ts-block-property">`dts request: Request; `<div class="ts-block-property-details"> The original request object. </div> </div> <div class="ts-block-property">`dts route: {/_…_/} `<div class="ts-block-property-details"> Info about the current route. <div class="ts-block-property-children"><div class="ts-block-property">`dts id: RouteId; ``<div class="ts-block-property-details"> The ID of the current route - e.g. for `src/routes/blog/[slug]`, it would be `/blog/[slug]`. It is `null` when no route is matched. </div> </div></div> </div> </div> <div class="ts-block-property">``dts setHeaders: (headers: Record<string, string>) => void; `<div class="ts-block-property-details"> If you need to set headers for the response, you can do so using the this method. This is useful if you want the page to be cached, for example:`js // @errors: 7031 /// file: src/routes/blog/+page.js export async function load({ fetch, setHeaders }) { const url = `https://cms.example.com/articles.json`; const response = await fetch(url); setHeaders({ age: response.headers.get('age'), 'cache-control': response.headers.get('cache-control') }); return response.json(); } ``Setting the same header multiple times (even in separate `load` functions) is an error — you can only set a given header once. You cannot add a `set-cookie` header with `setHeaders` — use the [`cookies` API instead. </div> </div> <div class="ts-block-property">``dts url: URL; `<div class="ts-block-property-details"> The requested URL. </div> </div> <div class="ts-block-property">`dts isDataRequest: boolean; ``<div class="ts-block-property-details"> `true` if the request comes from the client asking for `+page/layout.server.js` data. The `url` property will be stripped of the internal information related to the data request in this case. Use this property instead if the distinction is important to you. </div> </div> <div class="ts-block-property">`dts isSubRequest: boolean; `<div class="ts-block-property-details"> `true` for `+server.js` calls coming from SvelteKit without the overhead of actually making an HTTP request. This happens when you make same-origin `fetch` requests on the server. </div> </div></div> ## RequestHandler A `(event: RequestEvent) => Response` function exported from a `+server.js` file that corresponds to an HTTP verb (`GET`, `PUT`, `PATCH`, etc) and handles requests with that method. It receives `Params` as the first generic argument, which you can skip by using generated types instead. <div class="ts-block">`dts type RequestHandler< Params extends Partial<Record<string, string>> = Partial< Record<string, string> >, RouteId extends string | null = string | null > = ( event: RequestEvent<Params, RouteId> ) => MaybePromise<Response>; `</div> ## Reroute <blockquote class="since note"> Available since 2.3.0 </blockquote> The `reroute` hook allows you to modify the URL before it is used to determine which route to render. <div class="ts-block">``dts type Reroute = (event: { url: URL; fetch: typeof fetch; }) => MaybePromise<void | string>; `</div> ## ResolveOptions <div class="ts-block">`dts interface ResolveOptions {/_…_/} `<div class="ts-block-property">`dts transformPageChunk?: (input: { html: string; done: boolean }) => MaybePromise<string | undefined>; ``<div class="ts-block-property-details"> <div class="ts-block-property-bullets"> - `input` the html chunk and the info if this is the last chunk </div> Applies custom transforms to HTML. If `done` is true, it's the final chunk. Chunks are not guaranteed to be well-formed HTML (they could include an element's opening tag but not its closing tag, for example) but they will always be split at sensible boundaries such as `%sveltekit.head%` or layout/page components. </div> </div> <div class="ts-block-property">`dts filterSerializedResponseHeaders?: (name: string, value: string) => boolean; `<div class="ts-block-property-details"> <div class="ts-block-property-bullets"> - `name` header name - `value` header value </div> Determines which headers should be included in serialized responses when a `load` function loads a resource with `fetch`. By default, none will be included. </div> </div> <div class="ts-block-property">`dts preload?: (input: { type: 'font' | 'css' | 'js' | 'asset'; path: string }) => boolean; `<div class="ts-block-property-details"> <div class="ts-block-property-bullets"> - `input` the type of the file and its path </div> Determines what should be added to the `<head>` tag to preload it. By default, `js` and `css` files will be preloaded. </div> </div></div> ## RouteDefinition <div class="ts-block">``dts interface RouteDefinition<Config = any> {/_…_/} `<div class="ts-block-property">`dts id: string; `<div class="ts-block-property-details"></div> </div> <div class="ts-block-property">`dts api: { methods: Array<HttpMethod | '_'>; }; `<div class="ts-block-property-details"></div> </div> <div class="ts-block-property">`dts page: { methods: Array<Extract<HttpMethod, 'GET' | 'POST'>>; }; `<div class="ts-block-property-details"></div> </div> <div class="ts-block-property">`dts pattern: RegExp; `<div class="ts-block-property-details"></div> </div> <div class="ts-block-property">`dts prerender: PrerenderOption; `<div class="ts-block-property-details"></div> </div> <div class="ts-block-property">`dts segments: RouteSegment]; `<div class="ts-block-property-details"></div> </div> <div class="ts-block-property">`dts methods: Array<HttpMethod | '_'>; `<div class="ts-block-property-details"></div> </div> <div class="ts-block-property">`dts config: Config; `<div class="ts-block-property-details"></div> </div></div> ## SSRManifest <div class="ts-block">`dts interface SSRManifest {/_…_/} `<div class="ts-block-property">`dts appDir: string; `<div class="ts-block-property-details"></div> </div> <div class="ts-block-property">`dts appPath: string; `<div class="ts-block-property-details"></div> </div> <div class="ts-block-property">`dts assets: Set<string>; ``<div class="ts-block-property-details"> Static files from `kit.config.files.assets` and the service worker (if any). </div> </div> <div class="ts-block-property">``dts mimeTypes: Record<string, string>; `<div class="ts-block-property-details"></div> </div> <div class="ts-block-property">`dts \_: {/_…_/} `<div class="ts-block-property-details"> private fields <div class="ts-block-property-children"><div class="ts-block-property">`dts client: NonNullable<BuildData['client']>; `<div class="ts-block-property-details"></div> </div> <div class="ts-block-property">`dts nodes: SSRNodeLoader[]; `<div class="ts-block-property-details"></div> </div> <div class="ts-block-property">`dts routes: SSRRoute[]; `<div class="ts-block-property-details"></div> </div> <div class="ts-block-property">`dts prerendered_routes: Set<string>; `<div class="ts-block-property-details"></div> </div> <div class="ts-block-property">`dts matchers: () => Promise<Record<string, ParamMatcher>>; `<div class="ts-block-property-details"></div> </div> <div class="ts-block-property">`dts server_assets: Record<string, number>; ``<div class="ts-block-property-details"> A `[file]: size` map of all assets imported by server code. </div> </div></div> </div> </div></div> ## ServerInit <blockquote class="since note"> Available since 2.10.0 </blockquote> The [`init` will be invoked before the server responds to its first request <div class="ts-block">``dts type ServerInit = () => MaybePromise<void>; `</div> ## ServerInitOptions <div class="ts-block">`dts interface ServerInitOptions {/_…_/} `<div class="ts-block-property">`dts env: Record<string, string>; `<div class="ts-block-property-details"> A map of environment variables. </div> </div> <div class="ts-block-property">`dts read?: (file: string) => ReadableStream; ``<div class="ts-block-property-details"> A function that turns an asset filename into a `ReadableStream`. Required for the `read` export from `$app/server` to work. </div> </div></div> ## ServerLoad The generic form of `PageServerLoad` and `LayoutServerLoad`. You should import those from `./$types` (see generated types) rather than using `ServerLoad` directly. <div class="ts-block">``dts type ServerLoad< Params extends Partial<Record<string, string>> = Partial< Record<string, string> >, ParentData extends Record<string, any> = Record< string, any >, OutputData extends Record<string, any> | void = Record< string, any > | void, RouteId extends string | null = string | null > = ( event: ServerLoadEvent<Params, ParentData, RouteId> ) => MaybePromise<OutputData>; `</div> ## ServerLoadEvent <div class="ts-block">`dts interface ServerLoadEvent< Params extends Partial<Record<string, string>> = Partial< Record<string, string> >, ParentData extends Record<string, any> = Record< string, any >, RouteId extends string | null = string | null > extends RequestEvent<Params, RouteId> {/_…_/} `<div class="ts-block-property">`dts parent: () => Promise<ParentData>; ``<div class="ts-block-property-details"> `await parent()` returns data from parent `+layout.server.js` `load` functions. Be careful not to introduce accidental waterfalls when using `await parent()`. If for example you only want to merge parent data into the returned output, call it _after_ fetching your other data. </div> </div> <div class="ts-block-property">`dts depends: (...deps: string]) => void; `<div class="ts-block-property-details"> This function declares that the `load` function has a _dependency_ on one or more URLs or custom identifiers, which can subsequently be used with [`invalidate()` to cause `load` to rerun. Most of the time you won't need this, as `fetch` calls `depends` on your behalf — it's only necessary if you're using a custom API client that bypasses `fetch`. URLs can be absolute or relative to the page being loaded, and must be encoded. Custom identifiers have to be prefixed with one or more lowercase letters followed by a colon to conform to the URI specification. The following example shows how to use `depends` to register a dependency on a custom identifier, which is `invalidate`d after a button click, making the `load` function rerun.``js // @errors: 7031 /// file: src/routes/+page.js let count = 0; export async function load({ depends }) { depends('increase:count'); return { count: count++ }; } ` `html /// file: src/routes/+page.svelte <script> import { invalidate } from '$app/navigation'; let { data } = $props(); const increase = async () => { await invalidate('increase:count'); } </script> <p>{data.count}<p> <button on:click={increase}>Increase Count</button> `</div> </div> <div class="ts-block-property">`dts untrack: <T>(fn: () => T) => T; `<div class="ts-block-property-details"> Use this function to opt out of dependency tracking for everything that is synchronously called within the callback. Example:`js // @errors: 7031 /// file: src/routes/+page.js export async function load({ untrack, url }) { // Untrack url.pathname so that path changes don't trigger a rerun if (untrack(() => url.pathname === '/')) { return { message: 'Welcome!' }; } } ``</div> </div></div> ## Snapshot The type of `export const snapshot` exported from a page or layout component. <div class="ts-block">``dts interface Snapshot<T = any> {/_…_/} `<div class="ts-block-property">`dts capture: () => T; `<div class="ts-block-property-details"></div> </div> <div class="ts-block-property">`dts restore: (snapshot: T) => void; `<div class="ts-block-property-details"></div> </div></div> ## SubmitFunction <div class="ts-block">`dts type SubmitFunction< Success extends | Record<string, unknown> | undefined = Record<string, any>, Failure extends | Record<string, unknown> | undefined = Record<string, any> > = (input: { action: URL; formData: FormData; formElement: HTMLFormElement; controller: AbortController; submitter: HTMLElement | null; cancel: () => void; }) => MaybePromise< | void | ((opts: { formData: FormData; formElement: HTMLFormElement; action: URL; result: ActionResult<Success, Failure>; /\*\* _ Call this to get the default behavior of a form submission response. _ @param options Set `reset: false` if you don't want the `<form>` values to be reset after a successful submission. _ @param invalidateAll Set `invalidateAll: false` if you don't want the action to call `invalidateAll` after submission. _/ update: (options?: { reset?: boolean; invalidateAll?: boolean; }) => Promise<void>; }) => MaybePromise<void>) >; ``</div> ## Transport <blockquote class="since note"> Available since 2.11.0 </blockquote> The `transport` hook allows you to transport custom types across the server/client boundary. Each transporter has a pair of `encode` and `decode` functions. On the server, `encode` determines whether a value is an instance of the custom type and, if so, returns a non-falsy encoding of the value which can be an object or an array (or `false` otherwise). In the browser, `decode` turns the encoding back into an instance of the custom type.``ts import type { Transport } from '@sveltejs/kit'; declare class MyCustomType { data: any } // hooks.js export const transport: Transport = { MyCustomType: { encode: (value) => value instanceof MyCustomType && value.data], decode: ([data]) => new MyCustomType(data) } }; `<div class="ts-block">`dts type Transport = Record<string, Transporter>; ``</div> ## Transporter A member of the [`transport` hook. <div class="ts-block">``dts interface Transporter< T = any, U = Exclude< any, false | 0 | '' | null | undefined | typeof NaN > > {/_…_/} `<div class="ts-block-property">`dts encode: (value: T) => false | U; `<div class="ts-block-property-details"></div> </div> <div class="ts-block-property">`dts decode: (data: U) => T; `<div class="ts-block-property-details"></div> </div></div> ## Private types The following are referenced by the public types documented above, but cannot be imported directly: ## AdapterEntry <div class="ts-block">`dts interface AdapterEntry {/_…_/} `<div class="ts-block-property">`dts id: string; ``<div class="ts-block-property-details"> A string that uniquely identifies an HTTP service (e.g. serverless function) and is used for deduplication. For example, `/foo/a-[b]` and `/foo/[c]` are different routes, but would both be represented in a Netlify _redirects file as `/foo/:param`, so they share an ID </div> </div> <div class="ts-block-property">`dts filter(route: RouteDefinition): boolean; `<div class="ts-block-property-details"> A function that compares the candidate route with the current route to determine if it should be grouped with the current route. Use cases: - Fallback pages: `/foo/[c]` is a fallback for `/foo/a-[b]`, and `/[...catchall]` is a fallback for all routes - Grouping routes that share a common `config`: `/foo` should be deployed to the edge, `/bar` and `/baz` should be deployed to a serverless function </div> </div> <div class="ts-block-property">``dts complete(entry: { generateManifest(opts: { relativePath: string }): string }): MaybePromise<void>; `<div class="ts-block-property-details"> A function that is invoked once the entry has been created. This is where you should write the function to the filesystem and generate redirect manifests. </div> </div></div> ## Csp <div class="ts-block">`dts namespace Csp { type ActionSource = 'strict-dynamic' | 'report-sample'; type BaseSource = | 'self' | 'unsafe-eval' | 'unsafe-hashes' | 'unsafe-inline' | 'wasm-unsafe-eval' | 'none'; type CryptoSource = `${'nonce' | 'sha256' | 'sha384' | 'sha512'}-${string}`; type FrameSource = | HostSource | SchemeSource | 'self' | 'none'; type HostNameScheme = `${string}.${string}`| 'localhost'; type HostSource =`${HostProtocolSchemes}${HostNameScheme}${PortScheme}`; type HostProtocolSchemes = `${string}://`| ''; type HttpDelineator = '/' | '?' | '#' | '\\'; type PortScheme =`:${number}` | '' | ':_'; type SchemeSource = | 'http:' | 'https:' | 'data:' | 'mediastream:' | 'blob:' | 'filesystem:'; type Source = | HostSource | SchemeSource | CryptoSource | BaseSource; type Sources = Source[]; } `</div> ## CspDirectives <div class="ts-block">`dts interface CspDirectives {/_…_/} `<div class="ts-block-property">`dts 'child-src'?: Csp.Sources; `<div class="ts-block-property-details"></div> </div> <div class="ts-block-property">`dts 'default-src'?: Array<Csp.Source | Csp.ActionSource>; `<div class="ts-block-property-details"></div> </div> <div class="ts-block-property">`dts 'frame-src'?: Csp.Sources; `<div class="ts-block-property-details"></div> </div> <div class="ts-block-property">`dts 'worker-src'?: Csp.Sources; `<div class="ts-block-property-details"></div> </div> <div class="ts-block-property">`dts 'connect-src'?: Csp.Sources; `<div class="ts-block-property-details"></div> </div> <div class="ts-block-property">`dts 'font-src'?: Csp.Sources; `<div class="ts-block-property-details"></div> </div> <div class="ts-block-property">`dts 'img-src'?: Csp.Sources; `<div class="ts-block-property-details"></div> </div> <div class="ts-block-property">`dts 'manifest-src'?: Csp.Sources; `<div class="ts-block-property-details"></div> </div> <div class="ts-block-property">`dts 'media-src'?: Csp.Sources; `<div class="ts-block-property-details"></div> </div> <div class="ts-block-property">`dts 'object-src'?: Csp.Sources; `<div class="ts-block-property-details"></div> </div> <div class="ts-block-property">`dts 'prefetch-src'?: Csp.Sources; `<div class="ts-block-property-details"></div> </div> <div class="ts-block-property">`dts 'script-src'?: Array<Csp.Source | Csp.ActionSource>; `<div class="ts-block-property-details"></div> </div> <div class="ts-block-property">`dts 'script-src-elem'?: Csp.Sources; `<div class="ts-block-property-details"></div> </div> <div class="ts-block-property">`dts 'script-src-attr'?: Csp.Sources; `<div class="ts-block-property-details"></div> </div> <div class="ts-block-property">`dts 'style-src'?: Array<Csp.Source | Csp.ActionSource>; `<div class="ts-block-property-details"></div> </div> <div class="ts-block-property">`dts 'style-src-elem'?: Csp.Sources; `<div class="ts-block-property-details"></div> </div> <div class="ts-block-property">`dts 'style-src-attr'?: Csp.Sources; `<div class="ts-block-property-details"></div> </div> <div class="ts-block-property">`dts 'base-uri'?: Array<Csp.Source | Csp.ActionSource>; `<div class="ts-block-property-details"></div> </div> <div class="ts-block-property">`dts sandbox?: Array< | 'allow-downloads-without-user-activation' | 'allow-forms' | 'allow-modals' | 'allow-orientation-lock' | 'allow-pointer-lock' | 'allow-popups' | 'allow-popups-to-escape-sandbox' | 'allow-presentation' | 'allow-same-origin' | 'allow-scripts' | 'allow-storage-access-by-user-activation' | 'allow-top-navigation' | 'allow-top-navigation-by-user-activation' >; `<div class="ts-block-property-details"></div> </div> <div class="ts-block-property">`dts 'form-action'?: Array<Csp.Source | Csp.ActionSource>; `<div class="ts-block-property-details"></div> </div> <div class="ts-block-property">`dts 'frame-ancestors'?: Array<Csp.HostSource | Csp.SchemeSource | Csp.FrameSource>; `<div class="ts-block-property-details"></div> </div> <div class="ts-block-property">`dts 'navigate-to'?: Array<Csp.Source | Csp.ActionSource>; `<div class="ts-block-property-details"></div> </div> <div class="ts-block-property">`dts 'report-uri'?: string[]; `<div class="ts-block-property-details"></div> </div> <div class="ts-block-property">`dts 'report-to'?: string[]; `<div class="ts-block-property-details"></div> </div> <div class="ts-block-property">`dts 'require-trusted-types-for'?: Array<'script'>; `<div class="ts-block-property-details"></div> </div> <div class="ts-block-property">`dts 'trusted-types'?: Array<'none' | 'allow-duplicates' | '_' | string>; `<div class="ts-block-property-details"></div> </div> <div class="ts-block-property">`dts 'upgrade-insecure-requests'?: boolean; `<div class="ts-block-property-details"></div> </div> <div class="ts-block-property">`dts 'require-sri-for'?: Array<'script' | 'style' | 'script style'>; `<div class="ts-block-property-details"> <div class="ts-block-property-bullets"> - <span class="tag deprecated">deprecated</span> </div> </div> </div> <div class="ts-block-property">`dts 'block-all-mixed-content'?: boolean; `<div class="ts-block-property-details"> <div class="ts-block-property-bullets"> - <span class="tag deprecated">deprecated</span> </div> </div> </div> <div class="ts-block-property">`dts 'plugin-types'?: Array<`${string}/${string}` | 'none'>; `<div class="ts-block-property-details"> <div class="ts-block-property-bullets"> - <span class="tag deprecated">deprecated</span> </div> </div> </div> <div class="ts-block-property">`dts referrer?: Array< | 'no-referrer' | 'no-referrer-when-downgrade' | 'origin' | 'origin-when-cross-origin' | 'same-origin' | 'strict-origin' | 'strict-origin-when-cross-origin' | 'unsafe-url' | 'none' >; `<div class="ts-block-property-details"> <div class="ts-block-property-bullets"> - <span class="tag deprecated">deprecated</span> </div> </div> </div></div> ## HttpMethod <div class="ts-block">`dts type HttpMethod = | 'GET' | 'HEAD' | 'POST' | 'PUT' | 'DELETE' | 'PATCH' | 'OPTIONS'; `</div> ## Logger <div class="ts-block">`dts interface Logger {/_…_/} `<div class="ts-block-property">`dts (msg: string): void; `<div class="ts-block-property-details"></div> </div> <div class="ts-block-property">`dts success(msg: string): void; `<div class="ts-block-property-details"></div> </div> <div class="ts-block-property">`dts error(msg: string): void; `<div class="ts-block-property-details"></div> </div> <div class="ts-block-property">`dts warn(msg: string): void; `<div class="ts-block-property-details"></div> </div> <div class="ts-block-property">`dts minor(msg: string): void; `<div class="ts-block-property-details"></div> </div> <div class="ts-block-property">`dts info(msg: string): void; `<div class="ts-block-property-details"></div> </div></div> ## MaybePromise <div class="ts-block">`dts type MaybePromise<T> = T | Promise<T>; `</div> ## PrerenderEntryGeneratorMismatchHandler <div class="ts-block">`dts interface PrerenderEntryGeneratorMismatchHandler {/_…_/} `<div class="ts-block-property">`dts (details: { generatedFromId: string; entry: string; matchedId: string; message: string }): void; `<div class="ts-block-property-details"></div> </div></div> ## PrerenderEntryGeneratorMismatchHandlerValue <div class="ts-block">`dts type PrerenderEntryGeneratorMismatchHandlerValue = | 'fail' | 'warn' | 'ignore' | PrerenderEntryGeneratorMismatchHandler; `</div> ## PrerenderHttpErrorHandler <div class="ts-block">`dts interface PrerenderHttpErrorHandler {/_…_/} `<div class="ts-block-property">`dts (details: { status: number; path: string; referrer: string | null; referenceType: 'linked' | 'fetched'; message: string; }): void; `<div class="ts-block-property-details"></div> </div></div> ## PrerenderHttpErrorHandlerValue <div class="ts-block">`dts type PrerenderHttpErrorHandlerValue = | 'fail' | 'warn' | 'ignore' | PrerenderHttpErrorHandler; `</div> ## PrerenderMap <div class="ts-block">`dts type PrerenderMap = Map<string, PrerenderOption>; `</div> ## PrerenderMissingIdHandler <div class="ts-block">`dts interface PrerenderMissingIdHandler {/_…_/} `<div class="ts-block-property">`dts (details: { path: string; id: string; referrers: string[]; message: string }): void; `<div class="ts-block-property-details"></div> </div></div> ## PrerenderMissingIdHandlerValue <div class="ts-block">`dts type PrerenderMissingIdHandlerValue = | 'fail' | 'warn' | 'ignore' | PrerenderMissingIdHandler; `</div> ## PrerenderOption <div class="ts-block">`dts type PrerenderOption = boolean | 'auto'; `</div> ## Prerendered <div class="ts-block">`dts interface Prerendered {/_…_/} `<div class="ts-block-property">`dts pages: Map< string, { /\*\* The location of the .html file relative to the output directory _/ file: string; } >; ``<div class="ts-block-property-details"> A map of `path` to `{ file }` objects, where a path like `/foo` corresponds to `foo.html` and a path like `/bar/` corresponds to `bar/index.html`. </div> </div> <div class="ts-block-property">``dts assets: Map< string, { /\*_ The MIME type of the asset _/ type: string; } >; ``<div class="ts-block-property-details"> A map of `path` to `{ type }` objects. </div> </div> <div class="ts-block-property">``dts redirects: Map< string, { status: number; location: string; } >; `<div class="ts-block-property-details"> A map of redirects encountered during prerendering. </div> </div> <div class="ts-block-property">`dts paths: string[]; `<div class="ts-block-property-details"> An array of prerendered paths (without trailing slashes, regardless of the trailingSlash config) </div> </div></div> ## RequestOptions <div class="ts-block">`dts interface RequestOptions {/_…_/} `<div class="ts-block-property">`dts getClientAddress(): string; `<div class="ts-block-property-details"></div> </div> <div class="ts-block-property">`dts platform?: App.Platform; `<div class="ts-block-property-details"></div> </div></div> ## RouteSegment <div class="ts-block">`dts interface RouteSegment {/_…_/} `<div class="ts-block-property">`dts content: string; `<div class="ts-block-property-details"></div> </div> <div class="ts-block-property">`dts dynamic: boolean; `<div class="ts-block-property-details"></div> </div> <div class="ts-block-property">`dts rest: boolean; `<div class="ts-block-property-details"></div> </div></div> ## TrailingSlash <div class="ts-block">`dts type TrailingSlash = 'never' | 'always' | 'ignore';``` </div>

## docs/kit/98-reference/15-@sveltejs-kit-hooks.md

--- title: @sveltejs/kit/hooks --- `js // @noErrors import { sequence } from '@sveltejs/kit/hooks';` ## sequence A helper function for sequencing multiple `handle` calls in a middleware-like manner. The behavior for the `handle` options is as follows: - `transformPageChunk` is applied in reverse order and merged - `preload` is applied in forward order, the first option "wins" and no `preload` options after it are called - `filterSerializedResponseHeaders` behaves the same as `preload` `js // @errors: 7031 /// file: src/hooks.server.js import { sequence } from '@sveltejs/kit/hooks'; /** @type {import('@sveltejs/kit').Handle} */ async function first({ event, resolve }) { console.log('first pre-processing'); const result = await resolve(event, { transformPageChunk: ({ html }) => { // transforms are applied in reverse order console.log('first transform'); return html; }, preload: () => { // this one wins as it's the first defined in the chain console.log('first preload'); return true; } }); console.log('first post-processing'); return result; } /** @type {import('@sveltejs/kit').Handle} */ async function second({ event, resolve }) { console.log('second pre-processing'); const result = await resolve(event, { transformPageChunk: ({ html }) => { console.log('second transform'); return html; }, preload: () => { console.log('second preload'); return true; }, filterSerializedResponseHeaders: () => { // this one wins as it's the first defined in the chain console.log('second filterSerializedResponseHeaders'); return true; } }); console.log('second post-processing'); return result; } export const handle = sequence(first, second);` The example above would print: `first pre-processing first preload second pre-processing second filterSerializedResponseHeaders second transform first transform second post-processing first post-processing` <div class="ts-block"> `dts function sequence( ...handlers: import('@sveltejs/kit').Handle[] ): import('@sveltejs/kit').Handle;` </div>

## docs/kit/98-reference/15-@sveltejs-kit-node-polyfills.md

--- title: @sveltejs/kit/node/polyfills --- `js // @noErrors import { installPolyfills } from '@sveltejs/kit/node/polyfills';` ## installPolyfills Make various web APIs available as globals: - `crypto` - `File` <div class="ts-block"> `dts function installPolyfills(): void;` </div>

## docs/kit/98-reference/15-@sveltejs-kit-node.md

--- title: @sveltejs/kit/node --- `js // @noErrors import { createReadableStream, getRequest, setResponse } from '@sveltejs/kit/node';` ## createReadableStream <blockquote class="since note"> Available since 2.4.0 </blockquote> Converts a file on disk to a readable stream <div class="ts-block"> `dts function createReadableStream(file: string): ReadableStream;` </div> ## getRequest <div class="ts-block"> `dts function getRequest({ request, base, bodySizeLimit }: { request: import('http').IncomingMessage; base: string; bodySizeLimit?: number; }): Promise<Request>;` </div> ## setResponse <div class="ts-block"> `dts function setResponse( res: import('http').ServerResponse, response: Response ): Promise<void>;` </div>

## docs/kit/98-reference/15-@sveltejs-kit-vite.md

--- title: @sveltejs/kit/vite --- `js // @noErrors import { sveltekit } from '@sveltejs/kit/vite';` ## sveltekit Returns the SvelteKit Vite plugins. <div class="ts-block"> `dts function sveltekit(): Promise<import('vite').Plugin[]>;` </div>

## docs/kit/98-reference/20-$app-environment.md

--- title: $app/environment --- ```js // @noErrors import { browser, building, dev, version } from '$app/environment'; ``## browser `true` if the app is running in the browser. <div class="ts-block">``dts const browser: boolean; ``</div> ## building SvelteKit analyses your app during the `build` step by running it. During this process, `building` is `true`. This also applies during prerendering. <div class="ts-block">``dts const building: boolean; ``</div> ## dev Whether the dev server is running. This is not guaranteed to correspond to `NODE_ENV` or `MODE`. <div class="ts-block">``dts const dev: boolean; ``</div> ## version The value of `config.kit.version.name`. <div class="ts-block">``dts const version: string; ``` </div>

## docs/kit/98-reference/20-$app-forms.md

--- title: $app/forms --- ```js // @noErrors import { applyAction, deserialize, enhance } from '$app/forms'; ``## applyAction This action updates the `form` property of the current page with the given data and updates `page.status`. In case of an error, it redirects to the nearest error page. <div class="ts-block">``dts function applyAction< Success extends Record<string, unknown> | undefined, Failure extends Record<string, unknown> | undefined >( result: import('@sveltejs/kit').ActionResult< Success, Failure > ): Promise<void>; `</div> ## deserialize Use this function to deserialize the response from a form submission. Usage:`js // @errors: 7031 import { deserialize } from '$app/forms'; async function handleSubmit(event) { const response = await fetch('/form?/action', { method: 'POST', body: new FormData(event.target) }); const result = deserialize(await response.text()); // ... } `<div class="ts-block">`dts function deserialize< Success extends Record<string, unknown> | undefined, Failure extends Record<string, unknown> | undefined >( result: string ): import('@sveltejs/kit').ActionResult<Success, Failure>; ``</div> ## enhance This action enhances a `<form>` element that otherwise would work without JavaScript. The `submit` function is called upon submission with the given FormData and the `action` that should be triggered. If `cancel` is called, the form will not be submitted. You can use the abort `controller` to cancel the submission in case another one starts. If a function is returned, that function is called with the response from the server. If nothing is returned, the fallback will be used. If this function or its return value isn't set, it - falls back to updating the `form` prop with the returned data if the action is on the same page as the form - updates `page.status` - resets the `<form>` element and invalidates all data in case of successful submission with no redirect response - redirects in case of a redirect response - redirects to the nearest error page in case of an unexpected error If you provide a custom function with a callback and want to use the default behavior, invoke `update` in your callback. It accepts an options object - `reset: false` if you don't want the `<form>` values to be reset after a successful submission - `invalidateAll: false` if you don't want the action to call `invalidateAll` after submission <div class="ts-block">``dts function enhance< Success extends Record<string, unknown> | undefined, Failure extends Record<string, unknown> | undefined >( form_element: HTMLFormElement, submit?: import('@sveltejs/kit').SubmitFunction< Success, Failure > ): { destroy(): void; }; ``` </div>

## docs/kit/98-reference/20-$app-navigation.md

--- title: $app/navigation --- ```js // @noErrors import { afterNavigate, beforeNavigate, disableScrollHandling, goto, invalidate, invalidateAll, onNavigate, preloadCode, preloadData, pushState, replaceState } from '$app/navigation'; ``## afterNavigate A lifecycle function that runs the supplied `callback` when the current component mounts, and also whenever we navigate to a URL. `afterNavigate` must be called during a component initialization. It remains active as long as the component is mounted. <div class="ts-block">``dts function afterNavigate( callback: ( navigation: import('@sveltejs/kit').AfterNavigate ) => void ): void; ``</div> ## beforeNavigate A navigation interceptor that triggers before we navigate to a URL, whether by clicking a link, calling `goto(...)`, or using the browser back/forward controls. Calling `cancel()` will prevent the navigation from completing. If `navigation.type === 'leave'` — meaning the user is navigating away from the app (or closing the tab) — calling `cancel` will trigger the native browser unload confirmation dialog. In this case, the navigation may or may not be cancelled depending on the user's response. When a navigation isn't to a SvelteKit-owned route (and therefore controlled by SvelteKit's client-side router), `navigation.to.route.id` will be `null`. If the navigation will (if not cancelled) cause the document to unload — in other words `'leave'` navigations and `'link'` navigations where `navigation.to.route === null` — `navigation.willUnload` is `true`. `beforeNavigate` must be called during a component initialization. It remains active as long as the component is mounted. <div class="ts-block">``dts function beforeNavigate( callback: ( navigation: import('@sveltejs/kit').BeforeNavigate ) => void ): void; ``</div> ## disableScrollHandling If called when the page is being updated following a navigation (in `onMount` or `afterNavigate` or an action, for example), this disables SvelteKit's built-in scroll handling. This is generally discouraged, since it breaks user expectations. <div class="ts-block">``dts function disableScrollHandling(): void; ``</div> ## goto Allows you to navigate programmatically to a given route, with options such as keeping the current element focused. Returns a Promise that resolves when SvelteKit navigates (or fails to navigate, in which case the promise rejects) to the specified `url`. For external URLs, use `window.location = url` instead of calling `goto(url)`. <div class="ts-block">``dts function goto( url: string | URL, opts?: | { replaceState?: boolean | undefined; noScroll?: boolean | undefined; keepFocus?: boolean | undefined; invalidateAll?: boolean | undefined; invalidate?: | (string | URL | ((url: URL) => boolean))] | undefined; state?: App.PageState | undefined; } | undefined ): Promise<void>; ``</div> ## invalidate Causes any `load` functions belonging to the currently active page to re-run if they depend on the `url` in question, via `fetch` or `depends`. Returns a `Promise` that resolves when the page is subsequently updated. If the argument is given as a `string` or `URL`, it must resolve to the same URL that was passed to `fetch` or `depends` (including query parameters). To create a custom identifier, use a string beginning with `[a-z]+:` (e.g. `custom:state`) — this is a valid URL. The `function` argument can be used define a custom predicate. It receives the full `URL` and causes `load` to rerun if `true` is returned. This can be useful if you want to invalidate based on a pattern instead of a exact match.``ts // Example: Match '/path' regardless of the query parameters import { invalidate } from '$app/navigation'; invalidate((url) => url.pathname === '/path'); `<div class="ts-block">`dts function invalidate( resource: string | URL | ((url: URL) => boolean) ): Promise<void>; ``</div> ## invalidateAll Causes all `load` functions belonging to the currently active page to re-run. Returns a `Promise` that resolves when the page is subsequently updated. <div class="ts-block">``dts function invalidateAll(): Promise<void>; ``</div> ## onNavigate A lifecycle function that runs the supplied `callback` immediately before we navigate to a new URL except during full-page navigations. If you return a `Promise`, SvelteKit will wait for it to resolve before completing the navigation. This allows you to — for example — use `document.startViewTransition`. Avoid promises that are slow to resolve, since navigation will appear stalled to the user. If a function (or a `Promise` that resolves to a function) is returned from the callback, it will be called once the DOM has updated. `onNavigate` must be called during a component initialization. It remains active as long as the component is mounted. <div class="ts-block">``dts function onNavigate( callback: ( navigation: import('@sveltejs/kit').OnNavigate ) => MaybePromise<(() => void) | void> ): void; ``</div> ## preloadCode Programmatically imports the code for routes that haven't yet been fetched. Typically, you might call this to speed up subsequent navigation. You can specify routes by any matching pathname such as `/about` (to match `src/routes/about/+page.svelte`) or `/blog/*` (to match `src/routes/blog/[slug]/+page.svelte`). Unlike `preloadData`, this won't call `load` functions. Returns a Promise that resolves when the modules have been imported. <div class="ts-block">``dts function preloadCode(pathname: string): Promise<void>; ``</div> ## preloadData Programmatically preloads the given page, which means 1. ensuring that the code for the page is loaded, and 2. calling the page's load function with the appropriate options. This is the same behaviour that SvelteKit triggers when the user taps or mouses over an `<a>` element with `data-sveltekit-preload-data`. If the next navigation is to `href`, the values returned from load will be used, making navigation instantaneous. Returns a Promise that resolves with the result of running the new route's `load` functions once the preload is complete. <div class="ts-block">``dts function preloadData(href: string): Promise< | { type: 'loaded'; status: number; data: Record<string, any>; } | { type: 'redirect'; location: string; } >; ``</div> ## pushState Programmatically create a new history entry with the given `page.state`. To use the current URL, you can pass `''` as the first argument. Used for [shallow routing. <div class="ts-block">``dts function pushState( url: string | URL, state: App.PageState ): void; ``</div> ## replaceState Programmatically replace the current history entry with the given `page.state`. To use the current URL, you can pass `''` as the first argument. Used for shallow routing. <div class="ts-block">``dts function replaceState( url: string | URL, state: App.PageState ): void; ``` </div>

## docs/kit/98-reference/20-$app-paths.md

--- title: $app/paths --- ```js // @noErrors import { assets, base, resolveRoute } from '$app/paths'; ``## assets An absolute path that matches `config.kit.paths.assets`. <div class="ts-block">``dts let assets: | '' | `https://${string}` | `http://${string}` | '/\_svelte_kit_assets'; ``</div> ## base A string that matches `config.kit.paths.base`. Example usage: `<a href="{base}/your-page">Link</a>` <div class="ts-block">``dts let base: '' | `/${string}`; `</div> ## resolveRoute Populate a route ID with params to resolve a pathname.`js // @errors: 7031 import { resolveRoute } from '$app/paths'; resolveRoute( `/blog/[slug]/[...somethingElse]`, { slug: 'hello-world', somethingElse: 'something/else' } ); // `/blog/hello-world/something/else` `<div class="ts-block">`dts function resolveRoute( id: string, params: Record<string, string | undefined> ): string; ``` </div>

## docs/kit/98-reference/20-$app-server.md

--- title: $app/server --- ```js // @noErrors import { getRequestEvent, read } from '$app/server'; ``## getRequestEvent <blockquote class="since note"> Available since 2.20.0 </blockquote> Returns the current `RequestEvent`. Can be used inside `handle`, `load` and actions (and functions called by them). In environments without `AsyncLocalStorage`, this must be called synchronously (i.e. not after an `await`). <div class="ts-block">``dts function getRequestEvent(): RequestEvent< Partial<Record<string, string>>, string | null >; `</div> ## read <blockquote class="since note"> Available since 2.4.0 </blockquote> Read the contents of an imported asset from the filesystem`js // @errors: 7031 import { read } from '$app/server'; import somefile from './somefile.txt'; const asset = read(somefile); const text = await asset.text(); `<div class="ts-block">`dts function read(asset: string): Response; ``` </div>

## docs/kit/98-reference/20-$app-state.md

--- title: $app/state --- SvelteKit makes three read-only state objects available via the `$app/state`module —`page`,`navigating`and`updated`. > This module was added in 2.12. If you're using an earlier version of SvelteKit, use`$app/stores` instead. ```js // @noErrors import { navigating, page, updated } from '$app/state'; ``## navigating A read-only object representing an in-progress navigation, with `from`, `to`, `type` and (if `type === 'popstate'`) `delta` properties. Values are `null` when no navigation is occurring, or during server rendering. <div class="ts-block">``dts const navigating: | import('@sveltejs/kit').Navigation | { from: null; to: null; type: null; willUnload: null; delta: null; complete: null; }; ``</div> ## page A read-only reactive object with information about the current page, serving several use cases: - retrieving the combined `data` of all pages/layouts anywhere in your component tree (also see loading data) - retrieving the current value of the `form` prop anywhere in your component tree (also see form actions) - retrieving the page state that was set through `goto`, `pushState` or `replaceState` (also see goto and shallow routing) - retrieving metadata such as the URL you're on, the current route and its parameters, and whether or not there was an error``svelte <!file: +layout.svelte> <script> import { page } from '$app/state'; </script> <p>Currently at {page.url.pathname}</p> {#if page.error} <span class="red">Problem detected</span> {:else} <span class="small">All systems operational</span> {/if} ``` Changes to `page` are available exclusively with runes. (The legacy reactivity syntax will not reflect any changes) ```svelte <!file: +page.svelte> <script> import { page } from '$app/state'; const id = $derived(page.params.id); // This will correctly update id for usage on this page $: badId = page.params.id; // Do not use; will never update after initial load </script> ``On the server, values can only be read during rendering (in other words _not_ in e.g. `load` functions). In the browser, the values can be read at any time. <div class="ts-block">``dts const page: import('@sveltejs/kit').Page; ``</div> ## updated A read-only reactive value that's initially `false`. If `version.pollInterval` is a non-zero value, SvelteKit will poll for new versions of the app and update `current` to `true` when it detects one. `updated.check()` will force an immediate check, regardless of polling. <div class="ts-block">``dts const updated: { get current(): boolean; check(): Promise<boolean>; }; ``` </div>

## docs/kit/98-reference/20-$app-stores.md

--- title: $app/stores --- This module contains store-based equivalents of the exports from `$app/state`. If you're using SvelteKit 2.12 or later, use that module instead. ```js // @noErrors import { getStores, navigating, page, updated } from '$app/stores'; ``` ## getStores <div class="ts-block"> ```dts function getStores(): { page: typeof page; navigating: typeof navigating; updated: typeof updated; }; ``` </div> ## navigating <blockquote class="tag deprecated note"> Use`navigating`from`$app/state` instead (requires Svelte 5, see docs for more info) </blockquote> A readable store. When navigating starts, its value is a `Navigation` object with `from`, `to`, `type` and (if `type === 'popstate'`) `delta` properties. When navigating finishes, its value reverts to `null`. On the server, this store can only be subscribed to during component initialization. In the browser, it can be subscribed to at any time. <div class="ts-block"> ```dts const navigating: import('svelte/store').Readable< import('@sveltejs/kit').Navigation | null >; ``` </div> ## page <blockquote class="tag deprecated note"> Use `page` from `$app/state`instead (requires Svelte 5, see docs for more info) </blockquote> A readable store whose value contains page data. On the server, this store can only be subscribed to during component initialization. In the browser, it can be subscribed to at any time. <div class="ts-block"> ```dts const page: import('svelte/store').Readable< import('@sveltejs/kit').Page >; ``` </div> ## updated <blockquote class="tag deprecated note"> Use`updated`from`$app/state`instead (requires Svelte 5, see docs for more info) </blockquote> A readable store whose initial value is`false`. If`version.pollInterval`is a non-zero value, SvelteKit will poll for new versions of the app and update the store value to`true`when it detects one.`updated.check()`will force an immediate check, regardless of polling. On the server, this store can only be subscribed to during component initialization. In the browser, it can be subscribed to at any time. <div class="ts-block">`dts const updated: import('svelte/store').Readable<boolean> & { check(): Promise<boolean>; }; ` </div>

## docs/kit/98-reference/25-$env-dynamic-private.md

--- title: $env/dynamic/private --- This module provides access to runtime environment variables, as defined by the platform you're running on. For example if you're using `adapter-node` (or running `vite preview`), this is equivalent to `process.env`. This module only includes variables that _do not_ begin with `config.kit.env.publicPrefix` _and do_ start with `config.kit.env.privatePrefix` (if configured). This module cannot be imported into client-side code. Dynamic environment variables cannot be used during prerendering. ```ts import { env } from '$env/dynamic/private'; console.log(env.DEPLOYMENT_SPECIFIC_VARIABLE); ```> In`dev`, `$env/dynamic`always includes environment variables from`.env`. In `prod`, this behavior will depend on your adapter.

## docs/kit/98-reference/25-$env-dynamic-public.md

--- title: $env/dynamic/public --- Similar to `$env/dynamic/private`, but only includes variables that begin with`config.kit.env.publicPrefix`(which defaults to`PUBLIC\_`), and can therefore safely be exposed to client-side code. Note that public dynamic environment variables must all be sent from the server to the client, causing larger network requests — when possible, use`$env/static/public` instead. Dynamic environment variables cannot be used during prerendering. ```ts import { env } from '$env/dynamic/public'; console.log(env.PUBLIC_DEPLOYMENT_SPECIFIC_VARIABLE); ```

## docs/kit/98-reference/25-$env-static-private.md

--- title: $env/static/private --- Environment variables loaded by Vite from `.env` files and `process.env`. Like `$env/dynamic/private`, this module cannot be imported into client-side code. This module only includes variables that _do not_ begin with`config.kit.env.publicPrefix`_and do_ start with`config.kit.env.privatePrefix`(if configured). _Unlike_`$env/dynamic/private`, the values exported from this module are statically injected into your bundle at build time, enabling optimisations like dead code elimination. ```ts import { API_KEY } from '$env/static/private'; ``Note that all environment variables referenced in your code should be declared (for example in an `.env` file), even if they don't have a value until the app is deployed:`` MY_FEATURE_FLAG="" ``You can override `.env` values from the command line like so:``bash MY_FEATURE_FLAG="enabled" npm run dev ```

## docs/kit/98-reference/25-$env-static-public.md

--- title: $env/static/public --- Similar to `$env/static/private`, except that it only includes environment variables that begin with`config.kit.env.publicPrefix`(which defaults to`PUBLIC\_`), and can therefore safely be exposed to client-side code. Values are replaced statically at build time.`ts import { PUBLIC_BASE_URL } from '$env/static/public'; `

## docs/kit/98-reference/26-$lib.md

--- title: $lib --- SvelteKit automatically makes files under `src/lib` available using the `$lib`import alias. You can change which directory this alias points to in your config file.`svelte <!file: src/lib/Component.svelte> A reusable component ``svelte <!file: src/routes/+page.svelte> <script> import Component from '$lib/Component.svelte'; </script> <Component /> `

## docs/kit/98-reference/27-$service-worker.md

--- title: $service-worker --- ```js // @noErrors import { base, build, files, prerendered, version } from '$service-worker'; ``This module is only available to service workers. ## base The `base` path of the deployment. Typically this is equivalent to `config.kit.paths.base`, but it is calculated from `location.pathname` meaning that it will continue to work correctly if the site is deployed to a subdirectory. Note that there is a `base` but no `assets`, since service workers cannot be used if `config.kit.paths.assets` is specified. <div class="ts-block">``dts const base: string; ``</div> ## build An array of URL strings representing the files generated by Vite, suitable for caching with `cache.addAll(build)`. During development, this is an empty array. <div class="ts-block">``dts const build: string]; ``</div> ## files An array of URL strings representing the files in your static directory, or whatever directory is specified by `config.kit.files.assets`. You can customize which files are included from `static` directory using [`config.kit.serviceWorker.files` <div class="ts-block">``dts const files: string]; `</div> ## prerendered An array of pathnames corresponding to prerendered pages and endpoints. During development, this is an empty array. <div class="ts-block">`dts const prerendered: string[]; ``</div> ## version See [`config.kit.version`. It's useful for generating unique cache names inside your service worker, so that a later deployment of your app can invalidate old caches. <div class="ts-block">``dts const version: string; ``` </div>

## docs/kit/98-reference/50-configuration.md

--- title: Configuration --- Your project's configuration lives in a `svelte.config.js` file at the root of your project. As well as SvelteKit, this config object is used by other tooling that integrates with Svelte such as editor extensions. `js /// file: svelte.config.js // @filename: ambient.d.ts declare module '@sveltejs/adapter-auto' { const plugin: () => import('@sveltejs/kit').Adapter; export default plugin; } // @filename: index.js //cut import adapter from '@sveltejs/adapter-auto'; /** @type {import('@sveltejs/kit').Config} */ const config = { kit: { adapter: adapter() } }; export default config;` ## Config <div class="ts-block"> `dts interface Config {/*…*/}` <div class="ts-block-property"> `dts compilerOptions?: CompileOptions;` <div class="ts-block-property-details"> <div class="ts-block-property-bullets"> - <span class="tag">default</span> `{}` </div> Options passed to `svelte.compile`. </div> </div> <div class="ts-block-property"> `dts extensions?: string];` <div class="ts-block-property-details"> <div class="ts-block-property-bullets"> - <span class="tag">default</span> `[".svelte"]` </div> List of file extensions that should be treated as Svelte files. </div> </div> <div class="ts-block-property"> `dts kit?: KitConfig;` <div class="ts-block-property-details"> SvelteKit options </div> </div> <div class="ts-block-property"> `dts preprocess?: any;` <div class="ts-block-property-details"> Preprocessor options, if any. Preprocessing can alternatively also be done through Vite's preprocessor capabilities. </div> </div> <div class="ts-block-property"> `dts vitePlugin?: PluginOptions;` <div class="ts-block-property-details"> `vite-plugin-svelte` plugin options. </div> </div> <div class="ts-block-property"> `dts [key: string]: any;` <div class="ts-block-property-details"> Any additional options required by tooling that integrates with Svelte. </div> </div></div> ## KitConfig The `kit` property configures SvelteKit, and can have the following properties: ## adapter <div class="ts-block-property-bullets"> - <span class="tag">default</span> `undefined` </div> Your [adapter is run when executing `vite build`. It determines how the output is converted for different platforms. <div class="ts-block-property-children"> </div> ## alias <div class="ts-block-property-bullets"> - <span class="tag">default</span> `{}` </div> An object containing zero or more aliases used to replace values in `import` statements. These aliases are automatically passed to Vite and TypeScript. ``js // @errors: 7031 /// file: svelte.config.js /** @type {import('@sveltejs/kit').Config} */ const config = { kit: { alias: { // this will match a file 'my-file': 'path/to/my-file.js', // this will match a directory and its contents // (`my-directory/x` resolves to `path/to/my-directory/x`) 'my-directory': 'path/to/my-directory', // an alias ending /* will only match // the contents of a directory, not the directory itself 'my-directory/*': 'path/to/my-directory/*' } } };`` <div class="ts-block-property-children"> </div> ## appDir <div class="ts-block-property-bullets"> - <span class="tag">default</span> `"_app"` </div> The directory where SvelteKit keeps its stuff, including static assets (such as JS and CSS) and internally-used routes. If `paths.assets` is specified, there will be two app directories — `${paths.assets}/${appDir}` and `${paths.base}/${appDir}`. <div class="ts-block-property-children"> </div> ## csp <div class="ts-block-property-bullets"> </div> Content Security Policy configuration. CSP helps to protect your users against cross-site scripting (XSS) attacks, by limiting the places resources can be loaded from. For example, a configuration like this... ``js // @errors: 7031 /// file: svelte.config.js /** @type {import('@sveltejs/kit').Config} */ const config = { kit: { csp: { directives: { 'script-src': 'self'] }, // must be specified with either the `report-uri` or `report-to` directives, or both reportOnly: { 'script-src': ['self'], 'report-uri': ['/'] } } } }; export default config;`` ...would prevent scripts loading from external sites. SvelteKit will augment the specified directives with nonces or hashes (depending on `mode`) for any inline styles and scripts it generates. To add a nonce for scripts and links manually included in `src/app.html`, you may use the placeholder `%sveltekit.nonce%` (for example `<script nonce="%sveltekit.nonce%">`). When pages are prerendered, the CSP header is added via a `<meta http-equiv>` tag (note that in this case, `frame-ancestors`, `report-uri` and `sandbox` directives will be ignored). If this level of configuration is insufficient and you have more dynamic requirements, you can use the [`handle` hook to roll your own CSP. <div class="ts-block-property-children"> <div class="ts-block-property"> `ts // @noErrors mode?: 'hash' | 'nonce' | 'auto';` <div class="ts-block-property-details"> Whether to use hashes or nonces to restrict `<script>` and `<style>` elements. `'auto'` will use hashes for prerendered pages, and nonces for dynamically rendered pages. </div> </div> <div class="ts-block-property"> `ts // @noErrors directives?: CspDirectives;` <div class="ts-block-property-details"> Directives that will be added to `Content-Security-Policy` headers. </div> </div> <div class="ts-block-property"> `ts // @noErrors reportOnly?: CspDirectives;` <div class="ts-block-property-details"> Directives that will be added to `Content-Security-Policy-Report-Only` headers. </div> </div> </div> ## csrf <div class="ts-block-property-bullets"> </div> Protection against cross-site request forgery (CSRF) attacks. <div class="ts-block-property-children"> <div class="ts-block-property"> `ts // @noErrors checkOrigin?: boolean;` <div class="ts-block-property-details"> <div class="ts-block-property-bullets"> - <span class="tag">default</span> `true` </div> Whether to check the incoming `origin` header for `POST`, `PUT`, `PATCH`, or `DELETE` form submissions and verify that it matches the server's origin. To allow people to make `POST`, `PUT`, `PATCH`, or `DELETE` requests with a `Content-Type` of `application/x-www-form-urlencoded`, `multipart/form-data`, or `text/plain` to your app from other origins, you will need to disable this option. Be careful! </div> </div> </div> ## embedded <div class="ts-block-property-bullets"> - <span class="tag">default</span> `false` </div> Whether or not the app is embedded inside a larger app. If `true`, SvelteKit will add its event listeners related to navigation etc on the parent of `%sveltekit.body%` instead of `window`, and will pass `params` from the server rather than inferring them from `location.pathname`. Note that it is generally not supported to embed multiple SvelteKit apps on the same page and use client-side SvelteKit features within them (things such as pushing to the history state assume a single instance). <div class="ts-block-property-children"> </div> ## env <div class="ts-block-property-bullets"> </div> Environment variable configuration <div class="ts-block-property-children"> <div class="ts-block-property"> `ts // @noErrors dir?: string;` <div class="ts-block-property-details"> <div class="ts-block-property-bullets"> - <span class="tag">default</span> `"."` </div> The directory to search for `.env` files. </div> </div> <div class="ts-block-property"> `ts // @noErrors publicPrefix?: string;` <div class="ts-block-property-details"> <div class="ts-block-property-bullets"> - <span class="tag">default</span> `"PUBLIC_"` </div> A prefix that signals that an environment variable is safe to expose to client-side code. See `$env/static/public` and `$env/dynamic/public`. Note that Vite's `envPrefix` must be set separately if you are using Vite's environment variable handling - though use of that feature should generally be unnecessary. </div> </div> <div class="ts-block-property"> `ts // @noErrors privatePrefix?: string;` <div class="ts-block-property-details"> <div class="ts-block-property-bullets"> - <span class="tag">default</span> `""` - <span class="tag since">available since</span> v1.21.0 </div> A prefix that signals that an environment variable is unsafe to expose to client-side code. Environment variables matching neither the public nor the private prefix will be discarded completely. See `$env/static/private` and `$env/dynamic/private`. </div> </div> </div> ## files <div class="ts-block-property-bullets"> </div> Where to find various files within your project. <div class="ts-block-property-children"> <div class="ts-block-property"> `ts // @noErrors assets?: string;` <div class="ts-block-property-details"> <div class="ts-block-property-bullets"> - <span class="tag">default</span> `"static"` </div> a place to put static files that should have stable URLs and undergo no processing, such as `favicon.ico` or `manifest.json` </div> </div> <div class="ts-block-property"> `ts // @noErrors hooks?: {/*…*/}` <div class="ts-block-property-details"> <div class="ts-block-property-children"><div class="ts-block-property"> `ts // @noErrors client?: string;` <div class="ts-block-property-details"> <div class="ts-block-property-bullets"> - <span class="tag">default</span> `"src/hooks.client"` </div> The location of your client hooks. </div> </div> <div class="ts-block-property"> `ts // @noErrors server?: string;` <div class="ts-block-property-details"> <div class="ts-block-property-bullets"> - <span class="tag">default</span> `"src/hooks.server"` </div> The location of your server hooks. </div> </div> <div class="ts-block-property"> `ts // @noErrors universal?: string;` <div class="ts-block-property-details"> <div class="ts-block-property-bullets"> - <span class="tag">default</span> `"src/hooks"` - <span class="tag since">available since</span> v2.3.0 </div> The location of your universal hooks. </div> </div></div> </div> </div> <div class="ts-block-property"> `ts // @noErrors lib?: string;` <div class="ts-block-property-details"> <div class="ts-block-property-bullets"> - <span class="tag">default</span> `"src/lib"` </div> your app's internal library, accessible throughout the codebase as `$lib` </div> </div> <div class="ts-block-property"> `ts // @noErrors params?: string;` <div class="ts-block-property-details"> <div class="ts-block-property-bullets"> - <span class="tag">default</span> `"src/params"` </div> a directory containing parameter matchers </div> </div> <div class="ts-block-property"> `ts // @noErrors routes?: string;` <div class="ts-block-property-details"> <div class="ts-block-property-bullets"> - <span class="tag">default</span> `"src/routes"` </div> the files that define the structure of your app (see Routing) </div> </div> <div class="ts-block-property"> `ts // @noErrors serviceWorker?: string;` <div class="ts-block-property-details"> <div class="ts-block-property-bullets"> - <span class="tag">default</span> `"src/service-worker"` </div> the location of your service worker's entry point (see Service workers) </div> </div> <div class="ts-block-property"> `ts // @noErrors appTemplate?: string;` <div class="ts-block-property-details"> <div class="ts-block-property-bullets"> - <span class="tag">default</span> `"src/app.html"` </div> the location of the template for HTML responses </div> </div> <div class="ts-block-property"> `ts // @noErrors errorTemplate?: string;` <div class="ts-block-property-details"> <div class="ts-block-property-bullets"> - <span class="tag">default</span> `"src/error.html"` </div> the location of the template for fallback error responses </div> </div> </div> ## inlineStyleThreshold <div class="ts-block-property-bullets"> - <span class="tag">default</span> `0` </div> Inline CSS inside a `<style>` block at the head of the HTML. This option is a number that specifies the maximum length of a CSS file in UTF-16 code units, as specified by the String.length property, to be inlined. All CSS files needed for the page and smaller than this value are merged and inlined in a `<style>` block. <div class="ts-block-property-children"> </div> ## moduleExtensions <div class="ts-block-property-bullets"> - <span class="tag">default</span> `".js", ".ts"]` </div> An array of file extensions that SvelteKit will treat as modules. Files with extensions that match neither `config.extensions` nor `config.kit.moduleExtensions` will be ignored by the router. <div class="ts-block-property-children"> </div> ## outDir <div class="ts-block-property-bullets"> - <span class="tag">default</span> `".svelte-kit"` </div> The directory that SvelteKit writes files to during `dev` and `build`. You should exclude this directory from version control. <div class="ts-block-property-children"> </div> ## output <div class="ts-block-property-bullets"> </div> Options related to the build output format <div class="ts-block-property-children"> <div class="ts-block-property"> `ts // @noErrors preloadStrategy?: 'modulepreload' | 'preload-js' | 'preload-mjs';` <div class="ts-block-property-details"> <div class="ts-block-property-bullets"> - <span class="tag">default</span> `"modulepreload"` - <span class="tag since">available since</span> v1.8.4 </div> SvelteKit will preload the JavaScript modules needed for the initial page to avoid import 'waterfalls', resulting in faster application startup. There are three strategies with different trade-offs: - `modulepreload` - uses `<link rel="modulepreload">`. This delivers the best results in Chromium-based browsers, in Firefox 115+, and Safari 17+. It is ignored in older browsers. - `preload-js` - uses `<link rel="preload">`. Prevents waterfalls in Chromium and Safari, but Chromium will parse each module twice (once as a script, once as a module). Causes modules to be requested twice in Firefox. This is a good setting if you want to maximise performance for users on iOS devices at the cost of a very slight degradation for Chromium users. - `preload-mjs` - uses `<link rel="preload">` but with the `.mjs` extension which prevents double-parsing in Chromium. Some static webservers will fail to serve .mjs files with a `Content-Type: application/javascript` header, which will cause your application to break. If that doesn't apply to you, this is the option that will deliver the best performance for the largest number of users, until `modulepreload` is more widely supported. </div> </div> <div class="ts-block-property"> `ts // @noErrors bundleStrategy?: 'split' | 'single' | 'inline';` <div class="ts-block-property-details"> <div class="ts-block-property-bullets"> - <span class="tag">default</span> `'split'` - <span class="tag since">available since</span> v2.13.0 </div> The bundle strategy option affects how your app's JavaScript and CSS files are loaded. - If `'split'`, splits the app up into multiple .js/.css files so that they are loaded lazily as the user navigates around the app. This is the default, and is recommended for most scenarios. - If `'single'`, creates just one .js bundle and one .css file containing code for the entire app. - If `'inline'`, inlines all JavaScript and CSS of the entire app into the HTML. The result is usable without a server (i.e. you can just open the file in your browser). When using `'split'`, you can also adjust the bundling behaviour by setting [`output.experimentalMinChunkSize` and `output.manualChunks` inside your Vite config's `build.rollupOptions`. If you want to inline your assets, you'll need to set Vite's `build.assetsInlineLimit` option to an appropriate size then import your assets through Vite. `js // @errors: 7031 /// file: vite.config.js import { sveltekit } from '@sveltejs/kit/vite'; import { defineConfig } from 'vite'; export default defineConfig({ plugins: sveltekit()], build: { // inline all imported assets assetsInlineLimit: Infinity } });` `svelte /// file: src/routes/+layout.svelte <script> // import the asset through Vite import favicon from './favicon.png'; </script> <svelte:head> <link rel="icon" href={favicon} /> </svelte:head>` </div> </div> </div> ## paths <div class="ts-block-property-bullets"> </div> <div class="ts-block-property-children"> <div class="ts-block-property"> ``ts // @noErrors assets?: '' | `http://${string}` | `https://${string}`;`` <div class="ts-block-property-details"> <div class="ts-block-property-bullets"> - <span class="tag">default</span> `""` </div> An absolute path that your app's files are served from. This is useful if your files are served from a storage bucket of some kind. </div> </div> <div class="ts-block-property"> ``ts // @noErrors base?: '' | `/${string}`;`` <div class="ts-block-property-details"> <div class="ts-block-property-bullets"> - <span class="tag">default</span> `""` </div> A root-relative path that must start, but not end with `/` (e.g. `/base-path`), unless it is the empty string. This specifies where your app is served from and allows the app to live on a non-root path. Note that you need to prepend all your root-relative links with the base value or they will point to the root of your domain, not your `base` (this is how the browser works). You can use [`base` from `$app/paths` for that: `<a href="{base}/your-page">Link</a>`. If you find yourself writing this often, it may make sense to extract this into a reusable component. </div> </div> <div class="ts-block-property"> `ts // @noErrors relative?: boolean;` <div class="ts-block-property-details"> <div class="ts-block-property-bullets"> - <span class="tag">default</span> `true` - <span class="tag since">available since</span> v1.9.0 </div> Whether to use relative asset paths. If `true`, `base` and `assets` imported from `$app/paths` will be replaced with relative asset paths during server-side rendering, resulting in more portable HTML. If `false`, `%sveltekit.assets%` and references to build artifacts will always be root-relative paths, unless `paths.assets` is an external URL Single-page app fallback pages will always use absolute paths, regardless of this setting. If your app uses a `<base>` element, you should set this to `false`, otherwise asset URLs will incorrectly be resolved against the `<base>` URL rather than the current page. In 1.0, `undefined` was a valid value, which was set by default. In that case, if `paths.assets` was not external, SvelteKit would replace `%sveltekit.assets%` with a relative path and use relative paths to reference build artifacts, but `base` and `assets` imported from `$app/paths` would be as specified in your config. </div> </div> </div> ## prerender <div class="ts-block-property-bullets"> </div> See Prerendering. <div class="ts-block-property-children"> <div class="ts-block-property"> `ts // @noErrors concurrency?: number;` <div class="ts-block-property-details"> <div class="ts-block-property-bullets"> - <span class="tag">default</span> `1` </div> How many pages can be prerendered simultaneously. JS is single-threaded, but in cases where prerendering performance is network-bound (for example loading content from a remote CMS) this can speed things up by processing other tasks while waiting on the network response. </div> </div> <div class="ts-block-property"> `ts // @noErrors crawl?: boolean;` <div class="ts-block-property-details"> <div class="ts-block-property-bullets"> - <span class="tag">default</span> `true` </div> Whether SvelteKit should find pages to prerender by following links from `entries`. </div> </div> <div class="ts-block-property"> ``ts // @noErrors entries?: Array<'*' | `/${string}`>;`` <div class="ts-block-property-details"> <div class="ts-block-property-bullets"> - <span class="tag">default</span> `"*"]` </div> An array of pages to prerender, or start crawling from (if `crawl: true`). The `*` string includes all routes containing no required `[parameters]` with optional parameters included as being empty (since SvelteKit doesn't know what value any parameters should have). </div> </div> <div class="ts-block-property"> `ts // @noErrors handleHttpError?: PrerenderHttpErrorHandlerValue;` <div class="ts-block-property-details"> <div class="ts-block-property-bullets"> - <span class="tag">default</span> `"fail"` - <span class="tag since">available since</span> v1.15.7 </div> How to respond to HTTP errors encountered while prerendering the app. - `'fail'` — fail the build - `'ignore'` - silently ignore the failure and continue - `'warn'` — continue, but print a warning - `(details) => void` — a custom error handler that takes a `details` object with `status`, `path`, `referrer`, `referenceType` and `message` properties. If you `throw` from this function, the build will fail `js // @errors: 7031 /// file: svelte.config.js /** @type {import('@sveltejs/kit').Config} */ const config = { kit: { prerender: { handleHttpError: ({ path, referrer, message }) => { // ignore deliberate link to shiny 404 page if (path === '/not-found' && referrer === '/blog/how-we-built-our-404-page') { return; } // otherwise fail the build throw new Error(message); } } } };` </div> </div> <div class="ts-block-property"> `ts // @noErrors handleMissingId?: PrerenderMissingIdHandlerValue;` <div class="ts-block-property-details"> <div class="ts-block-property-bullets"> - <span class="tag">default</span> `"fail"` - <span class="tag since">available since</span> v1.15.7 </div> How to respond when hash links from one prerendered page to another don't correspond to an `id` on the destination page. - `'fail'` — fail the build - `'ignore'` - silently ignore the failure and continue - `'warn'` — continue, but print a warning - `(details) => void` — a custom error handler that takes a `details` object with `path`, `id`, `referrers` and `message` properties. If you `throw` from this function, the build will fail </div> </div> <div class="ts-block-property"> `ts // @noErrors handleEntryGeneratorMismatch?: PrerenderEntryGeneratorMismatchHandlerValue;` <div class="ts-block-property-details"> <div class="ts-block-property-bullets"> - <span class="tag">default</span> `"fail"` - <span class="tag since">available since</span> v1.16.0 </div> How to respond when an entry generated by the `entries` export doesn't match the route it was generated from. - `'fail'` — fail the build - `'ignore'` - silently ignore the failure and continue - `'warn'` — continue, but print a warning - `(details) => void` — a custom error handler that takes a `details` object with `generatedFromId`, `entry`, `matchedId` and `message` properties. If you `throw` from this function, the build will fail </div> </div> <div class="ts-block-property"> `ts // @noErrors origin?: string;` <div class="ts-block-property-details"> <div class="ts-block-property-bullets"> - <span class="tag">default</span> `"http://sveltekit-prerender"` </div> The value of `url.origin` during prerendering; useful if it is included in rendered content. </div> </div> </div> ## router <div class="ts-block-property-bullets"> </div> <div class="ts-block-property-children"> <div class="ts-block-property"> `ts // @noErrors type?: 'pathname' | 'hash';` <div class="ts-block-property-details"> <div class="ts-block-property-bullets"> - <span class="tag">default</span> `"pathname"` - <span class="tag since">available since</span> v2.14.0 </div> What type of client-side router to use. - `'pathname'` is the default and means the current URL pathname determines the route - `'hash'` means the route is determined by `location.hash`. In this case, SSR and prerendering are disabled. This is only recommended if `pathname` is not an option, for example because you don't control the webserver where your app is deployed. It comes with some caveats: you can't use server-side rendering (or indeed any server logic), and you have to make sure that the links in your app all start with #/, or they won't work. Beyond that, everything works exactly like a normal SvelteKit app. </div> </div> <div class="ts-block-property"> `ts // @noErrors resolution?: 'client' | 'server';` <div class="ts-block-property-details"> <div class="ts-block-property-bullets"> - <span class="tag">default</span> `"client"` - <span class="tag since">available since</span> v2.17.0 </div> How to determine which route to load when navigating to a new page. By default, SvelteKit will serve a route manifest to the browser. When navigating, this manifest is used (along with the `reroute` hook, if it exists) to determine which components to load and which `load` functions to run. Because everything happens on the client, this decision can be made immediately. The drawback is that the manifest needs to be loaded and parsed before the first navigation can happen, which may have an impact if your app contains many routes. Alternatively, SvelteKit can determine the route on the server. This means that for every navigation to a path that has not yet been visited, the server will be asked to determine the route. This has several advantages: - The client does not need to load the routing manifest upfront, which can lead to faster initial page loads - The list of routes is hidden from public view - The server has an opportunity to intercept each navigation (for example through a middleware), enabling (for example) A/B testing opaque to SvelteKit The drawback is that for unvisited paths, resolution will take slightly longer (though this is mitigated by [preloading). </div> </div> </div> ## serviceWorker <div class="ts-block-property-bullets"> </div> <div class="ts-block-property-children"> <div class="ts-block-property"> `ts // @noErrors register?: boolean;` <div class="ts-block-property-details"> <div class="ts-block-property-bullets"> - <span class="tag">default</span> `true` </div> Whether to automatically register the service worker, if it exists. </div> </div> <div class="ts-block-property"> `ts // @noErrors files?(filepath: string): boolean;` <div class="ts-block-property-details"> <div class="ts-block-property-bullets"> - <span class="tag">default</span> `(filename) => !/\.DS_Store/.test(filename)` </div> Determine which files in your `static` directory will be available in `$service-worker.files`. </div> </div> </div> ## typescript <div class="ts-block-property-bullets"> </div> <div class="ts-block-property-children"> <div class="ts-block-property"> `ts // @noErrors config?: (config: Record<string, any>) => Record<string, any> | void;` <div class="ts-block-property-details"> <div class="ts-block-property-bullets"> - <span class="tag">default</span> `(config) => config` - <span class="tag since">available since</span> v1.3.0 </div> A function that allows you to edit the generated `tsconfig.json`. You can mutate the config (recommended) or return a new one. This is useful for extending a shared `tsconfig.json` in a monorepo root, for example. </div> </div> </div> ## version <div class="ts-block-property-bullets"> </div> Client-side navigation can be buggy if you deploy a new version of your app while people are using it. If the code for the new page is already loaded, it may have stale content; if it isn't, the app's route manifest may point to a JavaScript file that no longer exists. SvelteKit helps you solve this problem through version management. If SvelteKit encounters an error while loading the page and detects that a new version has been deployed (using the `name` specified here, which defaults to a timestamp of the build) it will fall back to traditional full-page navigation. Not all navigations will result in an error though, for example if the JavaScript for the next page is already loaded. If you still want to force a full-page navigation in these cases, use techniques such as setting the `pollInterval` and then using `beforeNavigate`: `html /// file: +layout.svelte <script> import { beforeNavigate } from '$app/navigation'; import { updated } from '$app/state'; beforeNavigate(({ willUnload, to }) => { if (updated.current && !willUnload && to?.url) { location.href = to.url.href; } }); </script>` If you set `pollInterval` to a non-zero value, SvelteKit will poll for new versions in the background and set the value of `updated.current` `true` when it detects one. <div class="ts-block-property-children"> <div class="ts-block-property"> `ts // @noErrors name?: string;` <div class="ts-block-property-details"> The current app version string. If specified, this must be deterministic (e.g. a commit ref rather than `Math.random()` or `Date.now().toString()`), otherwise defaults to a timestamp of the build. For example, to use the current commit hash, you could do use `git rev-parse HEAD`: `js // @errors: 7031 /// file: svelte.config.js import * as child_process from 'node:child_process'; export default { kit: { version: { name: child_process.execSync('git rev-parse HEAD').toString().trim() } } };` </div> </div> <div class="ts-block-property"> `ts // @noErrors pollInterval?: number;` <div class="ts-block-property-details"> <div class="ts-block-property-bullets"> - <span class="tag">default</span> `0` </div> The interval in milliseconds to poll for version changes. If this is `0`, no polling occurs. </div> </div> </div>

## docs/kit/98-reference/52-cli.md

--- title: Command Line Interface --- SvelteKit projects use Vite, meaning you'll mostly use its CLI (albeit via `npm run dev/build/preview` scripts): - `vite dev` — start a development server - `vite build` — build a production version of your app - `vite preview` — run the production version locally However SvelteKit includes its own CLI for initialising your project: ## svelte-kit sync `svelte-kit sync` creates the `tsconfig.json` and all generated types (which you can import as `./$types` inside routing files) for your project. When you create a new project, it is listed as the `prepare` script and will be run automatically as part of the npm lifecycle, so you should not ordinarily have to run this command.

## docs/kit/98-reference/54-types.md

--- title: Types --- ## Generated types The `RequestHandler` and `Load` types both accept a `Params` argument allowing you to type the `params` object. For example this endpoint expects `foo`, `bar` and `baz` params: `js /// file: src/routes/foo]/[bar]/[baz]/+server.js // @errors: 2355 2322 1360 /** @type {import('@sveltejs/kit').RequestHandler<{ foo: string; bar: string; baz: string }>} */ export async function GET({ params }) { // ... }` Needless to say, this is cumbersome to write out, and less portable (if you were to rename the `[foo]` directory to `[qux]`, the type would no longer reflect reality). To solve this problem, SvelteKit generates `.d.ts` files for each of your endpoints and pages: `ts /// file: .svelte-kit/types/src/routes/[foo]/[bar]/[baz]/$types.d.ts /// link: true import type * as Kit from '@sveltejs/kit'; type RouteParams = { foo: string; bar: string; baz: string; }; export type RequestHandler = Kit.RequestHandler<RouteParams>; export type PageLoad = Kit.Load<RouteParams>;` These files can be imported into your endpoints and pages as siblings, thanks to the [`rootDirs` option in your TypeScript configuration: `js /// file: src/routes/foo]/[bar]/[baz]/+server.js // @filename: $types.d.ts import type * as Kit from '@sveltejs/kit'; type RouteParams = { foo: string; bar: string; baz: string; } export type RequestHandler = Kit.RequestHandler<RouteParams>; // @filename: index.js // @errors: 2355 2322 //cut /** @type {import('./$types').RequestHandler} */ export async function GET({ params }) { // ... }` `js /// file: src/routes/[foo]/[bar]/[baz]/+page.js // @filename: $types.d.ts import type * as Kit from '@sveltejs/kit'; type RouteParams = { foo: string; bar: string; baz: string; } export type PageLoad = Kit.Load<RouteParams>; // @filename: index.js // @errors: 2355 //cut /** @type {import('./$types').PageLoad} */ export async function load({ params, fetch }) { // ... }` The return types of the load functions are then available through the `$types` module as `PageData` and `LayoutData` respectively, while the union of the return values of all `Actions` is available as `ActionData`. Starting with version 2.16.0, two additional helper types are provided: `PageProps` defines `data: PageData`, as well as `form: ActionData`, when there are actions defined, while `LayoutProps` defines `data: LayoutData`, as well as `children: Snippet`. `svelte <!file: src/routes/+page.svelte> <script> /** @type {import('./$types').PageProps} */ let { data, form } = $props(); </script>` > Before 2.16.0: > `svelte > > <script> > /** @type {{ data: import('./$types').PageData, form: import('./$types').ActionData }} */ > let { data, form } = $props(); > </script> >` > > Using Svelte 4: > `svelte > > <script> > /** @type {import('./$types').PageData} */ > export let data; > /** @type {import('./$types').ActionData} */ > export let form; > </script> >` > > `{ "extends": "./.svelte-kit/tsconfig.json" }` ### Default tsconfig.json The generated `.svelte-kit/tsconfig.json` file contains a mixture of options. Some are generated programmatically based on your project configuration, and should generally not be overridden without good reason: `json /// file: .svelte-kit/tsconfig.json { "compilerOptions": { "paths": { "$lib": ["../src/lib"], "$lib/*": ["../src/lib/*"] }, "rootDirs": ["..", "./types"] }, "include": [ "ambient.d.ts", "non-ambient.d.ts", "./types/**/$types.d.ts", "../vite.config.js", "../vite.config.ts", "../src/**/*.js", "../src/**/*.ts", "../src/**/*.svelte", "../tests/**/*.js", "../tests/**/*.ts", "../tests/**/*.svelte" ], "exclude": [ "../node_modules/**", "../src/service-worker.js", "../src/service-worker/**/*.js", "../src/service-worker.ts", "../src/service-worker/**/*.ts", "../src/service-worker.d.ts", "../src/service-worker/**/*.d.ts" ] }` Others are required for SvelteKit to work properly, and should also be left untouched unless you know what you're doing: ``json /// file: .svelte-kit/tsconfig.json { "compilerOptions": { // this ensures that types are explicitly // imported with `import type`, which is // necessary as Svelte/Vite cannot // otherwise compile components correctly "verbatimModuleSyntax": true, // Vite compiles one TypeScript module // at a time, rather than compiling // the entire module graph "isolatedModules": true, // Tell TS it's used only for type-checking "noEmit": true, // This ensures both `vite build` // and `svelte-package` work correctly "lib": ["esnext", "DOM", "DOM.Iterable"], "moduleResolution": "bundler", "module": "esnext", "target": "esnext" } }`` ## $lib This is a simple alias to `src/lib`, or whatever directory is specified as [`config.kit.files.lib`. It allows you to access common components and utility modules without `../../../../` nonsense. ### $lib/server A subdirectory of `$lib`. SvelteKit will prevent you from importing any modules in `$lib/server` into client-side code. See server-only modules. ## app.d.ts The `app.d.ts` file is home to the ambient types of your apps, i.e. types that are available without explicitly importing them. Always part of this file is the `App` namespace. This namespace contains several types that influence the shape of certain SvelteKit features you interact with. ## Error Defines the common shape of expected and unexpected errors. Expected errors are thrown using the `error` function. Unexpected errors are handled by the `handleError` hooks which should return this shape. <div class="ts-block"> ```dts interface Error {/*…*/}``` <div class="ts-block-property"> ```dts message: string;``` <div class="ts-block-property-details"></div> </div></div> ## Locals The interface that defines `event.locals`, which can be accessed in server hooks (`handle`, and `handleError`), server-only `load` functions, and `+server.js` files. <div class="ts-block"> ```dts interface Locals {}``` </div> ## PageData Defines the common shape of the page.data state and $page.data store - that is, the data that is shared between all pages. The `Load` and `ServerLoad` functions in `./$types`will be narrowed accordingly. Use optional properties for data that is only present on specific pages. Do not add an index signature (`key: string]: any`). <div class="ts-block"> ```dts interface PageData {} ``` </div> ## PageState The shape of the`page.state`object, which can be manipulated using the [`pushState`and`replaceState`functions from`$app/navigation`. <div class="ts-block"> ```dts interface PageState {} ``` </div> ## Platform If your adapter provides platform-specific context via`event.platform`, you can specify it here. <div class="ts-block">`dts interface Platform {} ` </div>

Instructions for LLMs: <SYSTEM>Always use Svelte 5 runes and Svelte 5 syntax. Runes do not need to be imported, they are globals. $state() runes are always declared using `let`, never with `const`. When passing a function to $derived, you must always use $derived.by(() => ...). Error boundaries can only catch errors during component rendering and at the top level of an $effect inside the error boundary. Error boundaries do not catch errors in onclick or other event handlers.</SYSTEM>
